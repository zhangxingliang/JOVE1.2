/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.18 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */
var h5 = {};
var lang = _language;


(function(){
    var requirejs, require, define;
    (function (global) {
        var req, s, head, baseElement, dataMain, src,
            interactiveScript, currentlyAddingScript, mainScript, subPath,
            version = '2.1.18',
            commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
            cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
            jsSuffixRegExp = /\.js$/,
            currDirRegExp = /^\.\//,
            op = Object.prototype,
            ostring = op.toString,
            hasOwn = op.hasOwnProperty,
            ap = Array.prototype,
            apsp = ap.splice,
            isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
            isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
            //PS3 indicates loaded and complete, but need to wait for complete
            //specifically. Sequence is 'loading', 'loaded', execution,
            // then 'complete'. The UA check is unfortunate, but not sure how
            //to feature test w/o causing perf issues.
            readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
                          /^complete$/ : /^(complete|loaded)$/,
            defContextName = '_',
            //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
            isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
            contexts = {},
            cfg = {},
            globalDefQueue = [],
            useInteractive = false;

        function isFunction(it) {
            return ostring.call(it) === '[object Function]';
        }

        function isArray(it) {
            return ostring.call(it) === '[object Array]';
        }

        /**
         * Helper function for iterating over an array. If the func returns
         * a true value, it will break out of the loop.
         */
        function each(ary, func) {
            if (ary) {
                var i;
                for (i = 0; i < ary.length; i += 1) {
                    if (ary[i] && func(ary[i], i, ary)) {
                        break;
                    }
                }
            }
        }

        /**
         * Helper function for iterating over an array backwards. If the func
         * returns a true value, it will break out of the loop.
         */
        function eachReverse(ary, func) {
            if (ary) {
                var i;
                for (i = ary.length - 1; i > -1; i -= 1) {
                    if (ary[i] && func(ary[i], i, ary)) {
                        break;
                    }
                }
            }
        }

        function hasProp(obj, prop) {
            return hasOwn.call(obj, prop);
        }

        function getOwn(obj, prop) {
            return hasProp(obj, prop) && obj[prop];
        }

        /**
         * Cycles over properties in an object and calls a function for each
         * property value. If the function returns a truthy value, then the
         * iteration is stopped.
         */
        function eachProp(obj, func) {
            var prop;
            for (prop in obj) {
                if (hasProp(obj, prop)) {
                    if (func(obj[prop], prop)) {
                        break;
                    }
                }
            }
        }

        /**
         * Simple function to mix in properties from source into target,
         * but only if target does not already have a property of the same name.
         */
        function mixin(target, source, force, deepStringMixin) {
            if (source) {
                eachProp(source, function (value, prop) {
                    if (force || !hasProp(target, prop)) {
                        if (deepStringMixin && typeof value === 'object' && value &&
                            !isArray(value) && !isFunction(value) &&
                            !(value instanceof RegExp)) {

                            if (!target[prop]) {
                                target[prop] = {};
                            }
                            mixin(target[prop], value, force, deepStringMixin);
                        } else {
                            target[prop] = value;
                        }
                    }
                });
            }
            return target;
        }

        //Similar to Function.prototype.bind, but the 'this' object is specified
        //first, since it is easier to read/figure out what 'this' will be.
        function bind(obj, fn) {
            return function () {
                return fn.apply(obj, arguments);
            };
        }

        function scripts() {
            return document.getElementsByTagName('script');
        }

        function defaultOnError(err) {
            throw err;
        }

        //Allow getting a global that is expressed in
        //dot notation, like 'a.b.c'.
        function getGlobal(value) {
            if (!value) {
                return value;
            }
            var g = global;
            each(value.split('.'), function (part) {
                g = g[part];
            });
            return g;
        }

        /**
         * Constructs an error with a pointer to an URL with more information.
         * @param {String} id the error ID that maps to an ID on a web page.
         * @param {String} message human readable error.
         * @param {Error} [err] the original error, if there is one.
         *
         * @returns {Error}
         */
        function makeError(id, msg, err, requireModules) {
            var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
            e.requireType = id;
            e.requireModules = requireModules;
            if (err) {
                e.originalError = err;
            }
            return e;
        }

        if (typeof define !== 'undefined') {
            //If a define is already in play via another AMD loader,
            //do not overwrite.
            return;
        }

        if (typeof requirejs !== 'undefined') {
            if (isFunction(requirejs)) {
                //Do not overwrite an existing requirejs instance.
                return;
            }
            cfg = requirejs;
            requirejs = undefined;
        }

        //Allow for a require config object
        if (typeof require !== 'undefined' && !isFunction(require)) {
            //assume it is a config object.
            cfg = require;
            require = undefined;
        }

        function newContext(contextName) {
            var inCheckLoaded, Module, context, handlers,
                checkLoadedTimeoutId,
                config = {
                    //Defaults. Do not set a default for map
                    //config to speed up normalize(), which
                    //will run faster if there is no default.
                    waitSeconds: 7,
                    baseUrl: './',
                    paths: {},
                    bundles: {},
                    pkgs: {},
                    shim: {},
                    config: {}
                },
                registry = {},
                //registry of just enabled modules, to speed
                //cycle breaking code when lots of modules
                //are registered, but not activated.
                enabledRegistry = {},
                undefEvents = {},
                defQueue = [],
                defined = {},
                urlFetched = {},
                bundlesMap = {},
                requireCounter = 1,
                unnormalizedCounter = 1;

            /**
             * Trims the . and .. from an array of path segments.
             * It will keep a leading path segment if a .. will become
             * the first path segment, to help with module name lookups,
             * which act like paths, but can be remapped. But the end result,
             * all paths that use this function should look normalized.
             * NOTE: this method MODIFIES the input array.
             * @param {Array} ary the array of path segments.
             */
            function trimDots(ary) {
                var i, part;
                for (i = 0; i < ary.length; i++) {
                    part = ary[i];
                    if (part === '.') {
                        ary.splice(i, 1);
                        i -= 1;
                    } else if (part === '..') {
                        // If at the start, or previous value is still ..,
                        // keep them so that when converted to a path it may
                        // still work when converted to a path, even though
                        // as an ID it is less than ideal. In larger point
                        // releases, may be better to just kick out an error.
                        if (i === 0 || (i === 1 && ary[2] === '..') || ary[i - 1] === '..') {
                            continue;
                        } else if (i > 0) {
                            ary.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
            }

            /**
             * Given a relative module name, like ./something, normalize it to
             * a real name that can be mapped to a path.
             * @param {String} name the relative name
             * @param {String} baseName a real name that the name arg is relative
             * to.
             * @param {Boolean} applyMap apply the map config to the value. Should
             * only be done if this normalization is for a dependency ID.
             * @returns {String} normalized name
             */
            function normalize(name, baseName, applyMap) {
                var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                    foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                    baseParts = (baseName && baseName.split('/')),
                    map = config.map,
                    starMap = map && map['*'];

                //Adjust any relative paths.
                if (name) {
                    name = name.split('/');
                    lastIndex = name.length - 1;

                    // If wanting node ID compatibility, strip .js from end
                    // of IDs. Have to do this here, and not in nameToUrl
                    // because node allows either .js or non .js to map
                    // to same file.
                    if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                        name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                    }

                    // Starts with a '.' so need the baseName
                    if (name[0].charAt(0) === '.' && baseParts) {
                        //Convert baseName to array, and lop off the last part,
                        //so that . matches that 'directory' and not name of the baseName's
                        //module. For instance, baseName of 'one/two/three', maps to
                        //'one/two/three.js', but we want the directory, 'one/two' for
                        //this normalization.
                        normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                        name = normalizedBaseParts.concat(name);
                    }

                    trimDots(name);
                    name = name.join('/');
                }

                //Apply map config if available.
                if (applyMap && map && (baseParts || starMap)) {
                    nameParts = name.split('/');

                    outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                        nameSegment = nameParts.slice(0, i).join('/');

                        if (baseParts) {
                            //Find the longest baseName segment match in the config.
                            //So, do joins on the biggest to smallest lengths of baseParts.
                            for (j = baseParts.length; j > 0; j -= 1) {
                                mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                                //baseName segment has config, find if it has one for
                                //this name.
                                if (mapValue) {
                                    mapValue = getOwn(mapValue, nameSegment);
                                    if (mapValue) {
                                        //Match, update name to the new value.
                                        foundMap = mapValue;
                                        foundI = i;
                                        break outerLoop;
                                    }
                                }
                            }
                        }

                        //Check for a star map match, but just hold on to it,
                        //if there is a shorter segment match later in a matching
                        //config, then favor over this star map.
                        if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                            foundStarMap = getOwn(starMap, nameSegment);
                            starI = i;
                        }
                    }

                    if (!foundMap && foundStarMap) {
                        foundMap = foundStarMap;
                        foundI = starI;
                    }

                    if (foundMap) {
                        nameParts.splice(0, foundI, foundMap);
                        name = nameParts.join('/');
                    }
                }

                // If the name points to a package's name, use
                // the package main instead.
                pkgMain = getOwn(config.pkgs, name);

                return pkgMain ? pkgMain : name;
            }

            function removeScript(name) {
                if (isBrowser) {
                    each(scripts(), function (scriptNode) {
                        if (scriptNode.getAttribute('data-requiremodule') === name &&
                                scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                            scriptNode.parentNode.removeChild(scriptNode);
                            return true;
                        }
                    });
                }
            }

            function hasPathFallback(id) {
                var pathConfig = getOwn(config.paths, id);
                if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                    //Pop off the first array value, since it failed, and
                    //retry
                    pathConfig.shift();
                    context.require.undef(id);

                    //Custom require that does not do map translation, since
                    //ID is "absolute", already mapped/resolved.
                    context.makeRequire(null, {
                        skipMap: true
                    })([id]);

                    return true;
                }
            }

            //Turns a plugin!resource to [plugin, resource]
            //with the plugin being undefined if the name
            //did not have a plugin prefix.
            function splitPrefix(name) {
                var prefix,
                    index = name ? name.indexOf('!') : -1;
                if (index > -1) {
                    prefix = name.substring(0, index);
                    name = name.substring(index + 1, name.length);
                }
                return [prefix, name];
            }

            /**
             * Creates a module mapping that includes plugin prefix, module
             * name, and path. If parentModuleMap is provided it will
             * also normalize the name via require.normalize()
             *
             * @param {String} name the module name
             * @param {String} [parentModuleMap] parent module map
             * for the module name, used to resolve relative names.
             * @param {Boolean} isNormalized: is the ID already normalized.
             * This is true if this call is done for a define() module ID.
             * @param {Boolean} applyMap: apply the map config to the ID.
             * Should only be true if this map is for a dependency.
             *
             * @returns {Object}
             */
            function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
                var url, pluginModule, suffix, nameParts,
                    prefix = null,
                    parentName = parentModuleMap ? parentModuleMap.name : null,
                    originalName = name,
                    isDefine = true,
                    normalizedName = '';

                //If no name, then it means it is a require call, generate an
                //internal name.
                if (!name) {
                    isDefine = false;
                    name = '_@r' + (requireCounter += 1);
                }

                nameParts = splitPrefix(name);
                prefix = nameParts[0];
                name = nameParts[1];

                if (prefix) {
                    prefix = normalize(prefix, parentName, applyMap);
                    pluginModule = getOwn(defined, prefix);
                }

                //Account for relative paths if there is a base name.
                if (name) {
                    if (prefix) {
                        if (pluginModule && pluginModule.normalize) {
                            //Plugin is loaded, use its normalize method.
                            normalizedName = pluginModule.normalize(name, function (name) {
                                return normalize(name, parentName, applyMap);
                            });
                        } else {
                            // If nested plugin references, then do not try to
                            // normalize, as it will not normalize correctly. This
                            // places a restriction on resourceIds, and the longer
                            // term solution is not to normalize until plugins are
                            // loaded and all normalizations to allow for async
                            // loading of a loader plugin. But for now, fixes the
                            // common uses. Details in #1131
                            normalizedName = name.indexOf('!') === -1 ?
                                             normalize(name, parentName, applyMap) :
                                             name;
                        }
                    } else {
                        //A regular module.
                        normalizedName = normalize(name, parentName, applyMap);

                        //Normalized name may be a plugin ID due to map config
                        //application in normalize. The map config values must
                        //already be normalized, so do not need to redo that part.
                        nameParts = splitPrefix(normalizedName);
                        prefix = nameParts[0];
                        normalizedName = nameParts[1];
                        isNormalized = true;

                        url = context.nameToUrl(normalizedName);
                    }
                }

                //If the id is a plugin id that cannot be determined if it needs
                //normalization, stamp it with a unique ID so two matching relative
                //ids that may conflict can be separate.
                suffix = prefix && !pluginModule && !isNormalized ?
                         '_unnormalized' + (unnormalizedCounter += 1) :
                         '';

                return {
                    prefix: prefix,
                    name: normalizedName,
                    parentMap: parentModuleMap,
                    unnormalized: !!suffix,
                    url: url,
                    originalName: originalName,
                    isDefine: isDefine,
                    id: (prefix ?
                            prefix + '!' + normalizedName :
                            normalizedName) + suffix
                };
            }

            function getModule(depMap) {
                var id = depMap.id,
                    mod = getOwn(registry, id);

                if (!mod) {
                    mod = registry[id] = new context.Module(depMap);
                }

                return mod;
            }

            function on(depMap, name, fn) {
                var id = depMap.id,
                    mod = getOwn(registry, id);

                if (hasProp(defined, id) &&
                        (!mod || mod.defineEmitComplete)) {
                    if (name === 'defined') {
                        fn(defined[id]);
                    }
                } else {
                    mod = getModule(depMap);
                    if (mod.error && name === 'error') {
                        fn(mod.error);
                    } else {
                        mod.on(name, fn);
                    }
                }
            }

            function onError(err, errback) {
                var ids = err.requireModules,
                    notified = false;

                if (errback) {
                    errback(err);
                } else {
                    each(ids, function (id) {
                        var mod = getOwn(registry, id);
                        if (mod) {
                            //Set error on module, so it skips timeout checks.
                            mod.error = err;
                            if (mod.events.error) {
                                notified = true;
                                mod.emit('error', err);
                            }
                        }
                    });

                    if (!notified) {
                        req.onError(err);
                    }
                }
            }

            /**
             * Internal method to transfer globalQueue items to this context's
             * defQueue.
             */
            function takeGlobalQueue() {
                //Push all the globalDefQueue items into the context's defQueue
                if (globalDefQueue.length) {
                    //Array splice in the values since the context code has a
                    //local var ref to defQueue, so cannot just reassign the one
                    //on context.
                    apsp.apply(defQueue,
                               [defQueue.length, 0].concat(globalDefQueue));
                    globalDefQueue = [];
                }
            }

            handlers = {
                'require': function (mod) {
                    if (mod.require) {
                        return mod.require;
                    } else {
                        return (mod.require = context.makeRequire(mod.map));
                    }
                },
                'exports': function (mod) {
                    mod.usingExports = true;
                    if (mod.map.isDefine) {
                        if (mod.exports) {
                            return (defined[mod.map.id] = mod.exports);
                        } else {
                            return (mod.exports = defined[mod.map.id] = {});
                        }
                    }
                },
                'module': function (mod) {
                    if (mod.module) {
                        return mod.module;
                    } else {
                        return (mod.module = {
                            id: mod.map.id,
                            uri: mod.map.url,
                            config: function () {
                                return getOwn(config.config, mod.map.id) || {};
                            },
                            exports: mod.exports || (mod.exports = {})
                        });
                    }
                }
            };

            function cleanRegistry(id) {
                //Clean up machinery used for waiting modules.
                delete registry[id];
                delete enabledRegistry[id];
            }

            function breakCycle(mod, traced, processed) {
                var id = mod.map.id;

                if (mod.error) {
                    mod.emit('error', mod.error);
                } else {
                    traced[id] = true;
                    each(mod.depMaps, function (depMap, i) {
                        var depId = depMap.id,
                            dep = getOwn(registry, depId);

                        //Only force things that have not completed
                        //being defined, so still in the registry,
                        //and only if it has not been matched up
                        //in the module already.
                        if (dep && !mod.depMatched[i] && !processed[depId]) {
                            if (getOwn(traced, depId)) {
                                mod.defineDep(i, defined[depId]);
                                mod.check(); //pass false?
                            } else {
                                breakCycle(dep, traced, processed);
                            }
                        }
                    });
                    processed[id] = true;
                }
            }

            function checkLoaded() {
                var err, usingPathFallback,
                    waitInterval = config.waitSeconds * 1000,
                    //It is possible to disable the wait interval by using waitSeconds of 0.
                    expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                    noLoads = [],
                    reqCalls = [],
                    stillLoading = false,
                    needCycleCheck = true;

                //Do not bother if this call was a result of a cycle break.
                if (inCheckLoaded) {
                    return;
                }

                inCheckLoaded = true;

                //Figure out the state of all the modules.
                eachProp(enabledRegistry, function (mod) {
                    var map = mod.map,
                        modId = map.id;

                    //Skip things that are not enabled or in error state.
                    if (!mod.enabled) {
                        return;
                    }

                    if (!map.isDefine) {
                        reqCalls.push(mod);
                    }

                    if (!mod.error) {
                        //If the module should be executed, and it has not
                        //been inited and time is up, remember it.
                        if (!mod.inited && expired) {
                            if (hasPathFallback(modId)) {
                                usingPathFallback = true;
                                stillLoading = true;
                            } else {
                                noLoads.push(modId);
                                removeScript(modId);
                            }
                        } else if (!mod.inited && mod.fetched && map.isDefine) {
                            stillLoading = true;
                            if (!map.prefix) {
                                //No reason to keep looking for unfinished
                                //loading. If the only stillLoading is a
                                //plugin resource though, keep going,
                                //because it may be that a plugin resource
                                //is waiting on a non-plugin cycle.
                                return (needCycleCheck = false);
                            }
                        }
                    }
                });

                if (expired && noLoads.length) {
                    //If wait time expired, throw error of unloaded modules.
                    err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                    err.contextName = context.contextName;
                    return onError(err);
                }

                //Not expired, check for a cycle.
                if (needCycleCheck) {
                    each(reqCalls, function (mod) {
                        breakCycle(mod, {}, {});
                    });
                }

                //If still waiting on loads, and the waiting load is something
                //other than a plugin resource, or there are still outstanding
                //scripts, then just try back later.
                if ((!expired || usingPathFallback) && stillLoading) {
                    //Something is still waiting to load. Wait for it, but only
                    //if a timeout is not already in effect.
                    if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                        checkLoadedTimeoutId = setTimeout(function () {
                            checkLoadedTimeoutId = 0;
                            checkLoaded();
                        }, 50);
                    }
                }

                inCheckLoaded = false;
            }

            Module = function (map) {
                this.events = getOwn(undefEvents, map.id) || {};
                this.map = map;
                this.shim = getOwn(config.shim, map.id);
                this.depExports = [];
                this.depMaps = [];
                this.depMatched = [];
                this.pluginMaps = {};
                this.depCount = 0;

                /* this.exports this.factory
                   this.depMaps = [],
                   this.enabled, this.fetched
                */
            };

            Module.prototype = {
                init: function (depMaps, factory, errback, options) {
                    options = options || {};

                    //Do not do more inits if already done. Can happen if there
                    //are multiple define calls for the same module. That is not
                    //a normal, common case, but it is also not unexpected.
                    if (this.inited) {
                        return;
                    }

                    this.factory = factory;

                    if (errback) {
                        //Register for errors on this module.
                        this.on('error', errback);
                    } else if (this.events.error) {
                        //If no errback already, but there are error listeners
                        //on this module, set up an errback to pass to the deps.
                        errback = bind(this, function (err) {
                            this.emit('error', err);
                        });
                    }

                    //Do a copy of the dependency array, so that
                    //source inputs are not modified. For example
                    //"shim" deps are passed in here directly, and
                    //doing a direct modification of the depMaps array
                    //would affect that config.
                    this.depMaps = depMaps && depMaps.slice(0);

                    this.errback = errback;

                    //Indicate this module has be initialized
                    this.inited = true;

                    this.ignore = options.ignore;

                    //Could have option to init this module in enabled mode,
                    //or could have been previously marked as enabled. However,
                    //the dependencies are not known until init is called. So
                    //if enabled previously, now trigger dependencies as enabled.
                    if (options.enabled || this.enabled) {
                        //Enable this module and dependencies.
                        //Will call this.check()
                        this.enable();
                    } else {
                        this.check();
                    }
                },

                defineDep: function (i, depExports) {
                    //Because of cycles, defined callback for a given
                    //export can be called more than once.
                    if (!this.depMatched[i]) {
                        this.depMatched[i] = true;
                        this.depCount -= 1;
                        this.depExports[i] = depExports;
                    }
                },

                fetch: function () {
                    if (this.fetched) {
                        return;
                    }
                    this.fetched = true;

                    context.startTime = (new Date()).getTime();

                    var map = this.map;

                    //If the manager is for a plugin managed resource,
                    //ask the plugin to load it now.
                    if (this.shim) {
                        context.makeRequire(this.map, {
                            enableBuildCallback: true
                        })(this.shim.deps || [], bind(this, function () {
                            return map.prefix ? this.callPlugin() : this.load();
                        }));
                    } else {
                        //Regular dependency.
                        return map.prefix ? this.callPlugin() : this.load();
                    }
                },

                load: function () {
                    var url = this.map.url;

                    //Regular dependency.
                    if (!urlFetched[url]) {
                        urlFetched[url] = true;
                        context.load(this.map.id, url);
                    }
                },

                /**
                 * Checks if the module is ready to define itself, and if so,
                 * define it.
                 */
                check: function () {
                    if (!this.enabled || this.enabling) {
                        return;
                    }

                    var err, cjsModule,
                        id = this.map.id,
                        depExports = this.depExports,
                        exports = this.exports,
                        factory = this.factory;

                    if (!this.inited) {
                        this.fetch();
                    } else if (this.error) {
                        this.emit('error', this.error);
                    } else if (!this.defining) {
                        //The factory could trigger another require call
                        //that would result in checking this module to
                        //define itself again. If already in the process
                        //of doing that, skip this work.
                        this.defining = true;

                        if (this.depCount < 1 && !this.defined) {
                            if (isFunction(factory)) {
                                //If there is an error listener, favor passing
                                //to that instead of throwing an error. However,
                                //only do it for define()'d  modules. require
                                //errbacks should not be called for failures in
                                //their callbacks (#699). However if a global
                                //onError is set, use that.
                                if ((this.events.error && this.map.isDefine) ||
                                    req.onError !== defaultOnError) {
                                    try {
                                        exports = context.execCb(id, factory, depExports, exports);
                                    } catch (e) {
                                        err = e;
                                    }
                                } else {
                                    exports = context.execCb(id, factory, depExports, exports);
                                }

                                // Favor return value over exports. If node/cjs in play,
                                // then will not have a return value anyway. Favor
                                // module.exports assignment over exports object.
                                if (this.map.isDefine && exports === undefined) {
                                    cjsModule = this.module;
                                    if (cjsModule) {
                                        exports = cjsModule.exports;
                                    } else if (this.usingExports) {
                                        //exports already set the defined value.
                                        exports = this.exports;
                                    }
                                }

                                if (err) {
                                    err.requireMap = this.map;
                                    err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                    err.requireType = this.map.isDefine ? 'define' : 'require';
                                    return onError((this.error = err));
                                }

                            } else {
                                //Just a literal value
                                exports = factory;
                            }

                            this.exports = exports;

                            if (this.map.isDefine && !this.ignore) {
                                defined[id] = exports;

                                if (req.onResourceLoad) {
                                    req.onResourceLoad(context, this.map, this.depMaps);
                                }
                            }

                            //Clean up
                            cleanRegistry(id);

                            this.defined = true;
                        }

                        //Finished the define stage. Allow calling check again
                        //to allow define notifications below in the case of a
                        //cycle.
                        this.defining = false;

                        if (this.defined && !this.defineEmitted) {
                            this.defineEmitted = true;
                            this.emit('defined', this.exports);
                            this.defineEmitComplete = true;
                        }

                    }
                },

                callPlugin: function () {
                    var map = this.map,
                        id = map.id,
                        //Map already normalized the prefix.
                        pluginMap = makeModuleMap(map.prefix);

                    //Mark this as a dependency for this plugin, so it
                    //can be traced for cycles.
                    this.depMaps.push(pluginMap);

                    on(pluginMap, 'defined', bind(this, function (plugin) {
                        var load, normalizedMap, normalizedMod,
                            bundleId = getOwn(bundlesMap, this.map.id),
                            name = this.map.name,
                            parentName = this.map.parentMap ? this.map.parentMap.name : null,
                            localRequire = context.makeRequire(map.parentMap, {
                                enableBuildCallback: true
                            });

                        //If current map is not normalized, wait for that
                        //normalized name to load instead of continuing.
                        if (this.map.unnormalized) {
                            //Normalize the ID if the plugin allows it.
                            if (plugin.normalize) {
                                name = plugin.normalize(name, function (name) {
                                    return normalize(name, parentName, true);
                                }) || '';
                            }

                            //prefix and name should already be normalized, no need
                            //for applying map config again either.
                            normalizedMap = makeModuleMap(map.prefix + '!' + name,
                                                          this.map.parentMap);
                            on(normalizedMap,
                                'defined', bind(this, function (value) {
                                    this.init([], function () { return value; }, null, {
                                        enabled: true,
                                        ignore: true
                                    });
                                }));

                            normalizedMod = getOwn(registry, normalizedMap.id);
                            if (normalizedMod) {
                                //Mark this as a dependency for this plugin, so it
                                //can be traced for cycles.
                                this.depMaps.push(normalizedMap);

                                if (this.events.error) {
                                    normalizedMod.on('error', bind(this, function (err) {
                                        this.emit('error', err);
                                    }));
                                }
                                normalizedMod.enable();
                            }

                            return;
                        }

                        //If a paths config, then just load that file instead to
                        //resolve the plugin, as it is built into that paths layer.
                        if (bundleId) {
                            this.map.url = context.nameToUrl(bundleId);
                            this.load();
                            return;
                        }

                        load = bind(this, function (value) {
                            this.init([], function () { return value; }, null, {
                                enabled: true
                            });
                        });

                        load.error = bind(this, function (err) {
                            this.inited = true;
                            this.error = err;
                            err.requireModules = [id];

                            //Remove temp unnormalized modules for this module,
                            //since they will never be resolved otherwise now.
                            eachProp(registry, function (mod) {
                                if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                    cleanRegistry(mod.map.id);
                                }
                            });

                            onError(err);
                        });

                        //Allow plugins to load other code without having to know the
                        //context or how to 'complete' the load.
                        load.fromText = bind(this, function (text, textAlt) {
                            /*jslint evil: true */
                            var moduleName = map.name,
                                moduleMap = makeModuleMap(moduleName),
                                hasInteractive = useInteractive;

                            //As of 2.1.0, support just passing the text, to reinforce
                            //fromText only being called once per resource. Still
                            //support old style of passing moduleName but discard
                            //that moduleName in favor of the internal ref.
                            if (textAlt) {
                                text = textAlt;
                            }

                            //Turn off interactive script matching for IE for any define
                            //calls in the text, then turn it back on at the end.
                            if (hasInteractive) {
                                useInteractive = false;
                            }

                            //Prime the system by creating a module instance for
                            //it.
                            getModule(moduleMap);

                            //Transfer any config to this other module.
                            if (hasProp(config.config, id)) {
                                config.config[moduleName] = config.config[id];
                            }

                            try {
                                req.exec(text);
                            } catch (e) {
                                return onError(makeError('fromtexteval',
                                                 'fromText eval for ' + id +
                                                ' failed: ' + e,
                                                 e,
                                                 [id]));
                            }

                            if (hasInteractive) {
                                useInteractive = true;
                            }

                            //Mark this as a dependency for the plugin
                            //resource
                            this.depMaps.push(moduleMap);

                            //Support anonymous modules.
                            context.completeLoad(moduleName);

                            //Bind the value of that module to the value for this
                            //resource ID.
                            localRequire([moduleName], load);
                        });

                        //Use parentName here since the plugin's name is not reliable,
                        //could be some weird string with no path that actually wants to
                        //reference the parentName's path.
                        plugin.load(map.name, localRequire, load, config);
                    }));

                    context.enable(pluginMap, this);
                    this.pluginMaps[pluginMap.id] = pluginMap;
                },

                enable: function () {
                    enabledRegistry[this.map.id] = this;
                    this.enabled = true;

                    //Set flag mentioning that the module is enabling,
                    //so that immediate calls to the defined callbacks
                    //for dependencies do not trigger inadvertent load
                    //with the depCount still being zero.
                    this.enabling = true;

                    //Enable each dependency
                    each(this.depMaps, bind(this, function (depMap, i) {
                        var id, mod, handler;

                        if (typeof depMap === 'string') {
                            //Dependency needs to be converted to a depMap
                            //and wired up to this module.
                            depMap = makeModuleMap(depMap,
                                                   (this.map.isDefine ? this.map : this.map.parentMap),
                                                   false,
                                                   !this.skipMap);
                            this.depMaps[i] = depMap;

                            handler = getOwn(handlers, depMap.id);

                            if (handler) {
                                this.depExports[i] = handler(this);
                                return;
                            }

                            this.depCount += 1;

                            on(depMap, 'defined', bind(this, function (depExports) {
                                if (this.undefed) {
                                    return;
                                }
                                this.defineDep(i, depExports);
                                this.check();
                            }));

                            if (this.errback) {
                                on(depMap, 'error', bind(this, this.errback));
                            } else if (this.events.error) {
                                // No direct errback on this module, but something
                                // else is listening for errors, so be sure to
                                // propagate the error correctly.
                                on(depMap, 'error', bind(this, function(err) {
                                    this.emit('error', err);
                                }));
                            }
                        }

                        id = depMap.id;
                        mod = registry[id];

                        //Skip special modules like 'require', 'exports', 'module'
                        //Also, don't call enable if it is already enabled,
                        //important in circular dependency cases.
                        if (!hasProp(handlers, id) && mod && !mod.enabled) {
                            context.enable(depMap, this);
                        }
                    }));

                    //Enable each plugin that is used in
                    //a dependency
                    eachProp(this.pluginMaps, bind(this, function (pluginMap) {
                        var mod = getOwn(registry, pluginMap.id);
                        if (mod && !mod.enabled) {
                            context.enable(pluginMap, this);
                        }
                    }));

                    this.enabling = false;

                    this.check();
                },

                on: function (name, cb) {
                    var cbs = this.events[name];
                    if (!cbs) {
                        cbs = this.events[name] = [];
                    }
                    cbs.push(cb);
                },

                emit: function (name, evt) {
                    each(this.events[name], function (cb) {
                        cb(evt);
                    });
                    if (name === 'error') {
                        //Now that the error handler was triggered, remove
                        //the listeners, since this broken Module instance
                        //can stay around for a while in the registry.
                        delete this.events[name];
                    }
                }
            };

            function callGetModule(args) {
                //Skip modules already defined.
                if (!hasProp(defined, args[0])) {
                    getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
                }
            }

            function removeListener(node, func, name, ieName) {
                //Favor detachEvent because of IE9
                //issue, see attachEvent/addEventListener comment elsewhere
                //in this file.
                if (node.detachEvent && !isOpera) {
                    //Probably IE. If not it will throw an error, which will be
                    //useful to know.
                    if (ieName) {
                        node.detachEvent(ieName, func);
                    }
                } else {
                    node.removeEventListener(name, func, false);
                }
            }

            /**
             * Given an event from a script node, get the requirejs info from it,
             * and then removes the event listeners on the node.
             * @param {Event} evt
             * @returns {Object}
             */
            function getScriptData(evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                var node = evt.currentTarget || evt.srcElement;

                //Remove the listeners once here.
                removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
                removeListener(node, context.onScriptError, 'error');

                return {
                    node: node,
                    id: node && node.getAttribute('data-requiremodule')
                };
            }

            function intakeDefines() {
                var args;

                //Any defined modules in the global queue, intake them now.
                takeGlobalQueue();

                //Make sure any remaining defQueue items get properly processed.
                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' +
                            args[args.length - 1]));
                    } else {
                        //args are id, deps, factory. Should be normalized by the
                        //define() function.
                        callGetModule(args);
                    }
                }
            }

            context = {
                config: config,
                contextName: contextName,
                registry: registry,
                defined: defined,
                urlFetched: urlFetched,
                defQueue: defQueue,
                Module: Module,
                makeModuleMap: makeModuleMap,
                nextTick: req.nextTick,
                onError: onError,

                /**
                 * Set a configuration for the context.
                 * @param {Object} cfg config object to integrate.
                 */
                configure: function (cfg) {
                    //Make sure the baseUrl ends in a slash.
                    if (cfg.baseUrl) {
                        if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                            cfg.baseUrl += '/';
                        }
                    }

                    //Save off the paths since they require special processing,
                    //they are additive.
                    var shim = config.shim,
                        objs = {
                            paths: true,
                            bundles: true,
                            config: true,
                            map: true
                        };

                    eachProp(cfg, function (value, prop) {
                        if (objs[prop]) {
                            if (!config[prop]) {
                                config[prop] = {};
                            }
                            mixin(config[prop], value, true, true);
                        } else {
                            config[prop] = value;
                        }
                    });

                    //Reverse map the bundles
                    if (cfg.bundles) {
                        eachProp(cfg.bundles, function (value, prop) {
                            each(value, function (v) {
                                if (v !== prop) {
                                    bundlesMap[v] = prop;
                                }
                            });
                        });
                    }

                    //Merge shim
                    if (cfg.shim) {
                        eachProp(cfg.shim, function (value, id) {
                            //Normalize the structure
                            if (isArray(value)) {
                                value = {
                                    deps: value
                                };
                            }
                            if ((value.exports || value.init) && !value.exportsFn) {
                                value.exportsFn = context.makeShimExports(value);
                            }
                            shim[id] = value;
                        });
                        config.shim = shim;
                    }

                    //Adjust packages if necessary.
                    if (cfg.packages) {
                        each(cfg.packages, function (pkgObj) {
                            var location, name;

                            pkgObj = typeof pkgObj === 'string' ? {name: pkgObj} : pkgObj;

                            name = pkgObj.name;
                            location = pkgObj.location;
                            if (location) {
                                config.paths[name] = pkgObj.location;
                            }

                            //Save pointer to main module ID for pkg name.
                            //Remove leading dot in main, so main paths are normalized,
                            //and remove any trailing .js, since different package
                            //envs have different conventions: some use a module name,
                            //some use a file name.
                            config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                                         .replace(currDirRegExp, '')
                                         .replace(jsSuffixRegExp, '');
                        });
                    }

                    //If there are any "waiting to execute" modules in the registry,
                    //update the maps for them, since their info, like URLs to load,
                    //may have changed.
                    eachProp(registry, function (mod, id) {
                        //If module already has init called, since it is too
                        //late to modify them, and ignore unnormalized ones
                        //since they are transient.
                        if (!mod.inited && !mod.map.unnormalized) {
                            mod.map = makeModuleMap(id, null, true);
                        }
                    });

                    //If a deps array or a config callback is specified, then call
                    //require with those args. This is useful when require is defined as a
                    //config object before require.js is loaded.
                    if (cfg.deps || cfg.callback) {
                        context.require(cfg.deps || [], cfg.callback);
                    }
                },

                makeShimExports: function (value) {
                    function fn() {
                        var ret;
                        if (value.init) {
                            ret = value.init.apply(global, arguments);
                        }
                        return ret || (value.exports && getGlobal(value.exports));
                    }
                    return fn;
                },

                makeRequire: function (relMap, options) {
                    options = options || {};

                    function localRequire(deps, callback, errback) {
                        var id, map, requireMod;

                        if (options.enableBuildCallback && callback && isFunction(callback)) {
                            callback.__requireJsBuild = true;
                        }

                        if (typeof deps === 'string') {
                            if (isFunction(callback)) {
                                //Invalid call
                                return onError(makeError('requireargs', 'Invalid require call'), errback);
                            }

                            //If require|exports|module are requested, get the
                            //value for them from the special handlers. Caveat:
                            //this only works while module is being defined.
                            if (relMap && hasProp(handlers, deps)) {
                                return handlers[deps](registry[relMap.id]);
                            }

                            //Synchronous access to one module. If require.get is
                            //available (as in the Node adapter), prefer that.
                            if (req.get) {
                                return req.get(context, deps, relMap, localRequire);
                            }

                            //Normalize module name, if it contains . or ..
                            map = makeModuleMap(deps, relMap, false, true);
                            id = map.id;

                            if (!hasProp(defined, id)) {
                                return onError(makeError('notloaded', 'Module name "' +
                                            id +
                                            '" has not been loaded yet for context: ' +
                                            contextName +
                                            (relMap ? '' : '. Use require([])')));
                            }
                            return defined[id];
                        }

                        //Grab defines waiting in the global queue.
                        intakeDefines();

                        //Mark all the dependencies as needing to be loaded.
                        context.nextTick(function () {
                            //Some defines could have been added since the
                            //require call, collect them.
                            intakeDefines();

                            requireMod = getModule(makeModuleMap(null, relMap));

                            //Store if map config should be applied to this require
                            //call for dependencies.
                            requireMod.skipMap = options.skipMap;

                            requireMod.init(deps, callback, errback, {
                                enabled: true
                            });

                            checkLoaded();
                        });

                        return localRequire;
                    }

                    mixin(localRequire, {
                        isBrowser: isBrowser,

                        /**
                         * Converts a module name + .extension into an URL path.
                         * *Requires* the use of a module name. It does not support using
                         * plain URLs like nameToUrl.
                         */
                        toUrl: function (moduleNamePlusExt) {
                            var ext,
                                index = moduleNamePlusExt.lastIndexOf('.'),
                                segment = moduleNamePlusExt.split('/')[0],
                                isRelative = segment === '.' || segment === '..';

                            //Have a file extension alias, and it is not the
                            //dots from a relative path.
                            if (index !== -1 && (!isRelative || index > 1)) {
                                ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                                moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                            }

                            return context.nameToUrl(normalize(moduleNamePlusExt,
                                                    relMap && relMap.id, true), ext,  true);
                        },

                        defined: function (id) {
                            return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                        },

                        specified: function (id) {
                            id = makeModuleMap(id, relMap, false, true).id;
                            return hasProp(defined, id) || hasProp(registry, id);
                        }
                    });

                    //Only allow undef on top level require calls
                    if (!relMap) {
                        localRequire.undef = function (id) {
                            //Bind any waiting define() calls to this context,
                            //fix for #408
                            takeGlobalQueue();

                            var map = makeModuleMap(id, relMap, true),
                                mod = getOwn(registry, id);

                            mod.undefed = true;
                            removeScript(id);

                            delete defined[id];
                            delete urlFetched[map.url];
                            delete undefEvents[id];

                            //Clean queued defines too. Go backwards
                            //in array so that the splices do not
                            //mess up the iteration.
                            eachReverse(defQueue, function(args, i) {
                                if (args[0] === id) {
                                    defQueue.splice(i, 1);
                                }
                            });

                            if (mod) {
                                //Hold on to listeners in case the
                                //module will be attempted to be reloaded
                                //using a different config.
                                if (mod.events.defined) {
                                    undefEvents[id] = mod.events;
                                }

                                cleanRegistry(id);
                            }
                        };
                    }

                    return localRequire;
                },

                /**
                 * Called to enable a module if it is still in the registry
                 * awaiting enablement. A second arg, parent, the parent module,
                 * is passed in for context, when this method is overridden by
                 * the optimizer. Not shown here to keep code compact.
                 */
                enable: function (depMap) {
                    var mod = getOwn(registry, depMap.id);
                    if (mod) {
                        getModule(depMap).enable();
                    }
                },

                /**
                 * Internal method used by environment adapters to complete a load event.
                 * A load event could be a script load or just a load pass from a synchronous
                 * load call.
                 * @param {String} moduleName the name of the module to potentially complete.
                 */
                completeLoad: function (moduleName) {
                    var found, args, mod,
                        shim = getOwn(config.shim, moduleName) || {},
                        shExports = shim.exports;

                    takeGlobalQueue();

                    while (defQueue.length) {
                        args = defQueue.shift();
                        if (args[0] === null) {
                            args[0] = moduleName;
                            //If already found an anonymous module and bound it
                            //to this name, then this is some other anon module
                            //waiting for its completeLoad to fire.
                            if (found) {
                                break;
                            }
                            found = true;
                        } else if (args[0] === moduleName) {
                            //Found matching define call for this script!
                            found = true;
                        }

                        callGetModule(args);
                    }

                    //Do this after the cycle of callGetModule in case the result
                    //of those calls/init calls changes the registry.
                    mod = getOwn(registry, moduleName);

                    if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                        if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                            if (hasPathFallback(moduleName)) {
                                return;
                            } else {
                                return onError(makeError('nodefine',
                                                 'No define call for ' + moduleName,
                                                 null,
                                                 [moduleName]));
                            }
                        } else {
                            //A script that does not call define(), so just simulate
                            //the call for it.
                            callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                        }
                    }

                    checkLoaded();
                },

                /**
                 * Converts a module name to a file path. Supports cases where
                 * moduleName may actually be just an URL.
                 * Note that it **does not** call normalize on the moduleName,
                 * it is assumed to have already been normalized. This is an
                 * internal API, not a public one. Use toUrl for the public API.
                 */
                nameToUrl: function (moduleName, ext, skipExt) {
                    var paths, syms, i, parentModule, url,
                        parentPath, bundleId,
                        pkgMain = getOwn(config.pkgs, moduleName);

                    if (pkgMain) {
                        moduleName = pkgMain;
                    }

                    bundleId = getOwn(bundlesMap, moduleName);

                    if (bundleId) {
                        return context.nameToUrl(bundleId, ext, skipExt);
                    }

                    //If a colon is in the URL, it indicates a protocol is used and it is just
                    //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                    //or ends with .js, then assume the user meant to use an url and not a module id.
                    //The slash is important for protocol-less URLs as well as full paths.
                    if (req.jsExtRegExp.test(moduleName)) {
                        //Just a plain path, not module name lookup, so just return it.
                        //Add extension if it is included. This is a bit wonky, only non-.js things pass
                        //an extension, this method probably needs to be reworked.
                        url = moduleName + (ext || '');
                    } else {
                        //A module that needs to be converted to a path.
                        paths = config.paths;

                        syms = moduleName.split('/');
                        //For each module name segment, see if there is a path
                        //registered for it. Start with most specific name
                        //and work up from it.
                        for (i = syms.length; i > 0; i -= 1) {
                            parentModule = syms.slice(0, i).join('/');

                            parentPath = getOwn(paths, parentModule);
                            if (parentPath) {
                                //If an array, it means there are a few choices,
                                //Choose the one that is desired
                                if (isArray(parentPath)) {
                                    parentPath = parentPath[0];
                                }
                                syms.splice(0, i, parentPath);
                                break;
                            }
                        }

                        //Join the path parts together, then figure out if baseUrl is needed.
                        url = syms.join('/');
                        url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                        url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                    }

                    return config.urlArgs ? url +
                                            ((url.indexOf('?') === -1 ? '?' : '&') +
                                             config.urlArgs) : url;
                },

                //Delegates to req.load. Broken out as a separate function to
                //allow overriding in the optimizer.
                load: function (id, url) {
                    req.load(context, id, url);
                },

                /**
                 * Executes a module callback function. Broken out as a separate function
                 * solely to allow the build system to sequence the files in the built
                 * layer in the right sequence.
                 *
                 * @private
                 */
                execCb: function (name, callback, args, exports) {
                    return callback.apply(exports, args);
                },

                /**
                 * callback for script loads, used to check status of loading.
                 *
                 * @param {Event} evt the event from the browser for the script
                 * that was loaded.
                 */
                onScriptLoad: function (evt) {
                    //Using currentTarget instead of target for Firefox 2.0's sake. Not
                    //all old browsers will be supported, but this one was easy enough
                    //to support and still makes sense.
                    if (evt.type === 'load' ||
                            (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                        //Reset interactive script so a script node is not held onto for
                        //to long.
                        interactiveScript = null;

                        //Pull out the name of the module and the context.
                        var data = getScriptData(evt);
                        context.completeLoad(data.id);
                    }
                },

                /**
                 * Callback for script errors.
                 */
                onScriptError: function (evt) {
                    var data = getScriptData(evt);
                    if (!hasPathFallback(data.id)) {
                        return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                    }
                }
            };

            context.require = context.makeRequire();
            return context;
        }

        /**
         * Main entry point.
         *
         * If the only argument to require is a string, then the module that
         * is represented by that string is fetched for the appropriate context.
         *
         * If the first argument is an array, then it will be treated as an array
         * of dependency string names to fetch. An optional function callback can
         * be specified to execute when all of those dependencies are available.
         *
         * Make a local req variable to help Caja compliance (it assumes things
         * on a require that are not standardized), and to give a short
         * name for minification/local scope use.
         */
        req = requirejs = function (deps, callback, errback, optional) {

            //Find the right context, use default
            var context, config,
                contextName = defContextName;

            // Determine if have config object in the call.
            if (!isArray(deps) && typeof deps !== 'string') {
                // deps is a config object
                config = deps;
                if (isArray(callback)) {
                    // Adjust args if there are dependencies
                    deps = callback;
                    callback = errback;
                    errback = optional;
                } else {
                    deps = [];
                }
            }

            if (config && config.context) {
                contextName = config.context;
            }

            context = getOwn(contexts, contextName);
            if (!context) {
                context = contexts[contextName] = req.s.newContext(contextName);
            }

            if (config) {
                context.configure(config);
            }

            return context.require(deps, callback, errback);
        };

        /**
         * Support require.config() to make it easier to cooperate with other
         * AMD loaders on globally agreed names.
         */
        req.config = function (config) {
            return req(config);
        };

        /**
         * Execute something after the current tick
         * of the event loop. Override for other envs
         * that have a better solution than setTimeout.
         * @param  {Function} fn function to execute later.
         */
        req.nextTick = typeof setTimeout !== 'undefined' ? function (fn) {
            setTimeout(fn, 4);
        } : function (fn) { fn(); };

        /**
         * Export require as a global, but only if it does not already exist.
         */
        if (!require) {
            require = req;
        }

        req.version = version;

        //Used to filter out dependencies that are already paths.
        req.jsExtRegExp = /^\/|:|\?|\.js$/;
        req.isBrowser = isBrowser;
        s = req.s = {
            contexts: contexts,
            newContext: newContext
        };

        //Create default context.
        req({});

        //Exports some context-sensitive methods on global require.
        each([
            'toUrl',
            'undef',
            'defined',
            'specified'
        ], function (prop) {
            //Reference from contexts instead of early binding to default context,
            //so that during builds, the latest instance of the default context
            //with its config gets used.
            req[prop] = function () {
                var ctx = contexts[defContextName];
                return ctx.require[prop].apply(ctx, arguments);
            };
        });

        if (isBrowser) {
            head = s.head = document.getElementsByTagName('head')[0];
            //If BASE tag is in play, using appendChild is a problem for IE6.
            //When that browser dies, this can be removed. Details in this jQuery bug:
            //http://dev.jquery.com/ticket/2709
            baseElement = document.getElementsByTagName('base')[0];
            if (baseElement) {
                head = s.head = baseElement.parentNode;
            }
        }

        /**
         * Any errors that require explicitly generates will be passed to this
         * function. Intercept/override it if you want custom error handling.
         * @param {Error} err the error object.
         */
        req.onError = defaultOnError;

        /**
         * Creates the node for the load command. Only used in browser envs.
         */
        req.createNode = function (config, moduleName, url) {
            var node = config.xhtml ?
                    document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
                    document.createElement('script');
            node.type = config.scriptType || 'text/javascript';
            node.charset = 'utf-8';
            node.async = true;
            return node;
        };

        /**
         * Does the request to load a module for the browser case.
         * Make this a separate function to allow other environments
         * to override it.
         *
         * @param {Object} context the require context to find state.
         * @param {String} moduleName the name of the module.
         * @param {Object} url the URL to the module.
         */
        req.load = function (context, moduleName, url) {
            var config = (context && context.config) || {},
                node;
            if (isBrowser) {
                //In the browser so use a script tag
                node = req.createNode(config, moduleName, url);

                node.setAttribute('data-requirecontext', context.contextName);
                node.setAttribute('data-requiremodule', moduleName);

                //Set up load listener. Test attachEvent first because IE9 has
                //a subtle issue in its addEventListener and script onload firings
                //that do not match the behavior of all other browsers with
                //addEventListener support, which fire the onload event for a
                //script right after the script execution. See:
                //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
                //UNFORTUNATELY Opera implements attachEvent but does not follow the script
                //script execution mode.
                if (node.attachEvent &&
                    //Check if node.attachEvent is artificially added by custom script or
                    //natively supported by browser
                    //read https://github.com/jrburke/requirejs/issues/187
                    //if we can NOT find [native code] then it must NOT natively supported.
                    //in IE8, node.attachEvent does not have toString()
                    //Note the test for "[native code" with no closing brace, see:
                    //https://github.com/jrburke/requirejs/issues/273
                        !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                        !isOpera) {
                    //Probably IE. IE (at least 6-8) do not fire
                    //script onload right after executing the script, so
                    //we cannot tie the anonymous define call to a name.
                    //However, IE reports the script as being in 'interactive'
                    //readyState at the time of the define call.
                    useInteractive = true;

                    node.attachEvent('onreadystatechange', context.onScriptLoad);
                    //It would be great to add an error handler here to catch
                    //404s in IE9+. However, onreadystatechange will fire before
                    //the error handler, so that does not help. If addEventListener
                    //is used, then IE will fire error before load, but we cannot
                    //use that pathway given the connect.microsoft.com issue
                    //mentioned above about not doing the 'script execute,
                    //then fire the script load event listener before execute
                    //next script' that other browsers do.
                    //Best hope: IE10 fixes the issues,
                    //and then destroys all installs of IE 6-9.
                    //node.attachEvent('onerror', context.onScriptError);
                } else {
                    node.addEventListener('load', context.onScriptLoad, false);
                    node.addEventListener('error', context.onScriptError, false);
                }
                node.src = url;

                //For some cache cases in IE 6-8, the script executes before the end
                //of the appendChild execution, so to tie an anonymous define
                //call to the module name (which is stored on the node), hold on
                //to a reference to this node, but clear after the DOM insertion.
                currentlyAddingScript = node;
                if (baseElement) {
                    head.insertBefore(node, baseElement);
                } else {
                    head.appendChild(node);
                }
                currentlyAddingScript = null;

                return node;
            } else if (isWebWorker) {
                try {
                    //In a web worker, use importScripts. This is not a very
                    //efficient use of importScripts, importScripts will block until
                    //its script is downloaded and evaluated. However, if web workers
                    //are in play, the expectation that a build has been done so that
                    //only one script needs to be loaded anyway. This may need to be
                    //reevaluated if other use cases become common.
                    importScripts(url);

                    //Account for anonymous modules
                    context.completeLoad(moduleName);
                } catch (e) {
                    context.onError(makeError('importscripts',
                                    'importScripts failed for ' +
                                        moduleName + ' at ' + url,
                                    e,
                                    [moduleName]));
                }
            }
        };

        function getInteractiveScript() {
            if (interactiveScript && interactiveScript.readyState === 'interactive') {
                return interactiveScript;
            }

            eachReverse(scripts(), function (script) {
                if (script.readyState === 'interactive') {
                    return (interactiveScript = script);
                }
            });
            return interactiveScript;
        }

        //Look for a data-main script attribute, which could also adjust the baseUrl.
        if (isBrowser && !cfg.skipDataMain) {
            //Figure out baseUrl. Get it from the script tag with require.js in it.
            eachReverse(scripts(), function (script) {
                //Set the 'head' where we can append children by
                //using the script's parent.
                if (!head) {
                    head = script.parentNode;
                }

                //Look for a data-main attribute to set main script for the page
                //to load. If it is there, the path to data main becomes the
                //baseUrl, if it is not already set.
                dataMain = script.getAttribute('data-main');
                if (dataMain) {
                    //Preserve dataMain in case it is a path (i.e. contains '?')
                    mainScript = dataMain;

                    //Set final baseUrl if there is not already an explicit one.
                    if (!cfg.baseUrl) {
                        //Pull off the directory of data-main for use as the
                        //baseUrl.
                        src = mainScript.split('/');
                        mainScript = src.pop();
                        subPath = src.length ? src.join('/')  + '/' : './';

                        cfg.baseUrl = subPath;
                    }

                    //Strip off any trailing .js since mainScript is now
                    //like a module name.
                    mainScript = mainScript.replace(jsSuffixRegExp, '');

                    //If mainScript is still a path, fall back to dataMain
                    if (req.jsExtRegExp.test(mainScript)) {
                        mainScript = dataMain;
                    }

                    //Put the data-main script in the files to load.
                    cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                    return true;
                }
            });
        }

        /**
         * The function that handles definitions of modules. Differs from
         * require() in that a string for the module should be the first argument,
         * and the function to execute after dependencies are loaded should
         * return a value to define the module corresponding to the first argument's
         * name.
         */
        define = function (name, deps, callback) {
            var node, context;

            //Allow for anonymous modules
            if (typeof name !== 'string') {
                //Adjust args appropriately
                callback = deps;
                deps = name;
                name = null;
            }

            //This module may not have dependencies
            if (!isArray(deps)) {
                callback = deps;
                deps = null;
            }

            //If no name, and callback is a function, then figure out if it a
            //CommonJS thing with dependencies.
            if (!deps && isFunction(callback)) {
                deps = [];
                //Remove comments from the callback string,
                //look for require calls, and pull them into the dependencies,
                //but only if there are function args.
                if (callback.length) {
                    callback
                        .toString()
                        .replace(commentRegExp, '')
                        .replace(cjsRequireRegExp, function (match, dep) {
                            deps.push(dep);
                        });

                    //May be a CommonJS thing even without require calls, but still
                    //could use exports, and module. Avoid doing exports and module
                    //work though if it just needs require.
                    //REQUIRES the function to expect the CommonJS variables in the
                    //order listed below.
                    deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
                }
            }

            //If in IE 6-8 and hit an anonymous define() call, do the interactive
            //work.
            if (useInteractive) {
                node = currentlyAddingScript || getInteractiveScript();
                if (node) {
                    if (!name) {
                        name = node.getAttribute('data-requiremodule');
                    }
                    context = contexts[node.getAttribute('data-requirecontext')];
                }
            }

            //Always save off evaluating the def call until the script onload handler.
            //This allows multiple modules to be in a file without prematurely
            //tracing dependencies, and allows for anonymous module support,
            //where the module name is not known until the script onload event
            //occurs. If no context, use the global queue, and get it processed
            //in the onscript load callback.
            (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
        };

        define.amd = {
            jQuery: true
        };

        /**
         * Executes the text. Normally just uses eval, but can be modified
         * to use a better, environment-specific call. Only used for transpiling
         * loader plugins, not for plain JS modules.
         * @param {String} text the text to execute/evaluate.
         */
        req.exec = function (text) {
            /*jslint evil: true */
            return eval(text);
        };

        //Set up with config info.
        req(cfg);
    }(h5));

    this.h5 = {
        require: require,
        requirejs: requirejs,
        define: define
    };
})(this);;(function(global){
var util = {
    formatTimeString: function (totalMs) {


        var dateTime = new Date(0, 0, 0, 0, 0, 0, 0);
        dateTime.setMilliseconds(totalMs);

        var str = "";
        var h = dateTime.getHours();
        if (h > 0) {

            var hours = util.padString(dateTime.getHours(), 1, "0");
            str = hours + ":";
        }
        var minutes = util.padString(dateTime.getMinutes(), 2, "0");
        var seconds = util.padString(dateTime.getSeconds(), 2, "0");
        var ms = util.padString(dateTime.getMilliseconds(), 3, "0");

        return str + minutes + ":" + seconds + "." + ms;
    },
    toSmpteString: function (time, frameRate) {
        frameRate = frameRate || util.frameRate || 24;

        var lz = false;
        if (time < 0) {
            time = -time;
            lz = true;
        }

        var dateTime = new Date(0, 0, 0, 0, 0, 0, 0);
        dateTime.setMilliseconds(time);

        var str = "";
        var h = dateTime.getHours();
        if (h > 0) {

            var hours = util.padString(dateTime.getHours(), 1, "0");
            str = hours + ":";
        }
        var minutes = util.padString(dateTime.getMinutes(), 2, "0");
        var seconds = dateTime.getSeconds();
        var ms = dateTime.getMilliseconds();

        var f = Math.round((ms / 1000) * frameRate);

        if (f == 24) {
            seconds += 1;
            f = 0;
        }
        seconds = util.padString(seconds, 2, "0");

        return str + minutes + ":" + seconds + "." + util.padString(f, 2, "0");

    },

    toSeconds: function (timeStr, frameRate) {
        var validTimeFormat = /^([0-9]+:){0,2}[0-9]+([.;][0-9]+)?$/,
            errorMessage = "错误的时间格式",
            digitPairs, lastIndex, lastPair, firstPair,
            frameInfo, frameTime,
            frameRate = frameRate || util.frameRate || 24;

        if (typeof timeStr === "number") {
            return timeStr;
        }

        if (typeof timeStr === "string" &&
              !validTimeFormat.test(timeStr)) {
            throw new Error(errorMessage + ":" + timeStr);
        }

        digitPairs = timeStr.split(":");
        lastIndex = digitPairs.length - 1;
        lastPair = digitPairs[lastIndex];

        // Fix last element:
        if (lastPair.indexOf(".") > -1) {

            frameInfo = lastPair.split(".");
            frameTime = 0;

            if (frameRate && (typeof frameRate === "number")) {
                frameTime = parseFloat(frameInfo[1], 10) / frameRate;
            }

            digitPairs[lastIndex] = parseInt(frameInfo[0], 10) + frameTime;
        }

        firstPair = digitPairs[0];

        return {

            1: parseFloat(firstPair, 10),

            2: (parseInt(firstPair, 10) * 60) +
                  parseFloat(digitPairs[1], 10),

            3: (parseInt(firstPair, 10) * 3600) +
                (parseInt(digitPairs[1], 10) * 60) +
                  parseFloat(digitPairs[2], 10)

        }[digitPairs.length || 1];
    },

    roundTime: function (seconds, frameRate) {

        if (typeof seconds === "string") {
            seconds = util.toSeconds(seconds, frameRate);
        }


        //秒帧对齐
        frameRate = frameRate || util.frameRate || 24;

        var ns = Math.round(1000000 * 10 * seconds);

        //等于多少帧
        var f = Math.round((ns / (1000000 * 10)) * frameRate);

        var s = f / frameRate;

        s = Math.round(s * 100000) / 100000;
        return s;
    },
    isArray: function (o) {

        return Object.prototype.toString.call(o) === '[object Array]';

    },
    createReadonlyObject: function (source) {
        var target = {};

        var pobj = {};
        for (var k in source) {
            if (source.hasOwnProperty(k)) {
                var sourceProperty = source[k];
                pobj[k] = { writable: false, enumerable: true };
                if (util.isArray(sourceProperty)) {
                    pobj[k].value = util.cloneArray(sourceProperty);

                }else if (typeof (sourceProperty) == "object") {
                    pobj[k].value = util.createReadonlyObject(sourceProperty);
                } else {
                    pobj[k].value = sourceProperty;
                }
            }


        }
        Object.defineProperties(target, pobj);

        return target;
    },
    secondsToFrame: function (s, frameRate) {
        frameRate = frameRate || util.frameRate || 24;
        var ns = Math.round(1000000 * 10 * s);

        //等于多少帧
        var f = Math.round((ns / (1000000 * 10)) * frameRate);

        return f;
    },
    padString: function (value, padLength, padString) {


        var result = new String(value);

        while (result.length < padLength)
            result = padString + result;

        return result;
    },
    merge: function (destination, source) {

        if (!source)
            return;

        for (var i in source) {
            if (i == "fontDecorations") {
                console.log(i);
            }
            var destinationProperty = destination[i];
            var sourceProperty = source[i];

            if (sourceProperty == null)
                delete destination[i];
            else if (typeof (destinationProperty) == "object"
                    && typeof (sourceProperty) == "object"
                    && !(destinationProperty instanceof Array))
                util.merge(destination[i], source[i]);
            else

                destination[i] = sourceProperty;
        }
    },
    mergeForGC: function (destination, source) {

        if (!source)
            return;

        for (var i in source) {
            if (i == "fontDecorations") {
                console.log(i);
            }
            var destinationProperty = destination[i];
            var sourceProperty = source[i];

            if (sourceProperty == null)
                delete destination[i];
                //else if (typeof (destinationProperty) == "object"
                // && typeof (sourceProperty) == "object"
                //  && !(destinationProperty instanceof Array))
                //util.merge(destination[i], source[i]);
            else

                destination[i] = sourceProperty;
        }
    },
    proxy: function (context, fun) {
        var proxy = function () {
            return fun.apply(context, arguments);
        };
        proxy.source = fun;
        return proxy;
    },
    first: function (array, condition) {
        if (!array || array.length == 0) {
            return null;
        }

        for (var i = 0; i < array.length; i++) {
            var item = array[i];
            if (condition(item, i)) {
                return item;
            }
        }

    },
    forEach: function (array, fun /*, thisp */) {
        "use strict";

        if (array === void 0 || array === null)
            throw new TypeError();

        var t = Object(array);
        var len = t.length >>> 0;
        if (typeof fun !== "function")
            throw new TypeError();

        var thisp = arguments[2];
        for (var i = 0; i < len; i++) {
            if (i in t)
                fun.call(thisp, t[i], i, t);
        }
    },
    //异步迭代循环
    asyncForEach: function (array, iterator, done) {
        if (!array || array.length == 0) {
            if (done) {
                done();
            }
            return;
        }

        function next_loop(array) {
            var _array = array;
            var _idx = -1;

            return function () {
                _idx++;
                if (_idx >= _array.length) {
                    return null;
                }
                return { item: _array[_idx], idx: _idx };
            };
        }


        var next = next_loop(array);

        function executeItem(b) {
            if (!b) {
                if (done) {
                    done(b);
                }
                return;
            }
            var item = next();
            if (item == null) {
                if (done) {
                    done(b);
                }
            } else {
                iterator(item.item, item.idx, executeItem);
            }
        }

        executeItem(true);

    },
    cloneArray: function (array) {
        var a = [];
        if (array && array.length) {
            for (var i = 0; i < array.length; i++) {
                a.push(array[i]);
            }
        }
        return a;
    },
    clone: function (obj) {
        var newObj = {};
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                newObj[prop] = obj[prop];
            }
        }
        return newObj;
    },
    domFragment: function (inputString) {
        var range = document.createRange(),
            container = document.body || document.head,
            fragment,
            child;

        range.selectNode(container);
        fragment = range.createContextualFragment(inputString);

        return fragment.firstChild;
    },
};;
var Class = function () { };
Class.extend = function (properties) {
    var initializing = false;
    var functionTest = /xyz/.test(function () { xyz; }) ? /\b_super\b/ : /.*/;

    var _super = this.prototype;

    initializing = true;
    var prototype = new this();
    initializing = false;

    for (var name in properties) {
        prototype[name] = typeof properties[name] == "function" &&
        typeof _super[name] == "function" && functionTest.test(properties[name]) ?
        (function (name, fun) {
            return function () {
                var tmp = this._super;

                this._super = _super[name];
                var ret = fun.apply(this, arguments);
                this._super = tmp;

                return ret;
            };
        })(name, properties[name]) :
        properties[name];
    }

    function Class() {
        if (!initializing && this.init)
            this.init.apply(this, arguments);
    }

    Class.prototype = prototype;

    Class.constructor = Class;

    Class.extend = arguments.callee;

    return Class;
};;
//事件对象
function H5Event(type, target, data) {
    var _propagationStopped = false;

    Object.defineProperties(this, {
        type: {
            value: type
        },
        target: {
            value: target
        },
        data: {
            value: data
        },
        propagationStopped: {
            get: function () {
                return _propagationStopped;
            }
        }
    });


    this.stopPropagation = function () {
        _propagationStopped = true;
    };

    this.clone = function () {
        return new H5Event(type, target, data);
    };
}

var EventObject = Class.extend({

    init: function (options) {

        this.options = options || {};
        this.eventListeners = [];
    },

    addEventListener: function (type, callback, capture, instance) {

        this.eventListeners.push(
        {
            type: type,
            callback: callback,
            capture: capture,
            instance: instance
        });
    },
    removeEventListener: function (type, callback) {
        var e = [];
        util.forEach(this.eventListeners, function (l) {
            if (l.type === type && (l.callback === callback || l.callback.source === callback)) {
                e.push(l);
            }
        });
        var es = this.eventListeners;
        util.forEach(e, function (l) {
            var a = es.indexOf(l);
            if (a >= 0) {
                es.splice(a, 1);
            }
        });
    },

    dispatchEvent: function (eventName, eventObject) {
        var e = eventName;
        var name = eventName;
        if (e instanceof H5Event) {
            name = e.type;
        } else {
            e = new H5Event(eventName, this, eventObject);
        }

        util.forEach(this.eventListeners, function (l) {
            if (l.type === name) {

                if (l.instance) {
                    l.callback.call(l.instance, e);
                } else {
                    try{
                        l.callback(e);
                    } catch (e) {
                        console.log(e);
                    }
                }
            }
        });
    },
    //将b的事件传递给次对象
    chain: function (b, events) {

        var _this = this;
        var i = events.length;
        while (i--) {
            b.addEventListener(events[i], function (e) {
                _this.dispatchEvent(e.type, e);
            });  //this.dispatchEvent, false, this);
        }
    },
    unchain: function (b, events) {

        var i = events.length;
        while (i--) {
            b.removeEventListener(events[i], this.dispatchEvent);
        }
    },
    mergeOptions: function (userOptions, defaultOptions) {

        util.merge(this.options, defaultOptions);
        util.merge(this.options, userOptions);
    }
});
;
function logger(level) {

    this.log = function (str) {
        if (level == "debug") {
            console.log(str);
        }
    },
    this.error = function (str) {
        console.error(str);
    }
}
;var NULL_FUNCTION = function () { };
var _version = "0.0.0.1";
var _globalId = 1;

requestAnimationFrame = window.requestAnimationFrame
        || window.mozRequestAnimationFrame
        || window.webkitRequestAnimationFrame
        || window.msRequestAnimationFrame
        || window.oRequestAnimationFrame
        || function (callback) {
            setTimeout(callback, 1000 / 60);
        };
var cancelAnimationFrame = window.cancelAnimationFrame
    || window.mozCancelAnimationFrame
    || window.webkitCancelAnimationFrame
    || window.msCancelRequestAnimationFrame
    || window.oCancelAnimationFrame
    || function (id) {
        clearTimeout(id);
    };


function defaultMediaCreate(src, regEvent, useCors) {
    var v = document.createElement("video");

    regEvent(v);
    if (useCors) {
        v.crossOrigin = "anonymous";
    }
    v.setAttribute("src", src);

   // img.crossOrigin = "Anonymous";
    return v;
}

function defaultAudioMediaCreate(src, regEvent) {
    var v = document.createElement("audio");

    regEvent(v);

    v.setAttribute("src", src);

    return v;
}


var MediaError = function (code) {
    var _this = this,
        _code = code;

    Object.defineProperties(_this, {
        MEDIA_ERR_ABORTED: {
            value: 1,
            writable: false
        },
        MEDIA_ERR_NETWORK: {
            valud: 2,
            writable: false
        },
        MEDIA_ERR_DECODE: {
            valud: 3,
            writable: false
        },
        MEDIA_ERR_SRC_NOT_SUPPORTED: {
            valud: 4,
            writable: false
        },
        code: {
            get: function () {
                return _code;
            }
        }
    });
};

var ENDTYPE_NORMAL = 0, //出点等于时长
    ENDTYPE_OVERSTEP = 1, //出点大于时长
    ENDTYPE_CUT = 2; //出点小于时长

var MEDIASTATE_NONE = 0, //尚未初始化
    MEDIASTATE_INITING = 1, //初始化中
    MEDIASTATE_WAITING = 2, //等待中
    MEDIASTATE_NORMAL = 3; //正常状态

var MEDIAPHASE_NONE = 0, //尚未初始化
    MEDIAPHASE_INITING = 1, //开始初始化
    MEDIAPHASE_CREATEELEMENT = 2, //media element已被创建
    MEDIAPHASE_LOADING = 3, //已开始载入
    MEDIAPHASE_LOADEDJUMP = 4, //载入完成，但需要立即跳转
    MEDIAPHASE_PLAYING = 5, //播放中
    MEDIAPHASE_PAUSED = 6, //暂停中
    MEDIAPHASE_WAITING = 7, //等待中，（正在播放，但需要等待数据）
    MEDIAPHASE_SEEKING = 8; //跳转中

var MEDIAOPERATE_NONE = 0,
    MEDIAOPERATE_PLAY = 1, //播放
    MEDIAOPERATE_PAUSE = 2, //暂停
    MEDIAOPERATE_SEEK = 3, //跳转
    MEDIAOPERATE_LOAD = 4; //载入



var defineState = function () {
    var _this = this;

    _this.defineConst = function (obj) {
        Object.defineProperties(obj, {
            NETWORK_EMPTY: {
                value: 0,
                writable: false
            },
            NETWORK_IDLE: {
                value: 1,
                writable: false
            },
            NETWORK_LOADING: {
                value: 2,
                writable: false
            },
            NETWORK_LOADED: {
                value: 3,
                writable: false
            },
            NETWORK_NO_SOURCE: {
                value: 4,
                writable: false
            },
            VERSION: {
                value: _version,
                writable: false
            },
            HAVE_NOTHING: {
                value: 0,
                writable: false
            },
            HAVE_METADATA: {
                value: 1,
                writable: false
            },
            HAVE_CURRENT_DATA: {
                value: 2,
                writable: false
            },
            HAVE_FUTURE_DATA: {
                value: 3,
                writable: false
            },
            HAVE_ENOUGH_DATA: {
                value: 4,
                writable: false
            },
        });
    }

    _this.defineConst(_this);

};
var stateObj = new defineState();

var SOURCETYPE_SIMPLE = 0, //单段素材
    SOURCETYPE_VIRTUAL = 1; //虚拟素材



;/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />


var MediaElement = EventObject.extend({
    init: function (options) {
        this._super();
        var _element = null,
       _this = this,
        _logger = options.logger || new logger("debug"),
       _options = options || {},
       _id = options.id || ++_globalId,
       _src = options.src,
       _start = options.start || 0,
       _end = options.end || -1,
       _duration = NaN,
       _defaultPlaybackRate = options.defaultPlaybackRate || 1.0,
       _playbackRate = options.playbackRate || 1.0,
       _muted = options.muted || false,
       _volume = options.volume,
        _ended = false,
        _error = null,
         _autoplaying = false,
        _currentTime = 0,
        _lastTick = 0,
        _lastUpdateTime = 0,
        _overJump = false,
        _mockLooping = false,
        _mockId = -1,
        _buffering = 0,
        _useCros = (typeof options.useCros == 'undefined') ? true : options.useCros,
        _lastBufferTime = 0,
        _lastBufferTick = 0,
        _mediaStatus = MEDIASTATE_NONE,
        _mediaPhase = MEDIAPHASE_NONE,
        _lastOperate = MEDIAOPERATE_NONE,
        _lastOperateSeek = MEDIAOPERATE_NONE,
        _autoJumpTime = -1,
        _videoWidth = -1,
        _videoHeight =-1,
        _endType = ENDTYPE_NORMAL; // 当实际的长度超出了设定的end，此标记为true

        function loadStart() {
            _mediaPhase = MEDIAPHASE_LOADING;
            //_logger.log("me loadStart:" + _id);
            _this.dispatchEvent("loadstart");
        }
        function durationchange() {
            //_logger.log("me durationchange:" + _id);
            if (_end == -1) {
                _end = _element.duration;
                _duration = _end - _start;
            }
            else {
                _duration = _end - _start;
            }
            var diff = _element.duration - _end;
            if (diff == 0) {
                _endType = ENDTYPE_NORMAL;
            } else if (diff > 0) {
                _endType = ENDTYPE_CUT;
            } else {
                _endType = ENDTYPE_OVERSTEP;
            }
            _this.dispatchEvent("durationchange");
        }


        function loadedmetadata() {
            _this.dispatchEvent("loadedmetadata");
            //_logger.log("me loadedmetadata:" + _id);
            _element.addEventListener("canplaythrough", canplaythrough);

            _logger.log(_element.videoWidth + ' ' + _element.videoHeight);
        }

        function canplaythrough(e) {
            _element.removeEventListener("canplaythrough", canplaythrough);
           // _logger.log("me canplaythrough:" + _id + ' a');
            var bt = _start;
            if (_autoJumpTime >= 0) {
                bt = _autoJumpTime;
                _autoJumpTime = -1;
            }

            if (bt > _end) {
                bt = _end;
            }
            _currentTime = bt;
            if (bt > 0) {
               // _logger.log("me canplaythrough:" + _id+ ' b');
                _mediaPhase = MEDIAPHASE_LOADEDJUMP;
                var isOver = false,
                    jtime = bt;
                if (bt > _element.duration) {
                    isOver = true;
                    jtime = _element.duration;
                }

                function seeked() {
                   // _logger.log("me canplaythrough:" + _id + ' c');
                    _element.removeEventListener("seeked", seeked);
                    //触发事件前，先调整状态
                    if (_autoplaying) {
                        _mediaPhase = MEDIAPHASE_PLAYING;
                    } else {
                        _mediaPhase = MEDIAPHASE_PAUSED;
                    }
                    _element.style.display = "block";
                    _this.dispatchEvent("canplaythrough");
                    if (_lastOperateSeek == MEDIAOPERATE_SEEK) {
                        _this.dispatchEvent("seeked");
                    }
                    _lastOperate = MEDIAOPERATE_NONE;
                    _lastOperateSeek = MEDIAOPERATE_NONE;
                    if (isOver) {
                        _element.pause();
                        _element.playbackRate = 0;

                        _currentTime = bt;
                        if (_autoplaying) {
                            _lastTick = new Date().valueOf();
                            if (!_mockLooping) {
                                mockId = requestAnimationFrame(mockTimeupdate);
                            }
                            _this.dispatchEvent("playing");
                        }

                    } else {

                        if (_autoplaying) {
                            elementPlay();
                            _this.dispatchEvent("playing");
                        } else {
                            _element.pause();
                        }
                    }


                }

                _element.addEventListener("seeked", seeked);
                _element.currentTime = jtime;

            } else {

                if (_autoplaying) {
                    _mediaPhase = MEDIAPHASE_PLAYING;
                } else {
                    _mediaPhase = MEDIAPHASE_PAUSED;
                }
                if (_lastOperateSeek == MEDIAOPERATE_SEEK) {
                    _this.dispatchEvent("seeked");
                }
                _element.style.display = "block";
                _this.dispatchEvent("canplaythrough");

                if (_autoplaying) {
                    elementPlay();
                    _this.dispatchEvent("playing");
                } else {
                    _element.pause();
                }
                _lastOperate = MEDIAOPERATE_NONE;
            }
        }

        function timeupdate() {
            if (_mediaPhase == MEDIAPHASE_PLAYING && !_overJump && !_mockLooping) {
                if (_currentTime != _element.currentTime) {
                    _currentTime = _element.currentTime;
                    _lastBufferTime = _currentTime;
                    _this.dispatchEvent("timeupdate");
                }
                if (_element.currentTime >= _end && _ended) {
                    return;
                }
                _ended = false;
                if (_endType == ENDTYPE_CUT) {
                    var et = _end - (1 / 25);
                    if (_element.currentTime >= et && !_ended) {
                        _element.playbackRate = 0;
                        _ended = true;
                        _this.dispatchEvent("ended");
                    }
                }
            }
        }
        function ended() {
            if (_endType == ENDTYPE_NORMAL) {
                _ended = true;
                _this.dispatchEvent("ended");

            } else if (_endType == ENDTYPE_OVERSTEP) {
                //开始模拟timeupdate事件
                if (_mediaPhase == MEDIAPHASE_PLAYING && !_overJump) {
                    _currentTime = _element.currentTime;
                    _lastTick = new Date().valueOf();
                    if (!_mockLooping && _autoplaying) {
                        _mockId = requestAnimationFrame(mockTimeupdate);
                    }
                }
            }
        }

        function pause() {
            if (_element.ended) {
                //chrome 在达到ended时会触发pause事件
            } else {
                _this.dispatchEvent("pause");
            }
        }

        function seeking() {

        }

        function seeked() {
            //_logger.log("me seeked...id: " + _id + ' overJump: ' + _overJump + '  phase;' + _mediaPhase);
            if (_mediaPhase == MEDIAPHASE_SEEKING && !_overJump) {
                if (_autoplaying) {
                    _mediaPhase = MEDIAPHASE_PLAYING;
                } else {
                    _mediaPhase = MEDIAPHASE_PAUSED;
                }
                _this.dispatchEvent("seeked");
                _lastUpdateTime = _currentTime;
                if (_autoplaying) {
                    if (_currentTime < _end) {
                        _ended = false;
                    }
                    if (_element.paused) {

                        if (_currentTime < _element.duration) {
                            elementPlay();
                        }
                    }


                } else {
                }

            }

        }

        function error() {
            if (_element != null && !_element.getAttribute("src")) {
                return;
            }
            _error = _element.error;
            _this.dispatchEvent("error");
        }

        function isBuffering() {
            if (_buffering > 0 && _buffering == 2) {
                return true;
            }

            return false;
        }

        function progress() {
            if (_ended)
                return;

            var cur = _element.currentTime;
            var curTime = new Date().valueOf();
         //   console.log('progress: ' + cur + ' ' + (new Date()).valueOf());
            if (_mediaPhase == MEDIAPHASE_PLAYING) {
                if (_element.currentTime == _lastBufferTime && ((curTime - _lastBufferTick) >= 15) && _playbackRate != 0) {
                    //_logger.log("waiting ..." + _buffering + ' ' + _element.currentTime + ' ' + _lastBufferTime);
                    if (!isBuffering()) {
                        _buffering++;

                        if (isBuffering()) {
                            _mediaPhase = MEDIAPHASE_WAITING;

                            _this.dispatchEvent("waiting");
                            _element.playbackRate = 1;
                        }
                    }
                }
                else {
                    _buffering = 0;
                }

                _lastBufferTime = cur;

            } else if (_mediaPhase == MEDIAPHASE_WAITING) {
                if (_element.currentTime != _lastBufferTime) {
                    _buffering = 0;
                    _this.dispatchEvent("canplaythrough");
                    _element.playbackRate = _playbackRate;
                    if (_autoplaying) {
                        _mediaPhase = MEDIAPHASE_PLAYING;
                        if (_element.paused) {
                            elementPlay();
                        }
                        _this.dispatchEvent("playing");
                    } else {
                        _mediaPhase = MEDIAPHASE_PAUSED;
                        _element.pause();
                    }

                }
            }
            _lastBufferTick = curTime;

            _this.dispatchEvent("progress");
        }

        function waiting() {
            if ( _mediaPhase == MEDIAPHASE_PLAYING ) {
                _this.dispatchEvent("waiting");
            }
        }

        function mockTimeupdate() {

            _mockLooping = false;
            var t = new Date().valueOf();
            var offset = ((t - _lastTick) / 1000) * _playbackRate;

            //seeking时 空循环，不触发事件
            if (_mediaPhase == MEDIAPHASE_PLAYING) {
                _currentTime += offset;
            }

            _ended = false;
            var fire = false;
            if ((_currentTime - _lastUpdateTime) >= (0.15 * Math.max(_playbackRate, 1))) {
                _this.dispatchEvent("timeupdate");
                _lastUpdateTime = _currentTime;
                _lastBufferTime = _currentTime;
                fire = true;
            }
            if (_currentTime >= _end) {
                if (!fire) {
                    _this.dispatchEvent("timeupdate");
                }
                _ended = true;
                _this.dispatchEvent("ended");
            } else {
                if (_autoplaying) {
                    _mockLooping = true;
                    _mockId = requestAnimationFrame(mockTimeupdate);
                }
            }
            _lastTick = t;
        }

        function regEvent(v) {
         //   _this.addEventListener("progress", progress);
            v.addEventListener("loadStart", loadStart);
            v.addEventListener("durationchange", durationchange);
            v.addEventListener("loadedmetadata", loadedmetadata);
            v.addEventListener("timeupdate", timeupdate);
            v.addEventListener("ended", ended);
            v.addEventListener("pause", pause);
            v.addEventListener("seeking", seeking);
            v.addEventListener("seeked", seeked);
            v.addEventListener("error", error);
            v.addEventListener("progress", progress);
            v.addEventListener("waiting", waiting);
        }

        function unregEvent(v) {
            //_this.removeEventListener("progress", progress);
            v.removeEventListener("loadStart", loadStart);
            v.removeEventListener("durationchange", durationchange);
            v.removeEventListener("loadedmetadata", loadedmetadata);
            v.removeEventListener("timeupdate", timeupdate);
            v.removeEventListener("ended", ended);
            v.removeEventListener("pause", pause);
            v.removeEventListener("seeking", seeking);
            v.removeEventListener("seeked", seeked);
            v.removeEventListener("error", error);
            v.removeEventListener("progress", progress);
            v.removeEventListener("waiting", waiting);

        }

        function elementPlay() {
            _element.playbackRate = _playbackRate;
            _element.defaultPlaybackRate = _defaultPlaybackRate;
            _element.muted = _muted;
            if (typeof _volume == "number") {
                _element.volume = _volume;
            }
            _element.play();
        }

        function createElement() {
            _mediaPhase = MEDIAPHASE_NONE;
            //if (_mediaPhase >= MEDIAPHASE_CREATEELEMENT) {
            //    _this.destory();

            //}
            //if (_id == 10 || _id == 11) {
            //    _logger.log("createElement:" + _id);
            //}
            var proc = _options.create || defaultMediaCreate;
            //_src = src || _src;
            if (typeof src != "undefined") {
                _src = src;
            }
            _element = proc("", regEvent, _useCros);
            _element.defaultPlaybackRate = _defaultPlaybackRate;
            _element.playbackRate = _playbackRate;
            _element.muted = _muted;
            if (typeof _volume != "undefined") {
                _element.volume = _volume;
            }
          //  _mediaPhase = MEDIAPHASE_CREATEELEMENT;
            _element.style.display = "none";

        };

        this.play = function () {
            //if (_id == 11 || _id==10) {
            //    _logger.log("me id:" + _id + " _ended:" + _ended + ' _autoplaying:' + _autoplaying + ' _mediaPhase:' + _mediaPhase);
            //}

            if (_mediaPhase >= MEDIAPHASE_NONE && _mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                _ended = false;
            }

            if (_ended || _autoplaying) {
                return;
            }

            _this.dispatchEvent("play");
            _autoplaying = true;
            if (_mediaPhase >= MEDIAPHASE_NONE && _mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                _this.dispatchEvent("waiting");
                _lastOperate = MEDIAOPERATE_PLAY;

                if (!_element.getAttribute("src")) {
                    _mediaPhase = MEDIAPHASE_LOADING;
                    _element.style.display = "none";
                    _element.setAttribute("src", _src);
                }

                //if (_mediaPhase == MEDIAOPERATE_NONE || _mediaPhase == MEDIAPHASE_INITING) {
                   // _this.createElement();
                 //   _mediaPhase = MEDIAPHASE_LOADING;
                    //_element.load();
               // } else if (_mediaPhase == MEDIAPHASE_CREATEELEMENT) {
                   // _mediaPhase = MEDIAPHASE_LOADING;
                   // _this.load();
              //  }
            } else if (_mediaPhase == MEDIAPHASE_PAUSED) {
                _mediaPhase = MEDIAPHASE_PLAYING;

                if (_endType == ENDTYPE_OVERSTEP && _currentTime >= _element.duration) {
                    _lastTick = new Date().valueOf();
                    _lastUpdateTime = 0;
                    if (!_mockLooping) {
                        _mockId = requestAnimationFrame(mockTimeupdate);
                        _this.dispatchEvent("playing");
                    }

                } else {
                    elementPlay();
                    _this.dispatchEvent("playing");
                }


            } else if (_mediaPhase == MEDIAPHASE_WAITING) {
                _lastOperate = MEDIAOPERATE_PLAY;
            } else if (_mediaPhase == MEDIAPHASE_SEEKING) {
                _lastOperate = MEDIAOPERATE_PLAY;
            }

        };
        this.pause = function () {
            if (!_autoplaying) {
                return;
            }
            _this.dispatchEvent("pause");
            _autoplaying = false;
            _lastOperate = MEDIAOPERATE_PAUSE;
            _mediaPhase = MEDIAPHASE_PAUSED;

            if (_element != null) {
                _element.pause();
            }

        };
        this.load = function () {
            //if (_mediaPhase >= MEDIAPHASE_CREATEELEMENT) {
            //    _this.destory();

            //}
            _mediaPhase = MEDIAPHASE_INITING;
           // _this.createElement();
            if (_element != null) {
                _mediaPhase = MEDIAPHASE_LOADING;
                _element.style.display = "none";
                if (_element.getAttribute("src")) {
                    _element.load();
                } else {
                    _element.setAttribute('src', _src);
                }
              //  _element.load();
            }

            //_mediaStatus = MEDIASTATE_INITING;
            //initFlags();

            //if (_element == null) {
            //    _this.createElement();
            //}
            //_element.load();
        };

        //手动清理内部状态
        this.reset = function () {
            _buffering = 0;
            _overJump = false;
        }



        this.destory = function (b) {
            _mediaPhase = MEDIAPHASE_NONE;
            _lastOperate = MEDIAOPERATE_NONE;
            _lastOperateSeek = MEDIAOPERATE_NONE;
            _autoplaying = false;
            _ended = false;
            _overJump = false;

            if (_element != null) {
                _element.style.display = "none";
                //先取消事件绑定，避免下一语句引发异常
                unregEvent(_element);
                //关闭连接
                _element.setAttribute("src", "");
                _element.pause();
            }

            if (!b) {
                _this.eventListeners.length = 0;
            }

            _this.dispatchEvent("destory");
            delete _element;
            _element = null;

        };





        //调用stop可关闭socket连接，**** Chrome对每个域名的最大socket连接数为6，必须及时关闭未使用的连接 ****
        this.stop = function () {
            if (_element != null) {
                _mediaPhase = MEDIAPHASE_NONE;
                _autoplaying = false;
                _autoJumpTime = -1;
                _buffering = 0;
                _ended = false;
                _overJump = false;
                _element.setAttribute("src", "");
            }
        };



        function setCurrentTime(val) {
            var cur = val + _start;
            _overJump = false;
            _ended = false;
            _this.dispatchEvent("seeking");
            if (_mediaPhase <= MEDIAPHASE_INITING) {
                _lastOperateSeek = MEDIAOPERATE_SEEK;
                _currentTime = cur;
                _autoJumpTime = cur;
                _this.load();
            }
            //else if (_mediaPhase == MEDIAPHASE_CREATEELEMENT) {
            //    _autoJumpTime = cur;
            //    _currentTime = cur;
            //    if (_element != null) {
            //        _mediaPhase = MEDIAPHASE_LOADING;
            //        _element.load();
            //    }
            //    _lastOperateSeek = MEDIAOPERATE_SEEK;
            //}
            else if (_mediaPhase == MEDIAPHASE_LOADING) {
                _lastOperateSeek = MEDIAOPERATE_SEEK;
                _autoJumpTime = cur;
                _currentTime = cur;
            } else {

                if (cur > _end) {
                    cur = _end;
                }
                _currentTime = cur;
                if (_mediaPhase == MEDIAPHASE_WAITING) {
                }

                _mediaPhase = MEDIAPHASE_SEEKING;
                if (_endType == ENDTYPE_OVERSTEP && cur >= _element.duration) {
                    _logger.log("MediaElement set currentTime over Jump");
                    _currentTime = cur;
                    _this.dispatchEvent("timeupdate");
                    var targetTime = cur;
                    //跳转到最后一帧后再触发seeked事件
                    function _seeked() {
                        _logger.log("MediaElement set currentTime Skip to the last frame");
                        _element.removeEventListener("seeked", _seeked);

                        //可能在跳转过程中，用户又重新设置了新的位置
                        if (targetTime != _currentTime) {
                            return;
                        }

                        if (_currentTime == _end) {
                            _ended = true;
                            _this.dispatchEvent("ended");
                        }
                        if (!_ended) {
                            if (_autoplaying && !_mockLooping) {
                                _lastTick = new Date().valueOf();
                                _lastUpdateTime = _currentTime;
                                if (_mockId) {
                                    cancelAnimationFrame(_mockId);
                                }
                                _mockId = requestAnimationFrame(mockTimeupdate);
                            }
                        }
                        if (_autoplaying) {
                            _mediaPhase = MEDIAPHASE_PLAYING;
                        } else {
                            _mediaPhase = MEDIAPHASE_PAUSED;
                        }
                        _this.dispatchEvent("seeked");
                    }
                    _element.addEventListener("seeked", _seeked);
                    _overJump = true;
                    _element.currentTime = _element.duration;



                } else {
                    _element.currentTime = cur;
                }
            }

        }

        createElement();

        Object.defineProperties(_this, {
            src: {
                get: function () {
                    return _src;
                },
                set: function (val) {
                    if (_src != val) {
                        _src = val;
                    }
                    if (_element.getAttribute("src") != _src) {
                        _element.style.display = "none";
                        _mediaPhase = MEDIAPHASE_LOADING;
                        _element.setAttribute("src", _src);

                    }
                }
            },
            element: {
                get: function () {
                    return _element;
                }
            },
            error: {
                get: function () {
                    return _error;
                }
            },
            currentSrc: {
                get: function () {
                    if (_element == null) {
                        return null;
                    }
                    return _element.currentSrc;
                }
            },
            currentTime: {
                get: function () {
                    var cur = _currentTime - _start;
                    if (cur > _duration) {
                        cur = _duration;
                    }
                    if (cur < 0) {
                        cur = 0;
                    }
                    return cur;
                },
                set: function (val) {
                    setCurrentTime(val);

                }
            },
            networkState: {
                get: function () {
                    if (_element == null)
                        return stateObj.NETWORK_EMPTY;
                    return _element.networkState;
                }
            },
            readyState: {
                get: function () {
                    if (_element == null) {
                        return stateObj.HAVE_NOTHING;
                    }
                    return _element.readyState;
                }
            },
            seeking: {
                get: function () {
                    return _mediaPhase == MEDIAPHASE_SEEKING;
                }
            },
            paused: {
                get: function () {
                    return !_autoplaying;
                }
            },
            duration: {
                get: function () {
                    return _duration;
                }
            },
            ended: {
                get: function () {
                    return _ended;
                }
            },
            defaultPlaybackRate: {
                get: function () {
                    return _defaultPlaybackRate
                },
                set: function (val) {
                    _defaultPlaybackRate = val;
                    if (_element != null) {
                        _element.defaultPlaybackRate = _defaultPlaybackRate;
                    }
                }
            },
            mediaStatus: {
                get: function () {
                    if (_mediaPhase == MEDIAPHASE_NONE) {
                        return MEDIASTATE_NONE;
                    }else  if (_mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                        return MEDIASTATE_INITING;
                    } else if (_mediaPhase == MEDIAPHASE_SEEKING || _mediaPhase == MEDIAPHASE_WAITING) {
                        return MEDIASTATE_WAITING;
                    } else {
                        return MEDIASTATE_NORMAL;
                    }
                }
            },
            videoWidth: {
                get: function () {
                    return _videoWidth;
                }
            },
            videoHeight: {
                set: function () {
                    return _videoHeight;
                }
            },
            playbackRate: {
                get: function () {
                    return _playbackRate
                },
                set: function (val) {
                    _playbackRate = val;
                    if (_element != null) {
                        if (_mediaPhase == MEDIAPHASE_PLAYING || _mediaPhase == MEDIAPHASE_PAUSED || _mediaPhase == MEDIAPHASE_SEEKING) {
                            _element.playbackRate = _playbackRate;
                        }

                    }
                }
            },
            muted: {
                get: function () {
                    return _muted;
                },
                set: function (val) {
                    _muted = val;
                    if (_element != null ) {
                        _element.muted = _muted;
                    }
                }

            },
            volume: {
                get: function () {
                    return _volume;
                },
                set: function (val) {
                    if (val < 0) {
                        val = 0;
                    }
                    if (val > 1) {
                        val = 1;
                    }
                    _volume = val;

                    if (_element != null ) {
                        _element.volume = _volume;
                    }
                }

            },
            id: {
                get: function () {
                    return _id;
                }
            }
        });

    }
});

if (typeof global !== "undefined") {
    if (global.MediaElement) {
        global.MediaElement[_version] = MediaElement;
    } else {
        global.MediaElement = MediaElement;
    }
};/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />

//一个空的，不关联实际视频的虚拟播放器

var NullMediaElement = EventObject.extend({
    init: function (options) {
        this._super();
        var _element = null,
       _this = this,
       _options = options || {},
       _logger = _options.logger || new logger("debug"),
       _id = _options.id || ++_globalId,
       _src = _options.src,
       _start = _options.start || 0,
       _end = _options.end || 0,
       _duration = NaN,
       _defaultPlaybackRate = _options.defaultPlaybackRate || 1.0,
       _playbackRate = _options.playbackRate || 1.0,
       _muted = _options.muted || false,
       _volume = _options.volume,
        _ended = false,
        _loadStart = false,
         _autoplaying = false,
        _currentTime = 0,
        _lastTick = 0,
        _lastUpdateTime = 0,
        _isSeeking = false,
        _overJump = false,
        _mockLooping = false,
        _mockId = -1,
        _buffering = 0,
        _mediaStatus = MEDIASTATE_NONE,
        _bufferJump = false,
        _lastBufferTime = 0,
        _bufferStartTime = 0,
        _autoJumpTime = -1,
        _frame = _options.frame || false, //是否每一帧都触发timeupdate

        _endType = ENDTYPE_NORMAL; // 当实际的长度超出了设定的end，此标记为true

        function mockTimeupdate() {

            if (_currentTime >= _end && _ended) {
                return;
            }
            _mockLooping = false;
            var t = new Date().valueOf();
            var offset = ((t - _lastTick) / 1000) * _playbackRate;

            _currentTime += offset;



            _ended = false;
            var fire = false;

            var interval = (0.15 * Math.max(_playbackRate, 1));
            if (_frame) {
                interval = (0.04 * Math.max(_playbackRate, 1));
            }

            if ((_currentTime - _lastUpdateTime) >= interval) {
                _this.dispatchEvent("timeupdate");
                _lastUpdateTime = _currentTime;
                fire = true;
            }

            if (_currentTime >= _end) {
                if (!fire) {
                    _this.dispatchEvent("timeupdate");
                }
                _ended = true;
                _this.dispatchEvent("ended");
            } else {
                if (_autoplaying) {
                    _mockLooping = true;
                    if (_mockId >= 0) {
                        cancelAnimationFrame(_mockId);
                    }
                    _mockId = requestAnimationFrame(mockTimeupdate);
                }
            }
            _lastTick = t;
        }

        function initFlags() {
            _loadStart = true;
            _autoplaying = false;
            _ended = false;
            _lastUpdateTime = 0;
            _currentTime = _start;

            if (_mockLooping) {
                // requestAnimationFrame
                cancelAnimationFrame(_mockId);
                _mockLooping = false;

            }
        }


        this.createElement = function () {
            _mediaStatus = MEDIASTATE_INITING;
            initFlags();
            _element = document.createElement("div");
            _loadStart = true;
            _element.defaultPlaybackRate = _defaultPlaybackRate;
            _element.playbackRate = _playbackRate;
            _element.muted = _muted;
            if (typeof _volume != "undefined") {
                _element.volume = _volume;
            }

            _this.dispatchEvent("loadstart");
            var len = 0;
            if (typeof _options.duration == "number") {
                len = _options.duration;
                if (_end == -1) {
                    _end = len;
                }
            } else {
                len = 0;
            }

            _element.duration = len;
            _duration = _end - _start;
            _this.dispatchEvent("durationchange");
            _this.dispatchEvent("loadedmetadata");
            _this.dispatchEvent("canplay");
            _loadStart = false;
            setTimeout(function () {
                _mediaStatus = MEDIASTATE_NORMAL;
                _this.dispatchEvent("canplaythrough");

            }, 0);
        };

        this.play = function () {

            if (_currentTime < _duration) {
                _ended = false;
            }

            if (_ended || _autoplaying) {
                return;
            }

            if (_element == null) {
                _this.createElement();
            }

            _lastTick = new Date().valueOf();
            _lastUpdateTime = 0;
            _autoplaying = true;
            _this.dispatchEvent("play");
            if (!_mockLooping) {
                mockTimeupdate();
                _this.dispatchEvent("playing");
            }


        };
        this.pause = function () {
            if (_element != null) {
                if (_autoplaying) {
                    _autoplaying = false;
                    if (_mockLooping) {
                        cancelAnimationFrame(_mockId);
                        _mockLooping = false;
                    }
                    _this.dispatchEvent("pause");
                }



            } else {
                throw new Error(lang[_curLang].initializeFirst);
            }
        };
        this.load = function () {
            _mediaStatus = MEDIASTATE_INITING;
            initFlags();

            if (_element == null) {
                _this.createElement();
            }

        };

        function changeDuration(val) {
            if (_element == null) {
                _options.duration = val;
                return;
            }


            var len = _element.duration;
            if (len != val) {
                if (len == _end || _end==-1) {
                    _end = val;
                }
                len = val;
                _element.duration = val;

                if (_end > len) {
                    _end = len;
                }
                if (_currentTime > _end) {
                    _currentTime = _end;
                }

                _duration = _end - _start;

                if (_currentTime < _duration) {
                    _ended = false;
                }

                _this.dispatchEvent("durationchange");
            }
        };

        //手动清理内部状态
        this.reset = function () {
            _buffering = 0;
            _bufferJump = false;
        }

        this.destory = function () {
            if (_element != null) {
                delete _element;
                _element = null;
            }
            _this.eventListeners.length = 0;
            _mediaStatus = MEDIASTATE_NONE;
            _ended = false;
        };


        function setCurrentTime(val) {
            var cur = val + _start;
            if (cur > _end) {
                cur = _end;
            }
            if (cur < _end) {
                _ended = false;
            }
            _currentTime = cur;
            _lastUpdateTime = _currentTime;
            _lastTick = new Date().valueOf();
            _this.dispatchEvent("timeupdate");
            if (_autoplaying && !_mockLooping) {

                mockTimeupdate();
            }
        }

        Object.defineProperties(_this, {
            element: {
                get: function () {
                    return _element;
                }
            },
            error: {
                get: function () {
                    if (_element == null)
                        return null;
                    return null;
                }
            },
            currentSrc: {
                get: function () {
                    if (_element == null) {
                        return null;
                    }
                    return _src;
                }
            },
            mediaStatus: {
                get: function () {
                    return _mediaStatus;
                }
            },
            currentTime: {
                get: function () {
                    var cur = _currentTime - _start;
                    if (cur > _duration) {
                        cur = _duration;
                    }
                    return cur;
                },
                set: function (val) {
                    if (val < 0) {
                        val = 0;
                    }
                    _mediaStatus = MEDIASTATE_WAITING;
                    _this.dispatchEvent("seeking");
                    _isSeeking = true;
                    setCurrentTime(val);
                    _isSeeking = false;
                    _mediaStatus = MEDIASTATE_NORMAL;
                    _this.dispatchEvent("seeked");
                }
            },
            networkState: {
                get: function () {
                    if (_element == null)
                        return stateObj.NETWORK_EMPTY;
                    return stateObj.NETWORK_LOADING;
                }
            },
            readyState: {
                get: function () {
                    if (_element == null) {
                        return stateObj.HAVE_NOTHING;
                    }
                    return stateObj.HAVE_ENOUGH_DATA;
                }
            },
            seeking: {
                get: function () {
                    return _isSeeking;
                }
            },
            paused: {
                get: function () {
                    return !_autoplaying;
                }
            },
            duration: {
                get: function () {
                    return _duration;
                },
                set: function (val) {
                    changeDuration(val);
                }
            },
            ended: {
                get: function () {
                    return _ended;
                }
            },
            defaultPlaybackRate: {
                get: function () {
                    return _defaultPlaybackRate
                },
                set: function (val) {
                    _defaultPlaybackRate = val;
                    if (_element != null) {
                        _element.defaultPlaybackRate = _defaultPlaybackRate;
                    }
                }
            },
            playbackRate: {
                get: function () {
                    return _playbackRate
                },
                set: function (val) {
                    _playbackRate = val;
                    if (_element != null) {
                        _element.playbackRate = _playbackRate;

                    }
                }
            },
            muted: {
                get: function () {
                    return _muted;
                },
                set: function (val) {
                    _muted = val;
                    if (_element != null && !_ended) {
                        _element.muted = _muted;
                    }
                }

            },
            volume: {
                get: function () {
                    return _volume;
                },
                set: function (val) {
                    _volume = val;
                    if (_element != null && !_ended) {
                        _element.volume = _volume;
                    }
                }

            },
            id: {
                get: function () {
                    return _id;
                }
            }
        });

    }
});

if (typeof global !=="undefined") {
    if (global.NullMediaElement) {
        global.NullMediaElement[_version] = NullMediaElement;
    } else {
        global.NullMediaElement = NullMediaElement;
    }
};/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="NullMediaElement.js" />

var VCPlayer = EventObject.extend({
    init: function (options) {

        this._super();

        options = options || {};

        var _this = this,
        _currentSrc,
        _seeking = false,
        _paused = false,
        _duration = NaN,
        _ended = false,
        _start = 0,
        _end = -1,
        _id = '',
        _container = options.container,
        _playerCss = options.playerCss,
        _currentTime = 0,
        _error = null,
        _playbackRate = 1,
        _muted = false,
        _volume = 1,
        _defaultPlaybackRate = 1,
        _sourceType = SOURCETYPE_SIMPLE,
        _autoplaying = false,
        _mediaElements = [],
        _currentElement = null,
        _firstElement = null,
        _lastElement = null,
        _signUrlCallback = null,  //url签名回调  function(fileid, callback(isSuccess, newUrl))
        _signTimeout = 3600,
        _autoJumpTime = -1,
        _useCros = (typeof options.useCros == 'unefined') ? true : options.useCros,
        _isAudio = false,
         _mediaPhase = MEDIAPHASE_NONE,
        _mediaStatus = MEDIASTATE_NONE,
        _lastOperateSeek = MEDIAOPERATE_NONE,
        _lastOperate = MEDIAOPERATE_NONE,
        _propertySetter = options.propertySetter,
        _element = document.createElement("div"),
        _endType = ENDTYPE_NORMAL,
        _canvas = null,
        _canvasContext = null;


        var _logger = options.logger || new logger("debug");

        _element.style.position = "relative";
        if (_playerCss) {
            _element.classList.add(_playerCss);
        } else {
            _element.style.width = "100%";
            _element.style.height = "100%";
        }
        if (_container) {
            _container.appendChild(_element);
        }


        _this.setSource = function (src, id, options) {
            //_mediaStatus = MEDIASTATE_NONE;
            _mediaPhase = MEDIAPHASE_NONE;
            _logger.log("set soruce MEDIAPHASE_NONE");
          //  _inited = false;
            if (typeof id == "undefined") {
                id = ++_globalId;
            }


            options = options || {};
            _start = options.start || 0;
            if (_start < 0) {
                _start = 0;
            }
            _isAudio = options.audio || false;
            _end = options.end || -1;
            _muted = options.muted || false;
            _volume = options.volume || 1;
            _signTimeout = options.signTimeout || 3600;
            _signUrlCallback = options.signUrlCallback || null;
            //if (id == _id) {
                //id相同时，不重新处理
          //  } else {
                _id = id;
                _mediaPhase = MEDIAPHASE_INITING;
                // clearMediaElements();
                _this.destory(true);
                if (typeof src == "string") {
                    _sourceType = SOURCETYPE_SIMPLE;
                    var me = loadSimple(src, options);
                    _mediaElements.push(me);
                } else {
                    _sourceType = SOURCETYPE_VIRTUAL;
                    loadVirtual(src, options);
                }
          //  }
        }

        function loadSimple(src, options) {

            var me = new MediaElement({
                src: src,
                defaultPlaybackRate: _defaultPlaybackRate,
                playbackRate: _playbackRate,
                useCros: _useCros,
                logger: _logger,
                end: _end || -1,
                muted: _muted,
                create: _isAudio ? defaultAudioMediaCreate : defaultMediaCreate,
                volume: _volume
            });
            me.__clipIn = 0;
            me.__clipOut = -1;
            _endType = ENDTYPE_NORMAL;

            me.addEventListener("error", error);
            me.addEventListener("durationchange", durationchange);
            return me;
        }
        function loadVirtual(src, options) {

            var list = src.ref.sort(function (a, b) {
                return a.clipbegin - b.clipbegin;
            });

            var clips = [];

            var lastClip = null;
            for (var i = 0; i < list.length; i++) {
                var clip = util.clone(list[i]);
                if (lastClip != null) {
                    if (clip.clipbegin != lastClip.clipend) {
                        lastClip.clipend = clip.clipbegin;
                    }
                }
                lastClip = clip;
                clips.push(clip);
            }

            lastClip = clips[clips.length - 1];
            if (_end == -1) {
                _end = lastClip.clipend;
            }


            for (var i = 0; i < clips.length; i++) {
                var clip = clips[i];

                var me = new MediaElement({
                    src: clip.clipfile,
                    defaultPlaybackRate: _defaultPlaybackRate,
                    playbackRate: _playbackRate,
                    create: _isAudio ? defaultAudioMediaCreate : defaultMediaCreate,
                    start: clip.begin,
                    useCros: _useCros,
                    logger: _logger,
                    end: clip.begin + (clip.clipend - clip.clipbegin),
                    muted: _muted,
                    volume: _volume
                });
                me.__clipIn = clip.clipbegin;
                me.__clipOut = clip.clipend;
                me.__fileid = clip.fileid;
                me.__lastSignTime = 0;
                me.__source = clip;

                me.addEventListener("error", error);

               // attachEvent(me);

                _mediaElements.push(me);

            }

            if (_end > lastClip.clipend) {
                var me = new NullMediaElement({
                    duration: _end - lastClip.clipend,
                    start: 0,
                    end: -1,
                    defaultPlaybackRate: _defaultPlaybackRate,
                    playbackRate: _playbackRate
                });
                me.__clipIn = lastClip.clipend;
                me.__clipOut = _end;
                attachEvent(me);
                _mediaElements.push(me);
            }

            if (_end < lastClip.clipend) {
                _endType = ENDTYPE_CUT;
            } else {
                _endType = ENDTYPE_NORMAL;
            }


            _duration = _end - _start;


        }

        function attachEvent(me) {

            me.addEventListener("canplaythrough", canplaythrough);
            me.addEventListener("seeking", seeking);
            me.addEventListener("seeked", seeked);
            me.addEventListener("waiting", waiting);
            me.addEventListener("timeupdate", timeupdate);
            me.addEventListener("ended", ended);
        }

        function detachEvent(me) {
            me.removeEventListener("durationchange", durationchange);
            me.removeEventListener("canplaythrough", canplaythrough);
            me.removeEventListener("seeking", seeking);
            me.removeEventListener("seeked", seeked);
            me.removeEventListener("waiting", waiting);
            me.removeEventListener("error", error);
            me.removeEventListener("timeupdate", timeupdate);
            me.removeEventListener("ended", ended);
        }


        function durationchange(e) {
            if (_sourceType == SOURCETYPE_SIMPLE) {

                if (_end == -1) {
                    _end = e.target.duration;

                }

                e.target.__clipOut = _end;
                _duration = _end - _start;

                if (_end == e.target.duration) {
                    _endType = ENDTYPE_NORMAL;
                } else {
                    _endType = ENDTYPE_CUT;
                }
                _this.dispatchEvent("durationchanged");
            }
        }

        function canplaythrough(e) {
            _logger.log("vcplayer canplaythrough...id:" + _id + ' isCur:' + (e.target == _currentElement) + ' curId:' + _currentElement.id + ' eventId:' + e.target.id);
            if (e.target == _currentElement) {
                if (_currentElement.element != null) {
                    _currentElement.element.style.zIndex = 1;
                }
                _element.style.display = "block";
                _this.dispatchEvent("canplaythrough");
            }

            if (e.target.__preElement != null && e.target.__preElement != _currentElement) {
                e.target.__preElement.stop();
                e.target.__preElement.element.style.zIndex = 0;
                e.target.__preElement = null;
            }
        }

        function seeking(e) {
        }

        function seeked(e) {
            _logger.log("vcplayer seeked: id:" + _id + ' phase:' + _mediaPhase + ' isCur:' + (_currentElement == e.target) + ' curId:' + _currentElement.id);
            if (_currentElement == e.target && _mediaPhase == MEDIAPHASE_SEEKING) {
                if (_currentElement.element != null) {
                    _currentElement.element.style.zIndex = 1;
                }
                if (_autoplaying) {
                    _mediaPhase = MEDIAPHASE_PLAYING;
                } else {
                    _mediaPhase = MEDIAPHASE_PAUSED;
                }
                _this.dispatchEvent("seeked");
                if (_currentElement.__loadingjump) {
                    _this.dispatchEvent("canplaythrough");
                }
                if (_autoplaying) {
                    if (_currentElement.paused) {
                        elementPlay(_currentElement);
                    }
                } else {
                    if (!_currentElement.paused) {
                        _currentElement.pause();
                    }
                }
            }
            _currentElement.__loadingjump = false;

            if (e.target.__preElement != null && e.target.__preElement != _currentElement) {
                e.target.__preElement.stop();
                e.target.__preElement.element.style.zIndex = 0;
                e.target.__preElement = null;
            }
        }

        function waiting(e) {
            if (_currentElement == e.target) {
                _this.dispatchEvent("waiting");
            }
        }

        function timeupdate(e) {
            if (_currentElement == e.target && _mediaPhase==MEDIAPHASE_PLAYING) {
                if ((_currentElement.__clipIn + _currentElement.currentTime) >= _end && _ended) {
                    return;
                }
               // _ended = false;
                _error = null;
                _currentTime = _currentElement.__clipIn + _currentElement.currentTime;
              //  _canvasContext.drawImage(_currentElement.element,0,0, _canvas.width,_canvas.height);

                _this.dispatchEvent("timeupdate");
                if (_lastElement == _currentElement && _endType == ENDTYPE_CUT) {
                    //
                    if ((_currentElement.__clipIn + _currentElement.currentTime) >= _end) {
                        if (!_ended) {
                            _currentElement.playbackRate = 0;
                            _ended = true;
                            _this.dispatchEvent("ended");
                        }
                    } else {
                        _ended = false;
                    }
                }

                autoPreLoad();

            }
        }

        function error(e) {
            if (_currentElement == e.target) {
                _error = e.target.error;
                _isSeeking = false;
                _loadStart = false;
                _this.dispatchEvent("error");
            }
        }

        function ended(e) {
            //只有最后一个素材才会处理
            if (e.target == _currentElement && e.target == _lastElement) {
                _ended = true;
                _currentTime = _end;
                _this.dispatchEvent("ended");
            } else if (_sourceType == SOURCETYPE_VIRTUAL) {
                if (e.target != _lastElement && e.target == _currentElement && _autoplaying ) {
                    var idx = _mediaElements.indexOf(_currentElement);
                    var _ele = _mediaElements[idx + 1];
                   // _logger.log("next");
                    setCurrentTime(_ele.__clipIn - _start);
                }
            }
        }

        function setCurrentTime(time) {
            time = time + _start;
            _ended = false;
            _logger.log("vaplayer seeking..." + _id + ' ' + _mediaPhase);
            _this.dispatchEvent("seeking");
            if (_mediaPhase <= MEDIAPHASE_LOADING) {

                _lastOperateSeek = MEDIAOPERATE_SEEK;
                if (time > _end) {
                    time = _end;
                    _currentTime = time;
                    _this.dispatchEvent("timeupdate");
                    _this.dispatchEvent("seeked");
                    return;

                }
                _currentTime = time;
                _this.dispatchEvent("timeupdate");
                _autoJumpTime = time;

                if (_mediaPhase == MEDIAPHASE_NONE) {
                    _this.load();
                }

            } else {

                if (time > _end) {
                    time = _end;
                    _currentTime = time;
                    _ended = true;
                    _this.dispatchEvent("seeked");
                    return;

                }

                var diff = _currentTime - time;
                var dontAdjust = false;
                //if ((Math.abs(diff) * 25) < 2) {
                //    dontAdjust = true;

                //} else {
                //    _logger.log("时间差：" + diff);
                //}

                if (dontAdjust && _currentElement != null && (_mediaPhase == MEDIAPHASE_PLAYING || _mediaPhase == MEDIAPHASE_PAUSED)) {

                    _currentElement.playbackRate = _playbackRate;
                    _currentElement.muted = _muted;
                    _currentElement.volume = _volume;

                    if (_currentElement.paused && _autoplaying) {
                        elementPlay(_currentElement);
                    } else if (!_autoplaying) {
                        _currentElement.pause();
                    }
                    _this.dispatchEvent("seeked");
                    return;
                }
                _currentTime = time;

                if (_mediaPhase == MEDIAPHASE_WAITING) {

                }

                _mediaPhase = MEDIAPHASE_SEEKING;
                _this.dispatchEvent("timeupdate");

                var element = util.first(_mediaElements, function (item) {
                    if (item.__clipIn <= time && item.__clipOut > time) {
                        return true;
                    }
                    return false;
                });
                if (element == null && _currentTime == _end) {
                    element = _lastElement;
                }

                if (element.error != null) {
                    _error = element.error;
                    _this.dispatchEvent("error");
                    return;
                }

                _error = null;
                if (element != _currentElement) {
                    //change
                    var oldElement = _currentElement;
                    _currentElement = element;
                    //_currentElement.element.style.zIndex = 1;
                    if (oldElement != null) {
                        oldElement.pause();
                        oldElement.playbackRate = 0;
                        oldElement.muted = true;
                        oldElement.element.style.zIndex = 0;
                        if (_currentElement.__preElement) {
                            _currentElement.__preElement.stop();
                            _currentElement.__preElement.element.style.zIndex = 0;
                            _currentElement.__preElement = null;
                        }

                        _currentElement.__preElement = oldElement;
                        //oldElement.stop();
                        //oldElement.destory(true);
                        //oldElement.pause();
                        //oldElement.playbackRate = 0;
                        //oldElement.muted = true;
                        //oldElement.element.style.zIndex = 0;
                        //oldElement.currentTime = (oldElement.__localStart || 0);
                    }
                }

                function playNext() {

                    var localTime = time - _currentElement.__clipIn;
                    _logger.log("vcplayer playNext..."  + _id + ' ' + _currentElement.id + ' ' +  localTime);
                    _currentElement.reset();
                    if (_currentElement.__signurl) {
                        _currentElement.src = _currentElement.__signurl;
                    }
                    _currentElement.playbackRate = _playbackRate;
                    _currentElement.muted = _muted;
                    _currentElement.volume = _volume;
                    _currentElement.currentTime = localTime;

                    if (_currentElement.paused && _autoplaying) {
                        _logger.log("vcplayer playNext play...");
                        elementPlay(_currentElement);
                    } else if (!_autoplaying) {
                        _logger.log("vcplayer playNext pause...");
                        _currentElement.pause();
                    }
                }

                if (_signUrlCallback != null) {
                    var now = new Date().valueOf();
                    var remainTime = (now - _currentElement.__lastSignTime)/1000;
                    remainTime = _signTimeout - remainTime;
                    if (remainTime <= _currentElement.duration) {
                        //超时
                        _this.dispatchEvent("waiting");
                        _logger.log(lang[_curLang].signatureTimeout);
                        _signUrlCallback(_currentElement.__fileid, _currentElement.__source, function (b, url) {
                            _logger.log("生成签名：" + b + " " + url);
                            if (b) {
                                _currentElement.__signurl = url;
                            }
                            if (_currentElement == element) {
                                playNext();
                                //if (b) {
                                //    if (_currentElement.element != null) {
                                //        _element.removeChild(_currentElement.element);
                                //    }
                                //    _currentElement.destory();
                                //    _currentElement.createElement(url);
                                //    playNext();
                                //} else {
                                //    playNext();
                                //}
                            } else {
                                //再次跳转，忽略
                            }


                        });
                    } else {
                        playNext();
                    }


                } else {
                    playNext();
                }



            }
        }

        function destoryMediaElement() {
            util.forEach(_mediaElements, function (item) {
                item.destory();
            });
        }

        function elementPlay(item) {
            item.playbackRate = _playbackRate;
            item.defaultPlaybackRate = _defaultPlaybackRate;
            item.muted = _muted;
            item.volume = _volume;
            _element.style.display = "block";
            item.play();
        }

        //预载入下一个视频
        function autoPreLoad() {
            var mes = [];
            var ct = _this.currentTime + _start + 5; //提前5s载入
            util.forEach(_mediaElements, function (item) {
                if (item.__clipIn <= ct && (item.__clipOut > ct || item.__clipOut == -1) && item != _currentElement) {
                   // _logger.log(item.id + ' ' + item.mediaStatus);
                    if (item.mediaStatus == MEDIASTATE_NONE) {
                        mes.push(item);
                    }

                }

            });
            //最多载入2个
            var count = Math.min( mes.length,2);
            for (var i = 0; i < count; i++) {
                _logger.log("auto pre load: " + mes[i].id);
                mes[i].load();
            }

        }

        _this.load = function () {

            //var rect = _element.getBoundingClientRect();
            //if (rect.width > 0 && rect.height > 0 ) {
            //    if (_canvas == null || _canvas.width != rect.width || _canvas.height != rect.height) {
            //        _canvas = document.createElement("canvas");
            //        _canvas.width = rect.width;
            //        _canvas.height = rect.height;
            //        _canvasContext = _canvas.getContext("2d");
            //        _container.appendChild(_canvas);
            //    }
            //}
            _ended = false;
            _element.style.display = "none";

            _mediaPhase = MEDIAPHASE_INITING;
            if (_mediaPhase >= MEDIAPHASE_CREATEELEMENT) {
                destoryMediaElement();
            }



            //当前element
            //load之前设置了时间，直接跳转到设定的时间
            var bt = _start;
            if (_autoJumpTime >= 0) {

                bt = _autoJumpTime;
                _autoJumpTime = -1;
            }
            if (bt > _end && _end != -1) {
                bt = _end;
            }

            _firstElement = null;
            _lastElement = null;
            if (_mediaElements.length > 0) {
                _firstElement = util.first(_mediaElements, function (item) {
                    if (item.__clipIn <= _start && item.__clipOut > _start) {
                        return true;
                    }
                    return false;
                });
                if (_firstElement) {
                    _firstElement.__first = true;
                    _firstElement.__localStart = _start - _firstElement.__clipIn;
                }

                if (_end == -1) {
                    _lastElement = _mediaElements[_mediaElements.length - 1];
                } else {
                    _lastElement = util.first(_mediaElements, function (item) {
                        if ((item.__clipIn < _end && (item.__clipOut >= _end || item.__clipOut == -1))) {
                            return true;
                        }
                        return false;
                    });
                }
                if (_lastElement) {
                    _lastElement.__last = true;
                    _lastElement.__localEnd = _end - _lastElement.__clipIn;
                }
            }

            _currentElement = util.first(_mediaElements, function (item) {
                if (item.__clipIn <= bt && item.__clipOut > bt) {
                    return true;
                }
                return false;
            });

            function cp(e) {
                e.target.removeEventListener("canplaythrough");
                _logger.log("canplaythrough:" + e.target.id);
                //在此期间可能用户进行了再次跳转
                if (_autoJumpTime >= 0) {
                    bt = _autoJumpTime;
                    _autoJumpTime = -1;
                }
                if (bt > _end && _end != -1) {
                    bt = _end;
                }

                _currentElement = util.first(_mediaElements, function (item) {
                    if (item.__clipIn <= bt && item.__clipOut > bt) {
                        return true;
                    }
                    return false;
                });
                if (!_currentElement) {
                    return;
                }
                //开始处理事件
                util.forEach(_mediaElements, function (item) {
                    attachEvent(item);
                });

                function setMediaPhase() {
                    if (_autoplaying) {
                        _mediaPhase = MEDIAPHASE_PLAYING;
                    } else {
                        _mediaPhase = MEDIAPHASE_PAUSED;
                    }
                }

                function checkStatus(item) {
                    item.element.style.zIndex = 1;
                    if (_autoplaying) {
                        elementPlay(item);
                        _this.dispatchEvent("playing");
                    } else {
                        item.pause();
                    }
                }

                var localStart = bt - _currentElement.__clipIn;
                if (localStart == 0) {

                    setMediaPhase();
                    if (_lastOperateSeek == MEDIAOPERATE_SEEK) {
                        _this.dispatchEvent("seeked");
                    }
                    _element.style.display = "block";

                    _this.dispatchEvent("canplaythrough");

                    checkStatus(_currentElement);
                } else {
                    _mediaPhase = MEDIAPHASE_LOADEDJUMP;

                    function _seeked(e) {
                        e.target.removeEventListener("seeked", _seeked);

                        if (e.target == _currentElement) {
                            setMediaPhase();

                            _element.style.display = "block";
                            _this.dispatchEvent("canplaythrough");
                            if (_lastOperateSeek == MEDIAOPERATE_SEEK) {
                                _this.dispatchEvent("seeked");
                            }
                            checkStatus(_currentElement);
                            _lastOperateSeek = MEDIAOPERATE_NONE;
                        } else {
                            //又被跳转了
                            if (_currentElement.seeking) {
                                _currentElement.__loadingjump = true;
                            } else {
                                setMediaPhase();

                                _element.style.display = "block";
                                _this.dispatchEvent("canplaythrough");


                                checkStatus(_currentElement);

                                _lastOperateSeek = MEDIAOPERATE_NONE;
                                //if (_autoplaying) {
                                //    _mediaPhase = MEDIAPHASE_PLAYING;
                                //    elementPlay(_currentElement);
                                //    _this.dispatchEvent("playing");
                                //} else {
                                //    _mediaPhase = MEDIAPHASE_PAUSED;
                                //    _element.pause();
                                //}

                            }
                        }
                    }

                    _currentElement.addEventListener("seeked", _seeked);
                    _currentElement.currentTime = localStart;
                }
            }
            if (_currentElement) {
                _currentElement.addEventListener("canplaythrough", cp);
            } else {
                _logger.error("vcplayer position error...");
            }

            function loadElement(item, idx, src) {
                //item.createElement(src);
                item.element.style.cssText = "width: 100%;height: 100%;padding: 0px;z-index: 10;position: absolute;";
                item.element.style.zIndex = 0;
                _element.appendChild(item.element);
            }

            var mes = [];
            util.asyncForEach(_mediaElements, function (item, idx, loop) {

                if ((_end == -1 && (item.__clipOut > _start || item.__clipOut == -1)) ||
                    (_end > 0 && (item.__clipOut > _start || item.__clipOut == -1) && item.__clipIn < _end)) {
                    if (_signUrlCallback != null) {
                        var now = new Date().valueOf();
                        if ((now - item.__lastSignTime) >= _signTimeout * 1000) {
                            //需要重新获取签名url
                            _signUrlCallback(item.__fileid, item.__source, function (b, url) {
                                if (b) {
                                    mes.push({ item: item, sign: true, timeout: true, url: url, error: !b });
                                }
                                item.__lastSignTime = now;
                                loop(true);
                            });

                        } else {
                            mes.push({ item: item, sign: true, timeout: false });
                            loop(true);
                        }
                    } else {
                        //无需签名
                        mes.push({ item: item, sign: false });
                        loop(true);
                    }
                } else {
                    //未在播放区间，忽略
                    loop(true);
                }

            }, function (b) {

                _logger.log("count: " + mes.length);
                _this.dispatchEvent("durationchange");

               util.forEach(mes, function (item) {

                   loadElement(item.item);

                   if (!item.error && item.url) {
                       item.item.__signurl = item.url;
                       if (item.item == _currentElement) {
                           item.item.src = item.url;
                       }
                   } else {
                       if (item.item == _currentElement) {
                           if (item.item.__signurl) {
                               item.item.src = item.item.__signurl;
                           } else {
                               item.item.load();
                           }
                       }
                   }

                   //if (!item.sign || (item.sign && !item.timeout)) {
                   //    loadElement(item.item);
                   //} else {
                   //    if (item.error) {
                   //        loadElement(item.item);
                   //    } else {
                   //        _logger.log("更新url");
                   //        if (item.item.element != null) {
                   //            _element.removeChild(item.item.element);
                   //            item.item.destory();
                   //        }
                   //        loadElement(item.item, item.url);
                   //    }
                   //}



               });

                _mediaPhase = MEDIAPHASE_LOADING;

            });


        };

        _this.play = function () {
            if (_ended || _autoplaying) {
                return;
            }

            _this.dispatchEvent("play");
            _autoplaying = true;
            if (_mediaPhase >= MEDIAPHASE_NONE && _mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                _this.dispatchEvent("waiting");
                _lastOperate = MEDIAOPERATE_PLAY;
                if (_mediaPhase == MEDIAOPERATE_NONE) {
                    _this.load();
                } else {
                    //其他情况说明正在异步载入
                }
            } else if (_mediaPhase == MEDIAPHASE_PAUSED) {
                _mediaPhase = MEDIAPHASE_PLAYING;

                elementPlay(_currentElement);


            } else if (_mediaPhase == MEDIAPHASE_WAITING) {
                _lastOperate = MEDIAOPERATE_PLAY;
            } else if (_mediaPhase == MEDIAPHASE_SEEKING) {
                _lastOperate = MEDIAOPERATE_PLAY;
            }

        };

        _this.pause = function () {
            if (!_autoplaying) {
                return;
            }
            _this.dispatchEvent("pause");
            _autoplaying = false;
            _lastOperate = MEDIAOPERATE_PAUSE;
            _mediaPhase = MEDIAPHASE_PAUSED;

            if (_currentElement != null) {
                _currentElement.pause();
            }


        }


        _this.stop = function () {
            //  _mediaPhase = MEDIAPHASE_PAUSED;
            _mediaPhase = MEDIAPHASE_NONE;
            _logger.log("vcplayer stop..." + _id);
            util.forEach(_mediaElements, function (item) {
                if (item.mediaStatus != MEDIASTATE_NONE) {
                    item.stop();
                }
            });
            //在载入过程中取消，清除载入状态，以便下次能正常载入
            if (_mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                _mediaPhase = MEDIAPHASE_NONE;
            }

            //if (_element != null) {
            //    _mediaPhase = MEDIAPHASE_NONE;
            //    _autoplaying = false;
            //    _autoJumpTime = -1;
            //    _buffering = 0;
            //    _overJump = false;
            //    _element.setAttribute("src", "");
            //}
        };


        _this.destory = function (b) {
            if (_mediaElements.length > 0) {
                util.forEach(_mediaElements, function (item) {
                    if (item.destory) {
                        item.destory();
                    }
                });

            }

            while(_element.hasChildNodes()){
                _element.removeChild( _element.lastChild);
            }

            _mediaPhase = MEDIAPHASE_NONE;
            _currentElement = null;
            _lastElement = null;
            _firstElement = null;
            _mediaElements.length = 0;
            _autoplaying = false;
            _autoJumpTime = -1;
            if (!b) {
                _this.eventListeners.length = 0;
            }



        };

        function canSetProperty(pn, val) {
            if (_propertySetter && _propertySetter[pn]) {
                return _propertySetter[pn](val);
            }

            return true;
        }

        Object.defineProperties(_this, {
            currentSrc: {
                get: function () {
                    return _currentSrc;
                }
            },
            element: {
                get: function () {
                    //if (_currentElement != null) {
                    //    return _currentElement.element;
                    //}
                    return _element;
                }
            },
            videoElement: {
                get: function () {
                    if (_isAudio) {
                        return null;
                    }

                    if (_currentElement != null && _currentElement.element != null && _currentElement.element.tagName.toUpperCase() == "VIDEO") {
                        return _currentElement.element;
                    }
                    return null;
                }
            },
            networkState: {
                get: function () {
                    if (_currentElement) {
                        return _currentElement.networkState;
                    }
                    return stateObj.NETWORK_EMPTY;
                }
            },
            readyState: {
                get: function () {
                    if (_currentElement) {
                        return _currentElement.readyState;
                    }
                    return stateObj.HAVE_NOTHING;
                }
            },
            seeking: {
                get: function () {
                    return _mediaPhase == MEDIAPHASE_SEEKING;
                }
            },
            paused: {
                get: function () {
                    return !_autoplaying;
                }
            },
            duration: {
                get: function () {
                    return _duration;
                }
            },
            currentTime: {
                get: function () {
                    return _currentTime - _start;
                    //if (_mediaPhase <= MEDIAPHASE_LOADEDJUMP || _mediaPhase == MEDIAPHASE_SEEKING) {
                    //    return _currentTime - _start;
                    //}
                    //if (_currentElement) {
                    //    var time = _currentElement.currentTime + _currentElement.__clipIn - _start;
                    //    if (time < 0) {
                    //        time = 0;
                    //    }
                    //    if (time > _duration) {
                    //        time = _duration;
                    //    }

                    //    return time;
                    //}

                    return 0;
                },
                set: function (val) {
                    if (val < 0) {
                        val = 0;
                    }
                    setCurrentTime(val);


                }
            },
            ended: {
                get: function () {
                    return _ended;
                }
            },
            error: {
                get: function () {
                    return _error;
                }
            },
            defaultPlaybackRate: {
                get: function () {
                    return _defaultPlaybackRate
                },
                set: function (val) {
                    if (canSetProperty("defaultPlaybackRate", val)) {
                        _defaultPlaybackRate = val;
                        if (_currentElement != null) {
                            _currentElement.defaultPlaybackRate = _defaultPlaybackRate;
                        }
                    }
                }
            },
            playbackRate: {
                get: function () {
                    return _playbackRate
                },
                set: function (val) {
                    if (canSetProperty("playbackRate", val)) {
                        _playbackRate = val;
                        if (_currentElement != null) {

                            _currentElement.playbackRate = _playbackRate;
                        }
                    }
                }
            },
            //For Test
            currentElement: {
                get: function () {
                    return _currentElement;
                }
            },

            elements: {
                get: function () {
                    return _mediaElements;
                }
            },
            muted: {
                get: function () {
                    return _muted;
                },
                set: function (val) {
                    if (canSetProperty("muted", val)) {
                        if (_muted != val) {
                            _muted = val;
                            _this.dispatchEvent("volumechange");
                            if (_currentElement != null) {
                                _currentElement.muted = _muted;
                            }
                        }
                    }
                }

            },
            volume: {
                get: function () {
                    return _volume;
                },
                set: function (val) {
                    if (val < 0) {
                        val = 0;
                    }
                    if (val > 1) {
                        val = 1;
                    }
                    if (canSetProperty("volume", val)) {
                        if (_volume != val) {
                            _volume = val;
                            if (_currentElement != null) {
                                _currentElement.volume = _volume;
                            }
                            _this.dispatchEvent("volumechange");
                        }
                    }
                }

            },
            mediaStatus: {
                get: function () {
                    if (_mediaPhase == MEDIAPHASE_NONE) {
                        return MEDIASTATE_NONE;
                    }else if (_mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                        return MEDIASTATE_INITING;
                    } else if (_mediaPhase == MEDIAPHASE_SEEKING || _mediaPhase == MEDIAPHASE_WAITING) {
                        return MEDIASTATE_WAITING;
                    } else {
                        return MEDIASTATE_NORMAL;
                    }
                }
            }
        });
        //var _controller = new Controller({
        //    player: _this,
        //    container: _container
        //});
    }
});

stateObj.defineConst(VCPlayer.prototype);

if (typeof global !== "undefined") {
    if (global.VCPlayer) {
        global.VCPlayer[_version] = VCPlayer;
    } else {
        global.VCPlayer = VCPlayer;
    }
}

    ;/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="MediaElement.js" />
/// <reference path="NullMediaElement.js" />
/// <reference path="VCPlayer.js" />

var timelineTrackEventPlugins = {};

var TimelinePlayer = EventObject.extend({
    init: function (options) {
        this._super();
        var _this = this,
            _options = options || {},
            _container = _options.container,
            _duration = 0,
            _autoPlaying = false,
            _ended = false,
            _logger = _options.logger || new logger(),
            _playbackRate = 1,
            _error = null,
            _muted = false,
            _isSeeking =false,
            _volume = 1,
            _useCanvas = _options.useCanvas || false,
            _defaultPlaybackRate = 1,
            _mediaPhase = MEDIAPHASE_NONE,
            _lastOperate = MEDIAOPERATE_NONE,
            _lastOperateSeek = MEDIAOPERATE_NONE,
            _trackEvents = [],
            _canvas = null,
            _offlineCanvas = null,
            _useCros = (typeof _options.useCros == 'unefined') ? true : _options.useCros,
            _canvasContext = null,
            _tracksCanvas = [],
            _suspend = false,
            _offlineCanvasContext = null,
            _backgrundPlayer = null, //一个空的播放器，用于时间线非连续情况下的持续播放
            _currentTrackEvents = []; //保存处于当前播放位置的trackEvent

        _backgrundPlayer = new NullMediaElement({ frame: true });
        _backgrundPlayer.load();

        _backgrundPlayer.addEventListener("timeupdate", _timeupdate);
        _backgrundPlayer.addEventListener("ended", function () {
            _ended = true;
            _autoPlaying = false;
            _this.dispatchEvent("pause");
            _this.dispatchEvent("ended");
        });

        if (_useCanvas) {
            initCanvas();
        }

        function initCanvas() {

            var rect = _container.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {

                if (_canvas && _canvas.width == rect.width && _canvas.height == rect.height) {
                    return;
                }

                if (_canvas) {

                    if (_container.contains(_canvas)) {
                        _container.removeChild(_canvas);
                    }

                    delete _canvas;
                    _canvas = null;
                }
                if (_offlineCanvas) {
                    delete _offlineCanvas;
                    _offlineCanvas = null;
                }

                var trackCanvasCount = _tracksCanvas.length;
                for (var i = 0; i < _tracksCanvas.length; i++) {
                    var c = _tracksCanvas[i].canvas;
                    if (c) {
                        delete c;
                        c = null;
                    }
                }
                _tracksCanvas.length = 0;

                _canvas = document.createElement("canvas");
                _canvas.width = rect.width;
                _canvas.height = rect.height;
                _canvas.setAttribute("class", "playerCanvas");
                _canvas.style.position = "absolute";
                _canvas.style.left = "0px";
                _canvas.style.top = "0px";
                _container.appendChild(_canvas);
                _canvasContext = _canvas.getContext("2d");

                //一个离线 5个轨道所用离线Canvas
                var minCount = Math.max(trackCanvasCount, 5);
                for (var i = 0; i <= minCount; i++) {
                    var c = document.createElement("canvas");
                    c.width = rect.width;
                    c.height = rect.height;
                    var cx = c.getContext("2d");
                    if (i == 0) {
                        _offlineCanvas = c;
                        _offlineCanvasContext = cx;
                    } else {
                        _tracksCanvas.push({ canvas: c, context: cx });
                    }
                }


                util.forEach(_trackEvents, function (item) {
                    if (item.resize) {
                        item.resize(rect);
                    }
                });
            }

        }

        function _playerWaiting(e) {
            var oldWaiting = isWaiting();
            e.target.__waiting = true;
        //    console.log("waiting.....");
            var trackEvent = getTrackEventFromPlayer(e.target);
            if (trackEvent != null) {
                _backgrundPlayer.playbackRate = 0;
                e.target.playbackRate = 0;
                if (!oldWaiting) {
                    var minTime = _backgrundPlayer.currentTime;
                    util.forEach(_currentTrackEvents, function (item) {
                        if (item.isMediaPlayer && item.mediaStatus == MEDIASTATE_NORMAL) {
                            item.playbackRate = 0;
                            var ct = item.startTime + item.currentTime;
                            minTime = Math.min(ct, minTime);
                        }
                    });

                    //同步时间
                    if (minTime != _backgrundPlayer.currentTime) {
                        _backgrundPlayer.currentTime = minTime;
                        util.forEach(_currentTrackEvents, function (item) {
                            //item.ended 小数差异，可能已经播放结束，但当前时间不等于结束时间
                            if (item.isMediaPlayer && item.mediaStatus == MEDIASTATE_NORMAL && !item.ended ) {
                                var ct = item.startTime + item.currentTime;
                                if (ct > minTime) {
                                    item.__waittime = true;
                                }
                            }
                        });
                    }
                    _mediaPhase = MEDIAPHASE_WAITING;
                    _this.dispatchEvent("waiting");
                }
            }
        }
        function _playerCanplaythrough(e) {
            var oldWaiting = isWaiting();
           // _logger.log("canplaythrough..." + oldWaiting + ' ' + e.target.id);
            e.target.__waiting = false;
            var trackEvent = getTrackEventFromPlayer(e.target);
            if (trackEvent != null) {
                var newWaiting = isWaiting();
                if (oldWaiting && !newWaiting) {
                    if (_isSeeking) {
                        _isSeeking = false;
                    }
                    //    console.log("canplaythrough...");
                    _mediaPhase = MEDIAPHASE_PLAYING;
                    _this.dispatchEvent("canplaythrough");
                    util.forEach(_currentTrackEvents, function (item) {
                        if (item.isMediaPlayer && !item.__waittime) {
                            item.playbackRate = _playbackRate;
                            if (item.paused && _autoPlaying) {
                                setTrackEventPlayerProperty(item);
                                item.Play();
                            }
                        }
                    });
                    _backgrundPlayer.playbackRate = _playbackRate;
                    drawFrame();
                } else if (oldWaiting && newWaiting) {
                    e.target.playbackRate = 0;
                }
            }
        }

        function _playerError(e) {
            if (_error == null) {
                _error = e.target.error;
                _this.dispatchEvent("error");
            }
        }


        function _timeupdate(e) {
            if (_isInnerAdjustTime || _isSeeking) {
                return;
            }
            _error = null;
            _ended = false;

            currentTimeTrace();


        }

        var _isInnerAdjustTime = false;
        function currentTimeTrace() {
            if (_isSeeking) {
                return;
            }

            var _currentTime = _backgrundPlayer.currentTime;

            //时间同步
            var minTime = _currentTime;
            util.forEach(_currentTrackEvents, function (item) {
                if (item.isMediaPlayer && item.error==null && item.mediaStatus == MEDIASTATE_NORMAL && !item.ended) {
                    minTime = Math.min(minTime, item.startTime + item.currentTime);
                }
            });
            if (minTime != _currentTime) {
                _currentTime = minTime;
                _isInnerAdjustTime = true;
                _backgrundPlayer.currentTime = _currentTime;
                _isInnerAdjustTime = false;
            }



            util.forEach(_currentTrackEvents, function (item) {
                if (item.__waittime && item.playbackRate == 0) {
                    var ct = item.startTime + item.currentTime;
                    if (ct <= _currentTime) {
                        item.__waittime = false;
                        item.playbackRate = _playbackRate;
                    }
                }
            });

            //当前事件中，超过当前时间的事件，从当前列表中移除
            var removeTrackEvents = [];
            util.forEach(_currentTrackEvents, function (item) {
                if (item.startTime > _currentTime || item.endTime <= _currentTime) {
                    removeTrackEvents.push(item);
                }
            });
            util.forEach(removeTrackEvents, function (item) {
                var idx = _currentTrackEvents.indexOf(item);

                _currentTrackEvents.splice(idx, 1);
                item.end();
            });

            //进入当前时间，但在当前列表中不存在的事件
            var nextTrackEvents = [];
            var offsetTime = _currentTime + 5;
            util.forEach(_trackEvents, function (item) {
                if (item.startTime <= _currentTime && item.endTime > _currentTime) {
                    var idx = _currentTrackEvents.indexOf(item);
                    if (idx < 0) {
                        insertToCurrentTrackEvents(item);
                      //  _currentTrackEvents.push(item);
                        setTrackEventPlayerProperty(item);
                        item.start();
                        item.currentTime = _currentTime - item.startTime;
                        if (item.isMediaPlayer && item.paused) {
                            setTrackEventPlayerProperty(item);
                            item.Play();
                        }
                        if ( item.isMediaPlayer && item.mediaStatus != MEDIASTATE_NORMAL && _mediaPhase!= MEDIAPHASE_WAITING) {
                            _mediaPhase = MEDIAPHASE_WAITING;
                            _this.dispatchEvent("waiting");
                        }
                    }
                } else {
                    if (item.startTime <= offsetTime && item.endTime > offsetTime) {
                        nextTrackEvents.push(item);
                    }
                }
            });

            //预加载
            util.forEach(nextTrackEvents, function (item) {
                if (item.isMediaPlayer && item.mediaStatus== MEDIASTATE_NONE) {
                    item.playbackRate = 0;
                    item.muted = true;
                    item.currentTime = 0;
                    _logger.log(lang[_curLang].preload + item.id);
                }
            });

            //触发timeupdate回调
            util.forEach(_currentTrackEvents, function (item) {
                item.timeupdate(_currentTime);
            });

            drawFrame();
            _this.dispatchEvent("timeupdate");
        }

        function setTrackEventPlayerProperty(item) {
            if (item.isMediaPlayer ) {
                var player = item;
                player.playbackRate = _playbackRate;
                player.defaultPlaybackRate = _defaultPlaybackRate;
                player.muted = _muted;
                player.volume = _volume;
            }
        }

        function getTrackEventFromPlayer(p) {
            var trackEvent = util.first(_currentTrackEvents, function (item) {
                if (item.isMediaPlayer && item == p) {
                    return true;
                }
                return false;
            });

            return trackEvent;
        }

        function isWaiting() {
            var waiting = false;
            for (var i = 0; i < _currentTrackEvents.length; i++) {
                var item = _currentTrackEvents[i];
                if (item.isMediaPlayer && item.__waiting) {
                    waiting = true;
                    break;
                }
            }

            return waiting;
        }
        _this.waited = function () {
            return isWaiting();
        }

        //恢复默认状态
        _this.clear = function () {
            _error = null;
            _suspend = false;
            _backgrundPlayer.pause();
            _backgrundPlayer.currentTime = 0;
            _currentTrackEvents.length = 0;
            util.forEach(_trackEvents, function (item) {
                destoryTrackEvent(item);
            });
            _trackEvents.length = 0;

        };

        _this.suspend = function () {
            _suspend = true;
        };
        _this.resume = function () {
            _suspend = false;

            var dl =[];
            util.forEach(_trackEvents, function (item) {
                if (item.__removed) {
                    var idx = _currentTrackEvents.indexOf(item);
                    if (idx >= 0) {
                        item.end();
                        _currentTrackEvents.splice(idx, 1);
                    }

                    dl.push(item);
                }

            });

            util.forEach(dl, function (item) {

                var idx = _trackEvents.indexOf(item);
                if (idx >= 0) {
                    destoryTrackEvent(item);
                    _trackEvents.splice(idx, 1);
                }
            });

        };

        _this.play = function () {
            if (_suspend)
                return;


            if (_autoPlaying || _ended) {
                return;
            }

            _autoPlaying = true;
            _error = null;
            _this.dispatchEvent("play");
            if (_mediaPhase == MEDIAPHASE_WAITING) {
                _this.dispatchEvent("waiting");
            } else {
                if (!isWaiting()) {
                    util.forEach(_currentTrackEvents, function (item) {
                        if (item.isMediaPlayer) {
                            setTrackEventPlayerProperty(item);
                            item.Play();
                        }
                    });
                    _backgrundPlayer.play();

                    _this.dispatchEvent("playing");
                } else {
                    _mediaPhase = MEDIAPHASE_WAITING;
                    _this.dispatchEvent("waiting");
                }
            }

        };

        _this.pause = function () {
            if (_suspend) {
                return;
            }

            if (_autoPlaying) {
                _autoPlaying = false;
                util.forEach(_currentTrackEvents, function (item) {
                    if (item.isMediaPlayer) {
                        item.Pause();
                    }
                });
                _backgrundPlayer.pause();
                _this.dispatchEvent("pause");
            }

        };

        _this.print = function () {
            var info = '';
            for (var i = 0; i < _currentTrackEvents.length; i++) {
                var te= _currentTrackEvents[i];
                info = info + '\r\n';
                info += (te.id + '\t' + te.startTime + '\t' + te.endTime + '\t' + te.currentTime);
            }

            _logger.log(info);


        };

        _this.addTrackEvent = function (type, id, options) {
            _logger.log(options);
            var plugin = timelineTrackEventPlugins[type];
            if (!plugin) {
                throw new Error(lang[_curLang].notSupportL + type + lang[_curLang].notSupportR);
            }
            var trackEvent = util.first(_trackEvents, function (item) {
                if (item.pluginType == type && item.id == id) {
                    return true;
                }
                return false;
            });
            var shouldStart = true;
            if (trackEvent) {
                //先从当前列表中移除，以防止更新事件影响当前状态
                if (!_suspend) {
                    var idx = _currentTrackEvents.indexOf(trackEvent);
                    if (idx >= 0) {
                        _currentTrackEvents.splice(idx, 1);
                        shouldStart = false;
                        //trackEvent.end();

                    }

                } else {
                    trackEvent.__removed = true;

                }
                options.logger = _logger;
                options.useCros = _useCros;
                _logger.log("update trackEvent: " + id + " " + options.start + " " + options.end);
                var ctx = { mustStart: false };
                trackEvent._update(options, ctx);
                shouldStart = ctx.mustStart;
            }
            else {
                options.logger = _logger;
                options.useCros = _useCros;
                trackEvent = new plugin(id, type, _this, options);
                _trackEvents.push(trackEvent);
                trackEvent.setup();
                _logger.log("add trackEvent: " + id + " " + options.start + " " + options.end);
                if (plugin._isMediaPlayer()) {
                    //处理事件
                    trackEvent.addEventListener("waiting", _playerWaiting);
                    trackEvent.addEventListener("canplaythrough", _playerCanplaythrough);
                    trackEvent.addEventListener("error", _playerError);
                }
            }

            if (!_suspend) {
                var currentTime = _backgrundPlayer.currentTime;
                if (currentTime >= trackEvent.startTime && currentTime < trackEvent.endTime) {
                    var idx = _currentTrackEvents.indexOf(trackEvent);
                    if (idx < 0) {
                        insertToCurrentTrackEvents(trackEvent);
                        // _currentTrackEvents.push(trackEvent);
                        if (shouldStart) {
                            trackEvent.start();
                        }
                    }

                    if (trackEvent.isMediaPlayer) {
                        if (trackEvent.mediaStatus != MEDIASTATE_NORMAL) {
                            _mediaPhase = MEDIAPHASE_WAITING;
                            _this.dispatchEvent("waiting");
                        }
                        if (shouldStart) {
                            trackEvent.currentTime = currentTime - trackEvent.startTime;
                        }
                        if (_autoPlaying) {
                            trackEvent.Play();
                        } else {
                            trackEvent.Pause();
                        }
                    }
                }

                drawFrame();
            }
        };

        function destoryTrackEvent(trackEvent) {
            if (trackEvent) {
                if (trackEvent.isMediaPlayer) {
                    trackEvent.removeEventListener("waiting", _playerWaiting);
                    trackEvent.removeEventListener("canplaythrough", _playerCanplaythrough);
                    trackEvent.removeEventListener("error", _playerError);
                }

                var idx = _currentTrackEvents.indexOf(trackEvent);
                if (idx >= 0) {
                    trackEvent.end(true);
                    _currentTrackEvents.splice(idx, 1);
                }

                trackEvent.destory();

            }
        }

        _this.removeTrackEvent = function (type, id) {
            var plugin = timelineTrackEventPlugins[type];
            if (!plugin) {
                return;
            }
            var trackEvent = util.first(_trackEvents, function (item) {
                if (item.pluginType == type && item.id == id) {
                    return true;
                }
                return false;
            });


            if (trackEvent) {
                _logger.log("remove trackEvent: " + id);
                if (!_suspend) {
                    destoryTrackEvent(trackEvent);
                    var idx = _trackEvents.indexOf(trackEvent);
                    _trackEvents.splice(idx, 1);

                    drawFrame();
                } else {
                    trackEvent.__removed = true;
                }
            }

        }

        _this.getTrackEvent = function (type, id) {
            var trackEvent = util.first(_trackEvents, function (item) {
                if (item.pluginType == type && item.id == id) {
                    return true;
                }
                return false;
            });
            return trackEvent;
        }

        _this.resize = function () {
            initCanvas();
            drawFrame();
        };

        function setCurrentTrackEventsProperty(propertyName, val) {
            util.forEach(_currentTrackEvents, function (item) {
                if (item.isMediaPlayer) {
                    item[propertyName] = val;
                }
            });
            _backgrundPlayer[propertyName] = val;
        }

        function insertToCurrentTrackEvents(item) {
            var idx = -1;
            for (var i = 0; i < _currentTrackEvents.length; i++) {
                var cur = _currentTrackEvents[i];
                if (cur.zIndex > item.zIndex) {
                    idx = i;
                    break;
                }
            }

            if (idx >= 0) {
                _currentTrackEvents.splice(idx, 0, item);
            } else {
                _currentTrackEvents.push(item);
            }
        }

        function setCurrentTime(val) {

            if (_suspend) {
                return;
            }

            _isSeeking = true;
            _backgrundPlayer.playbackRate = 0;
            _backgrundPlayer.currentTime = val;
            var _currentTime = val;
            _ended = false;
            _error = null;

            _this.dispatchEvent("waiting");
            _this.dispatchEvent("timeupdate");

            var oldWaiting = isWaiting();

            //当前事件中，超过当前时间的事件，从当前列表中移除
            var removeTrackEvents = [];
            util.forEach(_currentTrackEvents, function (item) {
                if (item.startTime > _currentTime || item.endTime <= _currentTime) {
                    if (item.__waittime) {
                        item.__waittime = false;
                    }
                    removeTrackEvents.push(item);
                }
            });
            util.forEach(removeTrackEvents, function (item) {
                var idx = _currentTrackEvents.indexOf(item);
                _currentTrackEvents.splice(idx, 1);
                item.end();
            });

            var hasVideoTrack = false;
            //进入当前时间，但在当前列表中不存在的事件
            util.forEach(_trackEvents, function (item) {
                if (item.startTime <= _currentTime && item.endTime > _currentTime) {
                    var idx = _currentTrackEvents.indexOf(item);
                    if (idx < 0) {


                        insertToCurrentTrackEvents(item);
                      //  _currentTrackEvents.push(item);

                        item.start();
                        if (item.isMediaPlayer) {
                            setTrackEventPlayerProperty(item);
                            if (item.__isVideo) {
                                hasVideoTrack = true;
                            }
                        }
                    }
                }

            });

            //没有视频轨则清空canvas
            if (!hasVideoTrack) {
                var c = $('.playerCanvas');
                c[0].getContext('2d').clearRect(0,0,c.width(), c.height());
            }


            //跳转
            util.forEach(_currentTrackEvents, function (item) {
                if (item.isMediaPlayer) {
                    if (!_autoPlaying) {
                        item.Pause();
                    }
                    item.__waiting = true;
                    _logger.log("jump..." + item.id);
                    item.currentTime = _currentTime - item.startTime;
                }

            });

            setTimeout(function () {
                if (!isWaiting()) {
                    _isSeeking = false;
                    if (_autoPlaying) {
                        _mediaPhase = MEDIAPHASE_PLAYING;
                    } else {
                        _mediaPhase = MEDIAPHASE_PAUSED;
                    }
                   // if (oldWaiting) {
                        _this.dispatchEvent("canplaythrough");
                  //  }

                        if (_autoPlaying) {
                            _backgrundPlayer.play();
                        } else {
                            _backgrundPlayer.pause();
                        }
                    _backgrundPlayer.playbackRate = _playbackRate;
                }
            }, 0);


        }

        function drawFrame() {
            if (_currentTrackEvents.length == 0 || !_options.useCanvas) {
                //防止播放完视频后仍MV显示视频画面  2016.9.22 zxl
                _canvasContext.clearRect(0, 0, _canvas.width, _canvas.height);
                return;
            }
            _offlineCanvasContext.clearRect(0, 0, _offlineCanvas.width, _offlineCanvas.height);

            //先按轨道分组
            var tracks = {};
            var videoTrackCount = 0;
            for (var i = 0; i < _currentTrackEvents.length; i++) {
                var curItem = _currentTrackEvents[i];
                var idx = curItem.zIndex;
                var trackGroup = null;
                if (tracks[idx]) {
                    trackGroup = tracks[idx];
                    trackGroup.trackEvents.push(curItem);
                } else {
                    trackGroup = { trackEvents: [curItem], video:[], transition:[], mask:[]};
                    tracks[idx] = trackGroup;
                }

                if (curItem.pluginType == "PopcornMaskPlugin") {
                    //蒙版...
                    trackGroup.mask.push(curItem);
                }

                if (curItem.pluginType == "PopcornTransitionPlugin") {
                    //转场...
                    trackGroup.transition.push(curItem);

                }

                if (curItem.isMediaPlayer && !curItem.options.audio) {
                    //视频...
                    tracks[idx].hasVideo = true;
                    curItem.__isVideo = true;
                    trackGroup.video.push(curItem);

                    videoTrackCount++;
                } else {
                    curItem.__isVideo = false;
                }
            }

            //创建每个轨道的离屏Canvas
            if (_tracksCanvas.length < videoTrackCount) {
                var rect = _container.getBoundingClientRect();
                for (var i = _tracksCanvas.length; i < videoTrackCount; i++) {
                    var c = document.createElement("canvas");
                    c.width = rect.width;
                    c.height = rect.height;
                    var cx = _offlineCanvas.getContext("2d");
                    _tracksCanvas.push({ canvas: c, context: cx });
                }
            }

            var curTime = _this.currentTime;

            //针对每一轨生成合成后图像---有转场动画使用转场动画算法，没有就简单合成
            var vidx = 0;
            for (var key in tracks) {
                var trackGroup = tracks[key];
                if (trackGroup.hasVideo) {
                    var trackCanvas = _tracksCanvas[vidx];
                    if (trackGroup.transition.length == 0) {
                        //没有转场动画
                        for (var i = 0; i < trackGroup.video.length; i++) {
                            var trackEvent = trackGroup.video[i];
                            if (trackEvent.draw) {
                                trackEvent.draw(trackCanvas.context, curTime - trackEvent.startTime, trackGroup.video,trackGroup);
                            }
                        }
                    } else {
                        //交由转场动画trackEvent处理
                        trackCanvas.context.clearRect(0, 0, trackCanvas.context.canvas.width, trackCanvas.context.canvas.height);
                        for (var i = 0; i < trackGroup.transition.length; i++) {
                            var trackEvent = trackGroup.transition[i];
                            trackEvent.draw(trackCanvas.context, curTime - trackEvent.startTime, trackGroup.video, trackGroup);
                        }
                    }

                    trackGroup.canvasContext = trackCanvas;
                    vidx++;
                }
            }

            //合成  特效
            for (var key in tracks) {
                var trackGroup = tracks[key];
                if (trackGroup.mask.length > 0) {
                    //蒙版-->暂时未实现
                    for (var i = 0; i < trackGroup.mask.length; i++) {
                        var trackEvent = trackGroup.mask[i];
                        trackEvent.draw(_offlineCanvasContext, curTime - trackEvent.startTime, tracks[k - 1], tracks[k + 1], tracks, trackGroup);
                    }
                }else if (trackGroup.hasVideo) {
                    _offlineCanvasContext.drawImage(trackGroup.canvasContext.canvas, 0, 0);
                } else {
                    for (var i = 0; i < trackGroup.trackEvents.length; i++) {
                        var trackEvent = trackGroup.trackEvents[i];
                        if (trackEvent.draw) {
                            trackEvent.draw(_offlineCanvasContext, curTime - trackEvent.startTime, trackGroup);
                        }
                    }
                }
            }

            _canvasContext.clearRect(0, 0, _canvas.width, _canvas.height);
            _canvasContext.drawImage(_offlineCanvas, 0, 0);

        }




        Object.defineProperties(_this, {
            error: {
                get: function () {
                    return _error;
                }
            },
            isSuspend:{
                get: function () {
                    return _suspend;
                }
            },
            duration: {

                get: function () {
                    return _backgrundPlayer.duration;
                },
                set: function (val) {
                    _backgrundPlayer.duration = val;
                    if (_backgrundPlayer.currentTime != val) {
                        _ended = false;
                    } else {
                        _ended = true;
                        _autoPlaying = false;
                    }
                }
            },
            currentTime: {
                get: function () {
                    return _backgrundPlayer.currentTime;
                },
                set: function (val) {
                    var cur = val;
                    if (cur > _backgrundPlayer.duration) {
                        cur = _backgrundPlayer.duration;
                    }
                    if (cur < 0) {
                        cur = 0;
                    }
                    setCurrentTime(cur);
                }
            },
            paused: {
                get: function () {
                    return !_autoPlaying;
                }
            },
            defaultPlaybackRate: {
                get: function () {
                    return _defaultPlaybackRate
                },
                set: function (val) {
                    _defaultPlaybackRate = val;
                    setCurrentTrackEventsProperty("defaultPlaybackRate", val);
                }
            },
            playbackRate: {
                get: function () {
                    return _playbackRate
                },
                set: function (val) {
                    _playbackRate = val;
                    setCurrentTrackEventsProperty("playbackRate", val);
                }
            },
            useCanvas: {
                get: function () {
                    return _useCanvas;
                }
            },
            muted: {
                get: function () {
                    return _muted;
                },
                set: function (val) {
                    if (_muted != val) {
                        _muted = val;
                        setCurrentTrackEventsProperty("muted", val);
                        _this.dispatchEvent("volumechange");
                        if (_muted) {
                            _this.dispatchEvent("muted");
                        } else {
                            _this.dispatchEvent("unmuted");
                        }
                    }
                }

            },
            volume: {
                get: function () {
                    return _volume;
                },
                set: function (val) {
                    if (val < 0) {
                        val = 0;
                    }

                    if (_volume != val) {
                        _volume = val;
                        setCurrentTrackEventsProperty("volume", val);
                        _this.dispatchEvent("volumechange");
                    }
                }

            },
            element: {
                get: function () {
                    return _container;
                }
            },
            trackEvents:  {
                get: function () {
                    return _trackEvents;
                }
            },
            ended: {
                get: function () {
                    return _ended;
                }
            },
            mediaStatus: {
                get: function () {
                    if (_mediaPhase == MEDIAPHASE_WAITING) {
                        return MEDIASTATE_WAITING;
                    } else if (_mediaPhase <= MEDIAPHASE_LOADEDJUMP) {
                        return MEDIASTATE_INITING;
                    }
                    return MEDIASTATE_NORMAL;

                }
            },
            manifest: {
                get: function () {
                    return TimelinePlayer.manifest;
                }
            },
            TimelinePlayer: {
                get: function () {
                    return TimelinePlayer;
                }
            }
        });


    }
});

var TimelineTrackEventPlugin = EventObject.extend({
    init: function (id, type, player, options) {
        var _options = util.clone(options || {}),
            _id = id,
            _type = type,
            _player = player;
        var _this = this;
        _this._super();

        _this._update = function (options, ctx) {

            if (_this.timelinePlayer.isSuspend) {
                util.mergeForGC(_options, options);
            } else {

                _this.update(options, ctx);
                util.mergeForGC(_options, options);
            }
        }

        Object.defineProperties(_this, {
            options: {
                get: function () {
                    return _options;
                }
            },
            id: {
                get: function () {
                    return _id;
                }
            },
            startTime: {
                get: function () {
                    return _options.start || 0;
                }
            },
            endTime: {
                get: function () {
                    return _options.end || 0;
                }
            },
            zIndex: {
                get: function () {
                    return _options.zindex || 0;
                }
            },
            pluginType: {
                get: function () {
                    return _type;
                }
            },
            timelinePlayer: {
                get: function () {
                    return _player;
                }
            },
            isMediaPlayer: {
                get: function () {
                    return timelineTrackEventPlugins[_type]._isMediaPlayer();
                }
            }
        });

   //     if (_this.isMediaPlayer) {
            Object.defineProperties(_this, {
                muted: {
                    get: function () {
                        return _this.Muted();
                    },
                    set: function (val) {
                        _this.Muted(val);
                    }
                },
                volume: {
                    get: function () {
                        return _this.Volume();
                    },
                    set: function (val) {
                        _this.Volume(val);
                    }
                },
                playbackRate: {
                    get: function () {
                        return _this.PlaybackRate();
                    },
                    set: function (val) {
                        _this.PlaybackRate(val);
                    }
                },
                defaultPlaybackRate: {
                    get: function () {
                        return _this.DefaultPlaybackRate();
                    },
                    set: function (val) {
                        _this.DefaultPlaybackRate(val);
                    }
                },
                mediaStatus: {
                    get: function () {
                        return _this.MediaStatus();
                    }
                },
                currentTime: {
                    get: function () {
                        return _this.CurrentTime();
                    },
                    set: function (val) {
                        _this.CurrentTime(val);
                    }
                },
                paused: {
                    get: function () {
                        return _this.Paused();
                    }
                },
                ended: {
                    get: function () {
                        return _this.Ended();
                    }
                }
            });
     //   }

    },
    setup: function () {
    },
    destory: function () {
    },
    timeupdate: function (time) {
    },
    start: function () {
    },
    end: function () {
    },
    update: function () {

    },
    Play:function(){
    },
    Pause:function(){
    },
    Muted: function (val) {
    },
    Volume: function (val) {
    },
    PlaybackRate: function (val) {
    },
    DefaultPlaybackRate: function (val) {
    },
    CurrentTime: function (val) {
    },
    MediaStatus: function () {
    },
    Paused: function () {
    },
    Ended: function () {
    }
});

TimelinePlayer.manifest = { owner: TimelinePlayer };
TimelinePlayer.pluginList = timelineTrackEventPlugins;

TimelinePlayer.plugin = function (pluginType, property, callback) {
    var instanceFunc = {
        pluginType: function () {
            return pluginType;
        }
    };
    var staticFunc = {};
    for (var k in property) {
        if (property.hasOwnProperty(k)) {
            if (k.substring(0, 1) == '_') {
                staticFunc[k] = property[k];
            }
            else if (k == 'manifest') {
                var p = {};
                p[pluginType] = { writable: false };
                p[pluginType].value = util.createReadonlyObject(property[k]);

                Object.defineProperties(TimelinePlayer.manifest, p);
            }
            else {
                instanceFunc[k] = property[k];
            }
        }
    }



    var plugin = TimelineTrackEventPlugin.extend(instanceFunc);
    for (var k in staticFunc) {
        if (staticFunc.hasOwnProperty(k)) {
            plugin[k] = staticFunc[k];
        }
    }
    if (typeof plugin._isMediaPlayer == "function") {
    } else {
        plugin._isMediaPlayer = function () { return false; };
    }

    timelineTrackEventPlugins[pluginType] = plugin;

    if (callback) {
        callback(TimelinePlayer);
    }
};

if (typeof global !== "undefined") {
    if (global.TimelinePlayer) {
        global.TimelinePlayer[_version] = TimelinePlayer;
    } else {
        global.TimelinePlayer = TimelinePlayer;
        global.TimelinePlayer.Class = Class;
        global.TimelinePlayer.EventObject = EventObject;
        global.TimelinePlayer.Logger = logger;
        global.TimelinePlayer.util = util;
    }
};/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="../MediaElement.js" />
/// <reference path="../NullMediaElement.js" />
/// <reference path="../VCPlayer.js" />
/// <reference path="../TimelinePlayer.js" />
(function (TimelinePlayer) {
    TimelinePlayer.plugin("PopcornMediaPlugin", {
        _isMediaPlayer: function () {
            return true;
        },
        setup: function () {

            var _container = document.createElement("div");
            _container.style.zIndex = 0;
            _container.className = "popcorn-media";
            _container.style.position = "absolute";
            _container.style.width = "100%";
            _container.style.height = "100%";
            _container.style.top = 0;
            _container.style.left = 0;


            var options = this.options,
                _this = this;

            _this.toString = function () {
                return options.title || options.source || "";
            };

            var v = new VCPlayer({
                logger: options.logger,
                useCros: options.useCros
               });

               _container.appendChild(v.element);

               _container.style.zIndex = _this.zIndex;


               var _player = v;
               var _error = null;
               Object.defineProperties(_this, {
                   mediaPlayer: {
                       get: function () {
                           return _player;
                       }
                   },
                   error: {
                       get: function () {
                           return _player.error;
                       }
                   },
                   container: {
                       get: function () {
                           return _container;
                       }
                   }
               });



               v.addEventListener("waiting", function () {
                   _this.dispatchEvent("waiting");
               });
               v.addEventListener("seeking", function () {
                   _this.dispatchEvent("waiting");
               });
               v.addEventListener("canplaythrough", function () {
                   _this.dispatchEvent("canplaythrough");
               });
               v.addEventListener("seeked", function () {
                   _this.dispatchEvent("canplaythrough");
               });
               v.addEventListener("error", function (e) {
                   _this.dispatchEvent("error");
               });
               var _clip = options.source;
               if (typeof _clip == "string") {
                   _clip = {
                       ref:[{
                           clipfile: _clip,
                           begin: 0,
                           clipbegin: 0,
                           clipend: _this.options.duration
                       }]
                   };
               } else {

               }

               v.setSource(_clip, _this.id, {
                   start: _this.options.from,
                   end: _this.options.duration,
                   signUrlCallback: _this.options.signUrlCallback,
                   signTimeout: _this.options.signTimeout || 3600,
                   audio: _this.options.audio || false
               });

        },
        destory: function (b) {
            if (this.timelinePlayer.element.contains(this.container)) {
                this.timelinePlayer.element.removeChild(this.container);
            }
            this.mediaPlayer.destory();
            if (!b) {
                this.eventListeners.length = 0;
            }
        },
        draw: function (context) {
           // var context = document.createElement("canvas").getContext("2d");
          //  context.fillStyle = "red";
           // context.fillRect(0, 0, context.canvas.width, context.canvas.height);
            if (this.mediaPlayer) {
                var video = this.mediaPlayer.videoElement;
                if (video && video.videoWidth >0) {
                    //add by zxl   iphone video
                    var vh = video.videoHeight,
                        vw = video.videoWidth,
                        ch = context.canvas.height,
                        cw = context.canvas.width,
                        scale, dw, dl, dt, dh;
                    //清空画面
                    context.clearRect(0, 0, cw, ch);
                    if (vh / vw >= ch / cw) {
                        scale = ch / vh;
                        dw = Math.floor(vw * scale)-1;
                        dh = ch -2;
                        dl = Math.floor((cw - vw * scale) / 2);
                        dt = 0;
                    }
                    else {
                        scale = cw / vw;
                        dw = cw -2;
                        dh = Math.floor(vh * scale)-1;
                        dl = 0;
                        dt = Math.floor((ch - vh * scale) / 2);
                    }
                    context.drawImage(video, dl, dt, dw, dh);
                }
            }


        },
        getImage: function () {
            if (this.mediaPlayer) {
                var video = this.mediaPlayer.videoElement;
                if (video) {
                    return video;
                }
            }
            return null;
        },
        update: function (options, ctx) {

            var _this = this;

            util.mergeForGC(this.options, options);
            if (typeof options.from == "undefined" && typeof options.duration == "undefined") {
                //如果只是修改了时间线上位置，不用重建
                //if (typeof options.zindex == "number") {
                //    _container.style.zIndex = 0;
                //}
                if (typeof options.volume != "undefined") {
                    this.mediaPlayer.volume = options.volume;
                }
                ctx.mustStart = false;
            } else {

                this.mediaPlayer.destory(true);


                var _clip = this.options.source;
                if (typeof _clip == "string") {
                    _clip = {
                        ref: [{
                            clipfile: _clip,
                            begin: 0,
                            clipbegin: 0,
                            clipend: _this.options.duration
                        }]
                    };
                } else {

                }


                this.mediaPlayer.setSource(_clip, _this.id, {
                    start: _this.options.from,
                    end: _this.options.duration,
                    signUrlCallback: _this.options.signUrlCallback,
                    signTimeout: _this.options.signTimeout || 3600,
                    audio: _this.options.audio || false
                });

                ctx.mustStart = true;
            }
        },
        start: function () {
            if (!this.options.audio && !this.timelinePlayer.useCanvas) {
                this.container.style.zIndex = this.zIndex;
                this.timelinePlayer.element.appendChild(this.container);
            }
            //if (this.mediaPlayer.currentTime != 0) {
            //    this.mediaPlayer.currentTime = 0;
            //}
            //if (!this.timelinePlayer.paused) {

            //    this.mediaPlayer.play();
            //}
        },
        end: function () {
            if (!this.options.audio && !this.timelinePlayer.useCanvas) {
                this.timelinePlayer.element.removeChild(this.container);
            }
            //释放连接
            this.mediaPlayer.stop();
        },
        timeupdate:function(time){
        },
        Play: function () {
            this.mediaPlayer.play();
        },
        Pause: function () {
            this.mediaPlayer.pause();
        },
        Muted: function (val) {
            if (typeof val == "undefined") {
                return this.mediaPlayer.muted;
            }

            if (this.options.mute) {
                this.mediaPlayer.muted = true;
            } else {
                this.mediaPlayer.muted = val;
            }
        },
        Volume: function (val) {
            if (typeof val == "undefined") {
                return this.mediaPlayer.volume;
            }

            this.mediaPlayer.volume = val;

        },
        PlaybackRate: function (val) {
            if (typeof val == "undefined") {
                return this.mediaPlayer.playbackRate;
            }

            this.mediaPlayer.playbackRate = val;
        },
        DefaultPlaybackRate: function (val) {
            if (typeof val == "undefined") {
                return this.mediaPlayer.defaultPlaybackRate;
            }

            this.mediaPlayer.defaultPlaybackRate = val;
        },
        CurrentTime: function (val) {
            if (typeof val == "undefined") {
                return this.mediaPlayer.currentTime;
            }

            this.mediaPlayer.currentTime = val;
        },
        MediaStatus: function () {
            return this.mediaPlayer.mediaStatus;
        },
        Paused: function () {
            return this.mediaPlayer.paused;
        },
        Ended:function(){
            return this.mediaPlayer.ended;
        },
        manifest: {
            about: {
                desc: 'Media resource class TrackEvent'
            },
            options: {
                start: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].in,
                    "units": lang[_curLang].second
                },
                end: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].out,
                    "units": lang[_curLang].second
                },
                source: {
                    elem: "input",
                    type: "url",
                    label: "Source URL",
                    hidden: true,
                    "default": ""
                },
                title: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].name,
                    readonly: true,
                    "default": ""
                },
                width: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].width,
                    "default": 100,
                    "units": "%",
                    hidden: true
                },
                height: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].height,
                    "default": 100,
                    "units": "%",
                    hidden: true
                },
                top: {
                    elem: "input",
                    type: "number",
                    label: "Top",
                    "default": 0,
                    "units": "%",
                    hidden: true
                },
                left: {
                    elem: "input",
                    type: "number",
                    label: "Left",
                    "default": 0,
                    "units": "%",
                    hidden: true
                },
                from: {
                    elem: "input",
                    type: "seconds",
                    "units": "seconds",
                    "label": lang[_curLang].startAt,
                    "default": 0
                },
                volume: {
                    elem: "input",
                    type: "range",
                    units: "%",
                    label: "Volume",
                    slider_unit: "%",
                    min: 0,
                    max: 1,
                    "default": 0.7
                },
                hidden: {
                    elem: "input",
                    type: "checkbox",
                    label: "Sound only",
                    "default": false
                },
                mute: {
                    elem: "input",
                    type: "checkbox",
                    label: "Mute",
                    "default": false
                },
                zindex: {
                    hidden: true,
                    "default": 0
                },
                duration: {
                    hidden: true,
                    "default": 0
                },
                type: {
                    hidden: true,
                    "default": "video"
                }
            }
        }
    });

})(TimelinePlayer);;/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="../MediaElement.js" />
/// <reference path="../NullMediaElement.js" />
/// <reference path="../VCPlayer.js" />
/// <reference path="../TimelinePlayer.js" />
(function (TimelinePlayer) {
    var DEFAULT_FONT_COLOR = "#ffffff",
    DEFAULT_SHADOW_COLOR = "#444444",
    DEFAULT_BACKGROUND_COLOR = "#888888";

    function newlineToBreak(string) {
        return string.replace(/\r?\n/gm, "<br>");
    }

    TimelinePlayer.plugin("PopcornTextPlugin", {
        _isMediaPlayer: function () {
            return false;
        },
        setup: function (udp) {

            var _manifest = TimelinePlayer.manifest.PopcornTextPlugin.options;

            var _target = this.timelinePlayer.element,
                _text = newlineToBreak(this.options.text),
                _container =  document.createElement("div"),
                _innerContainer = document.createElement("div"),
                _innerSpan = document.createElement("span"),
                _innerDiv = document.createElement("div"),
                _fontSheet,
                _fontDecorations = this.options.fontDecorations || _manifest.fontDecorations.default,
                _position = this.options.position || _manifest.position.default,
                _alignment = this.options.alignment || _manifest.alignment.default,
                _shadowColor = this.options.shadowColor || DEFAULT_SHADOW_COLOR,
                _backgroundColor = this.options.backgroundColor || DEFAULT_BACKGROUND_COLOR,
                _this = this;

            var _padding = "3",
                _width = 100 - (_padding * 2);

            _this._container = _container;
            if ("container" in _this) {

            } else {
                (function () {

                    Object.defineProperties(_this, {
                        container: {
                            get: function () {
                                return _this._container;
                            }
                        }
                    });
                })();
            }

            _container.style.position = "absolute";
            _container.classList.add("popcorn-text");

            // backwards comp
            if ("center left right".match(_position)) {
                _alignment = _position;
                _position = "middle";
            }

            _innerSpan.appendChild(_innerDiv);
            _innerContainer.appendChild(_innerSpan);
            _container.appendChild(_innerContainer);
            _target.appendChild(_container);

            _container.classList.add("off");


            _this.options.fontColor = _this.options.fontColor || DEFAULT_FONT_COLOR;
            _innerContainer.classList.add("text-inner-div");
            _innerContainer.style.color = _this.options.fontColor;
            _innerContainer.style.fontStyle = _fontDecorations.italics ? "italic" : "normal";
            _innerContainer.style.fontWeight = _fontDecorations.bold ? "bold" : "normal";

            if (_this.options.background) {
                _innerContainer.style.backgroundColor = _backgroundColor;
            }
            if (_this.options.shadow) {
                _innerContainer.style.textShadow = "0 1px 5px " + _shadowColor + ", 0 1px 10px " + _shadowColor;
            }

            _innerContainer.style.fontFamily = _this.options.fontFamily || _manifest.fontFamily.default;
            _innerContainer.style.fontSize = (_this.options.fontSize || _manifest.fontSize.default) + "%";
            _container.classList.add("text-custom");
            _innerContainer.classList.add("text-" + _alignment);
            if (_position === "top") {
                _container.style.left = _padding + "%";
                _container.style.width = _width + "%";
                _container.style.top = _padding + "%";
            } else if (_position === "bottom") {
                _container.style.left = _padding + "%";
                _container.style.width = _width + "%";
                _container.style.top = 100 - _padding - _this.options.fontSize + "%";
            } else if (_position === "middle") {
                _container.style.left = _padding + "%";
                _container.style.width = _width + "%";
                _container.style.top = 50 - (_this.options.fontSize / 2) + "%";
            } else if (_position === "custom") {
                _container.style.left = _this.options.left + "%";
                _container.style.top = _this.options.top + "%";
                if (_this.options.width) {
                    _container.style.width = _this.options.width + "%";
                }
            }
            _container.style.zIndex = +_this.zIndex;

            _innerDiv.innerHTML = _text;


            _this.toString = function () {
                return _this.options.text || _manifest.text.default;
            };
        },
        destory: function (b) {
            this.timelinePlayer.element.removeChild(this.container);
            if (!b) {
                this.eventListeners.length = 0;
            }
        },
        update: function (options, ctx) {
            util.merge(this.options, options);
            this.destory(false);
            this.setup(true);
            ctx.mustStart = true;
        },
        start: function () {
            this.container.classList.add("on");
            this.container.classList.remove("off");
        },
        end: function () {
            this.container.classList.add("off");
            this.container.classList.remove("on");
        },
        timeupdate:function(time){
        },
        manifest: {
            displayName: lang[_curLang].text,
            about: {},
            options: {
                text: {
                    elem: "textarea",
                    label: lang[_curLang].content,
                    "default": lang[_curLang].text
                },
                position: {
                    elem: "select",
                    options: [lang[_curLang].customize, lang[_curLang].center, lang[_curLang].bottom, lang[_curLang].top],
                    values: ["custom", "middle", "bottom", "top"],
                    label: lang[_curLang].textPosition,
                    "default": "bottom"
                },
                alignment: {
                    elem: "select",
                    options: [lang[_curLang].center, lang[_curLang].left, lang[_curLang].right],
                    values: ["center", "left", "right"],
                    label: lang[_curLang].alignment,
                    "default": "center"
                },
                start: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].start,
                    group: "advanced",
                    "units": lang[_curLang].second
                },
                end: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].finish,
                    group: "advanced",
                    "units": lang[_curLang].second
                },
                fontFamily: {
                    elem: "select",
                    label: lang[_curLang].font,
                    styleClass: "",
                    googleFonts: true,
                    group: "advanced",
                    "default": "Arial"
                },
                fontSize: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].fontSize,
                    "default": 10,
                    units: "%",
                    group: "advanced"
                },
                fontColor: {
                    elem: "input",
                    type: "color",
                    label: lang[_curLang].fontColor,
                    "default": DEFAULT_FONT_COLOR,
                    group: "advanced"
                },
                shadow: {
                    elem: "input",
                    type: "checkbox",
                    label: lang[_curLang].shadow,
                    "default": false,
                    group: "advanced"
                },
                shadowColor: {
                    elem: "input",
                    type: "color",
                    label: lang[_curLang].shadowColor,
                    "default": DEFAULT_SHADOW_COLOR,
                    group: "advanced"
                },
                background: {
                    elem: "input",
                    type: "checkbox",
                    label: lang[_curLang].background,
                    "default": false,
                    group: "advanced"
                },
                backgroundColor: {
                    elem: "input",
                    type: "color",
                    label: lang[_curLang].backgroundColor,
                    "default": DEFAULT_BACKGROUND_COLOR,
                    group: "advanced"
                },
                fontDecorations: {
                    elem: "checkbox-group",
                    labels: { bold: lang[_curLang].boldface, italics: lang[_curLang].italic },
                    "default": { bold: false, italics: false },
                    group: "advanced"
                },
                left: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].leftMargin,
                    units: "%",
                    "default": 25,
                    hidden: true
                },
                top: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].topMargin,
                    units: "%",
                    "default": 0,
                    hidden: true
                },
                width: {
                    elem: "input",
                    type: "number",
                    units: "%",
                    label: lang[_curLang].width,
                    "default": 50,
                    hidden: true
                },
                zindex: {
                    hidden: true
                }
            }
        }
    });

})(TimelinePlayer);;/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="../MediaElement.js" />
/// <reference path="../NullMediaElement.js" />
/// <reference path="../VCPlayer.js" />
/// <reference path="../TimelinePlayer.js" />
(function (TimelinePlayer) {

    var urlRegex = /[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/;


    function validateDimension(value, fallback) {
        if (typeof value === "number") {
            return value;
        }
        return fallback;
    }

    function createImageDiv(imageUrl, linkUrl, instance) {
        var imageDiv = document.createElement("img");
        imageDiv.src = imageUrl;
        imageDiv.classList.add("image-plugin-img");

        return imageDiv;
    }


    TimelinePlayer.plugin("PopcornImagePlugin", {
        _isMediaPlayer: function () {
            return false;
        },
        setup: function (upd) {
            var _manifest = TimelinePlayer.manifest.PopcornImagePlugin.options;

            var _target = this.timelinePlayer.element,
                _container,
                options = this.options,
                _image,
                _this = this;

            function setupImageDiv() {
                _container.appendChild(_link);
                _image = _container.querySelector(".image-plugin-img");
                _image.style.left = validateDimension(options.innerLeft, "0") + "%";
                _image.style.top = validateDimension(options.innerTop, "0") + "%";
                if (options.innerHeight) {
                    _image.style.height = validateDimension(options.innerHeight, "0") + "%";
                } else {
                    _image.style.height = 100 + '%';
                }
                if (options.innerWidth) {
                    _image.style.width = validateDimension(options.innerWidth, "0") + "%";
                } else {
                    _image.style.width = 100 + '%';
                }
                options.link = _link;
                options.image = _image;
            }

            _container = document.createElement("div");

            _container.classList.add("image-plugin-container");
            _container.style.width = validateDimension(options.width, "100") + "%";
            _container.style.height = validateDimension(options.height, "100") + "%";
            _container.style.top = validateDimension(options.top, "0") + "%";
            _container.style.left = validateDimension(options.left, "0") + "%";
            _container.style.zIndex = +this.zIndex;
            _container.style.position = 'absolute';
           // _container.classList.add(options.transition);
            _container.classList.add("off");

            if (_target) {

                _target.appendChild(_container);

                if (options.src) {

                    _link = createImageDiv(options.src, options.linkSrc, _this);
                    setupImageDiv();

                }


            }

            _this._container = _container;
            if ("container" in _this) {

            } else {
                (function () {

                    Object.defineProperties(_this, {
                        container: {
                            get: function () {
                                return _this._container;
                            }
                        }
                    });
                })();
            }


            _this.toString = function () {
                var _splitSource = [];
                if (options.title) {
                    return options.title;
                } else if (/^data:/.test(options.src)) {
                    // might ba a data URI
                    return options.src.substring(0, 30) + "...";
                } else if (options.src) {
                    _splitSource = options.src.split("/");
                    return _splitSource[_splitSource.length - 1];
                } else if (options.tags) {
                    return options.tags;
                } else if (options.photosetId) {
                    return options.photosetId;
                }

                return "Image Plugin";
            };

        },
        destory: function (b) {
            this.timelinePlayer.element.removeChild(this.container);
            if (!b) {
                this.eventListeners.length = 0;
            }
        },
        update: function (options,ctx) {
            util.merge(this.options, options);
            this.destory(false);
            this.setup(true);
            ctx.mustStart = true;
        },
        start: function () {
            this.container.classList.add("on");
            this.container.classList.remove("off");
        },
        end: function () {
            this.container.classList.add("off");
            this.container.classList.remove("on");
        },
        timeupdate:function(time){
        },
        manifest: {
            about: {

            },
            options: {
                src: {
                    elem: "input",
                    type: "url",
                    label: lang[_curLang].address,
                    "default": "",
                    hidden: true
                },
                width: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].width,
                    "default": 50,
                    "units": "%",
                    hidden: true
                },
                height: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].height,
                    "default": 50,
                    "units": "%",
                    hidden: true
                },
                top: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].topMargin,
                    "default": 0,
                    "units": "%",
                    hidden: true
                },
                left: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].leftMargin,
                    "default": 0,
                    "units": "%",
                    hidden: true
                },
                title: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].name,
                    readonly: true,
                    "default": ""

                },
                start: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].start,
                    units: lang[_curLang].second
                },
                end: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].finish,
                    units: lang[_curLang].second
                },
                zindex: {
                    hidden: true
                }
            }
        }
    });

})(TimelinePlayer);;/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="../MediaElement.js" />
/// <reference path="../NullMediaElement.js" />
/// <reference path="../VCPlayer.js" />
/// <reference path="../TimelinePlayer.js" />
(function (TimelinePlayer) {
    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
    function hexToRGB(sColor) {

        sColor = sColor.toLowerCase();
        if (sColor && reg.test(sColor)) {
            if (sColor.length === 4) {
                var sColorNew = "#";
                for (var i = 1; i < 4; i += 1) {
                    sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
                }
                sColor = sColorNew;
            }
            //处理六位的颜色值
            var sColorChange = [];
            for (var i = 1; i < 7; i += 2) {
                sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
            }
            return sColorChange;
        } else {
            return sColor;
        }

    }

    var effects = {
        GRAY: function (sourceContext, targetContext) {
            var w = sourceContext.canvas.width;
            var h = sourceContext.canvas.height;
            var sdataId = sourceContext.getImageData(0, 0, w, h);
            var sdata = sdataId.data;
            for( var i =0;i< sdata.length;i+=4){
                var c = Math.round( (sdata[i] + sdata[i+1] + sdata[i+2])/3);
                sdata[i] = c;
                sdata[i+1]=c;
                sdata[i+2]=c;
            }
            sourceContext.putImageData(sdataId, 0, 0);
        },
        INVERT: function (sourceContext, targetContext) {
            var w = sourceContext.canvas.width;
            var h = sourceContext.canvas.height;
            var sdataId = sourceContext.getImageData(0, 0, w, h);
            var sdata = sdataId.data;
            for (var i = 0; i < sdata.length; i += 4) {
                sdata[i] = 255 - sdata[i];
                sdata[i + 1] = 255 - sdata[i + 1];
                sdata[i + 2] = 255 - sdata[i + 2];
            }
            sourceContext.putImageData(sdataId, 0, 0);
        },
        COLOR: function (sourceContext, targetContext, color, merg) {
            color = hexToRGB(color);
            if (color.length != 3) {
                console.error(lang[_curLang].colorValueError);
                return;
            }
            var w = sourceContext.canvas.width;
            var h = sourceContext.canvas.height;
            var sdataId = sourceContext.getImageData(0, 0, w, h);
            var sdata = sdataId.data;
            if (merg == "add") {
                for (var idx = 0; idx < sdata.length; idx += 4) {
                    sdata[idx] = Math.min(255, sdata[idx] + color[0]);
                    sdata[idx + 1] = Math.min(255, sdata[idx + 1] + color[ 1]);
                    sdata[idx + 2] = Math.min(255, sdata[idx + 2] + color[2]);
                }
            } else if (merg == "substract") {
                for (var idx = 0; idx < sdata.length; idx += 4) {
                    sdata[idx] = Math.max(0, sdata[idx] - color[0]);
                    sdata[idx + 1] = Math.max(0, sdata[idx + 1] - color[1]);
                    sdata[idx + 2] = Math.max(0, sdata[idx + 2] - color[2]);
                }
            }
            else if (merg == "mutiple") {
                for (var idx = 0; idx < sdata.length; idx += 4) {
                    sdata[idx] = Math.min(255, (sdata[idx] * color[0]) / 255);
                    sdata[idx + 1] = Math.min(255, (sdata[idx + 1] * color[1]) / 255);
                    sdata[idx + 2] = Math.min(255, (sdata[idx + 2] * color[2]) / 255);
                }
            } else if (merg == "normal") {
                for (var idx = 0; idx < sdata.length; idx += 4) {
                    sdata[idx] = color[0];
                    sdata[idx + 1] = color[1];
                    sdata[idx + 2] = color[2];
                }
            }
            sourceContext.putImageData(sdataId, 0, 0);
        }
    };

    TimelinePlayer.plugin("PopcornEffectPlugin", {
        _isMediaPlayer: function () {
            return false;
        },
        setup: function (udp) {

            var _this = this;

            var _canvas = null;
            var _context = null;

            var _container = document.createElement("div");

            Object.defineProperties(_this, {
                container: {
                    get: function () {
                        return _container;
                    }
                }
            });

            var rect = this.timelinePlayer.element.getBoundingClientRect();
            if (rect.width > 0 && rect.height > 0) {
                _canvas = document.createElement("canvas");
                _canvas.width = rect.width;
                _canvas.height = rect.height;
                _context = _canvas.getContext("2d");


                //var g = _context.createLinearGradient(0, 0, _canvas.width, 0);
                //g.addColorStop(0, "black");
                //g.addColorStop(1, "white");

                _context.save();
                _context.fillStyle = "red";
                _context.rect(0, 0, _canvas.width, _canvas.height);
                _context.fill();
                _context.restore();
            }

            Object.defineProperties(_this, {

                canvasContext: {
                    get: function () {
                        return _context;
                    }
                }
            });

            _this.toString = function () {
                return _this.options.title || _this.options.effectType;
            };
        },
        destory: function (b) {
        },
        update: function (options) {

        },
        start: function () {
        },
        end: function () {
        },
        timeupdate:function(time){
        },
        draw: function (context) {

            var et = this.options.effectType.toUpperCase();
            if (effects[et]) {
                effects[et](context, null, this.options.color, this.options.merg);
            }


        },
        manifest: {
            displayName: 'Effect',
            about: {},
            options: {
                effectType: {
                    hidden:true
                },
                start: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].start,
                    group: "advanced",
                    "units": lang[_curLang].second
                },
                end: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].finish,
                    group: "advanced",
                    "units": lang[_curLang].second
                },
                color: {
                    elem: "input",
                    type: "color",
                    label: lang[_curLang].color,
                    "default": '#4390e8',
                },
                merg: {
                    elem: "select",
                    options: [lang[_curLang].sum, lang[_curLang].subtract, lang[_curLang].multiply, lang[_curLang].normal],
                    values: ["add", "substract", "mutiple","normal"],
                    label: lang[_curLang].renderMethod,
                    "default": "mutiple"
                },
                left: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].leftMargin,
                    units: "%",
                    "default": 25,
                    hidden: true
                },
                top: {
                    elem: "input",
                    type: "number",
                    label: lang[_curLang].topMargin,
                    units: "%",
                    "default": 0,
                    hidden: true
                },
                width: {
                    elem: "input",
                    type: "number",
                    units: "%",
                    label: lang[_curLang].width,
                    "default": 50,
                    hidden: true
                },
                zindex: {
                    hidden: true
                }
            }
        }
    });

})(TimelinePlayer);;/// <reference path="base/util.js" />
/// <reference path="base/Class.js" />
/// <reference path="base/EventObject.js" />
/// <reference path="base/MediaUtils.js" />
/// <reference path="base/logger.js" />
/// <reference path="../MediaElement.js" />
/// <reference path="../NullMediaElement.js" />
/// <reference path="../VCPlayer.js" />
/// <reference path="../TimelinePlayer.js" />
(function (TimelinePlayer) {
    var transitionManifest = {};
    var transitionPlugin = {};
    TimelinePlayer.plugin("PopcornTransitionPlugin", {
        _isMediaPlayer: function () {
            return false;
        },
        _registerTransition: function (name, plugin) {
            transitionPlugin[name] = plugin;
            if (plugin.manifest) {
                var p ={};
                p[name] = {writable:false};
                p[name].value = util.createReadonlyObject( plugin.manifest);

                Object.defineProperties(TimelinePlayer.manifest.transitionManifest, p);
            }
        },
        _getManifest: function (name) {
            return TimelinePlayer.manifest.transitionManifest[name];
        },
        _getPlugin: function (name) {
            return transitionPlugin[name];
        },
        setup: function (udp) {

            var _this = this;

            var _canvas = null;
            var _context = null;

            var _container = document.createElement("div");

            Object.defineProperties(_this, {
                container: {
                    get: function () {
                        return _container;
                    }
                }
            });



            _this.toString = function () {
                var t = _this.options.title;
                if (!t) {
                    var p = transitionPlugin[_this.options.transition];
                    if (p && p.manifest) {
                        t = p.manifest.displayName;
                    }
                }
                return t;
            };
        },
        destory: function (b) {
        },
        update: function (options) {

        },
        start: function () {
        },
        end: function () {
        },
        timeupdate: function (time) {
        },
        draw: function (context, time, video, trackGroup) {
            var plugin = transitionPlugin[this.options.transition];
            if (plugin && plugin.draw) {
                plugin.draw(context, time, video, trackGroup, this);
            }

        },
        manifest: {
            displayName: lang[_curLang].transition,
            about: {},
            options: {
                transition: {
                    hidden: true
                },
                start: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].start,
                    group: "advanced",
                    "units": lang[_curLang].second
                },
                end: {
                    elem: "input",
                    type: "text",
                    label: lang[_curLang].finish,
                    group: "advanced",
                    "units": lang[_curLang].second
                },
                zindex: {
                    hidden: true
                }
            }
        }
    }, function (timelinePlayer) {
        //回调，注册转场动画需要的常量
        transitionManifest = { writable: false };
        transitionManifest.value = util.createReadonlyObject({
            ALIGN_CENTER: 1, //居中不重叠
            ALIGN_OVERLAP: 2, //居中重叠
            ALIGN_LEFT: 4, //左对齐
            ALIGN_RIGHT: 8 //右对齐
        });

        Object.defineProperties(timelinePlayer.manifest, {
            transitionManifest: transitionManifest
        });
    });

})(TimelinePlayer);
})(window);;/*! jQuery v2.1.4 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.4",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b="length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N=M.replace("w","w#"),O="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+N+"))|)"+L+"*\\]",P=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+O+")*)|.*)\\)|)",Q=new RegExp(L+"+","g"),R=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),S=new RegExp("^"+L+"*,"+L+"*"),T=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),U=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),V=new RegExp(P),W=new RegExp("^"+N+"$"),X={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+O),PSEUDO:new RegExp("^"+P),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,aa=/[+~]/,ba=/'|\\/g,ca=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),da=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ea=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(fa){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],k=b.nodeType,"string"!=typeof a||!a||1!==k&&9!==k&&11!==k)return d;if(!e&&p){if(11!==k&&(f=_.exec(a)))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return H.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName)return H.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=1!==k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(ba,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+ra(o[l]);w=aa.test(a)&&pa(b.parentNode)||b,x=o.join(",")}if(x)try{return H.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function pa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=g.documentElement,e=g.defaultView,e&&e!==e.top&&(e.addEventListener?e.addEventListener("unload",ea,!1):e.attachEvent&&e.attachEvent("onunload",ea)),p=!f(g),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(g.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(g.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!g.getElementsByName||!g.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ca,da);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(g.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\f]' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){var b=g.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",P)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===g||a.ownerDocument===v&&t(v,a)?-1:b===g||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,h=[a],i=[b];if(!e||!f)return a===g?-1:b===g?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?la(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},g):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ca,da),a[3]=(a[3]||a[4]||a[5]||"").replace(ca,da),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ca,da).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(Q," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(ca,da),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return W.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(ca,da).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:oa(function(){return[0]}),last:oa(function(a,b){return[b-1]}),eq:oa(function(a,b,c){return[0>c?c+b:c]}),even:oa(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:oa(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:oa(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:oa(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function qa(){}qa.prototype=d.filters=d.pseudos,d.setFilters=new qa,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function ra(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function sa(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function ta(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ua(a,b,c){for(var d=0,e=b.length;e>d;d++)ga(a,b[d],c);return c}function va(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function wa(a,b,c,d,e,f){return d&&!d[u]&&(d=wa(d)),e&&!e[u]&&(e=wa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ua(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:va(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=va(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=va(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function xa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=sa(function(a){return a===b},h,!0),l=sa(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[sa(ta(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return wa(i>1&&ta(m),i>1&&ra(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&xa(a.slice(i,e)),f>e&&xa(a=a.slice(e)),f>e&&ra(a))}m.push(c)}return ta(m)}function ya(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=F.call(i));s=va(s)}H.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&ga.uniqueSort(i)}return k&&(w=v,j=t),r};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=xa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,ya(e,d)),f.selector=a}return f},i=ga.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ca,da),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ca,da),aa.test(j[0].type)&&pa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&ra(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,aa.test(a)&&pa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+K.uid++}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){
return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,ba=/<([\w:]+)/,ca=/<|&#?\w+;/,da=/<(?:script|style|link)/i,ea=/checked\s*(?:[^=]|=\s*.checked.)/i,fa=/^$|\/(?:java|ecma)script/i,ga=/^true\/(.*)/,ha=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ia={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ia.optgroup=ia.option,ia.tbody=ia.tfoot=ia.colgroup=ia.caption=ia.thead,ia.th=ia.td;function ja(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function ka(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function la(a){var b=ga.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function ma(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function na(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function oa(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pa(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=oa(h),f=oa(a),d=0,e=f.length;e>d;d++)pa(f[d],g[d]);if(b)if(c)for(f=f||oa(a),g=g||oa(h),d=0,e=f.length;e>d;d++)na(f[d],g[d]);else na(a,h);return g=oa(h,"script"),g.length>0&&ma(g,!i&&oa(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(ca.test(e)){f=f||k.appendChild(b.createElement("div")),g=(ba.exec(e)||["",""])[1].toLowerCase(),h=ia[g]||ia._default,f.innerHTML=h[1]+e.replace(aa,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=oa(k.appendChild(e),"script"),i&&ma(f),c)){j=0;while(e=f[j++])fa.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=ja(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(oa(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&ma(oa(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(oa(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!da.test(a)&&!ia[(ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(aa,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(oa(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(oa(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&ea.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(oa(c,"script"),ka),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,oa(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,la),j=0;g>j;j++)h=f[j],fa.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(ha,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qa,ra={};function sa(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function ta(a){var b=l,c=ra[a];return c||(c=sa(a,b),"none"!==c&&c||(qa=(qa||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qa[0].contentDocument,b.write(),b.close(),c=sa(a,b),qa.detach()),ra[a]=c),c}var ua=/^margin/,va=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wa=function(b){return b.ownerDocument.defaultView.opener?b.ownerDocument.defaultView.getComputedStyle(b,null):a.getComputedStyle(b,null)};function xa(a,b,c){var d,e,f,g,h=a.style;return c=c||wa(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),va.test(g)&&ua.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function ya(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),f.removeChild(c),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var za=/^(none|table(?!-c[ea]).+)/,Aa=new RegExp("^("+Q+")(.*)$","i"),Ba=new RegExp("^([+-])=("+Q+")","i"),Ca={position:"absolute",visibility:"hidden",display:"block"},Da={letterSpacing:"0",fontWeight:"400"},Ea=["Webkit","O","Moz","ms"];function Fa(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Ea.length;while(e--)if(b=Ea[e]+c,b in a)return b;return d}function Ga(a,b,c){var d=Aa.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Ha(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ia(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wa(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xa(a,b,f),(0>e||null==e)&&(e=a.style[b]),va.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Ha(a,b,c||(g?"border":"content"),d,f)+"px"}function Ja(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",ta(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xa(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fa(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Ba.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fa(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xa(a,b,d)),"normal"===e&&b in Da&&(e=Da[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?za.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Ca,function(){return Ia(a,b,d)}):Ia(a,b,d):void 0},set:function(a,c,d){var e=d&&wa(a);return Ga(a,c,d?Ha(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=ya(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xa,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ua.test(a)||(n.cssHooks[a+b].set=Ga)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wa(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Ja(this,!0)},hide:function(){return Ja(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Ka(a,b,c,d,e){return new Ka.prototype.init(a,b,c,d,e)}n.Tween=Ka,Ka.prototype={constructor:Ka,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Ka.propHooks[this.prop];return a&&a.get?a.get(this):Ka.propHooks._default.get(this)},run:function(a){var b,c=Ka.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Ka.propHooks._default.set(this),this}},Ka.prototype.init.prototype=Ka.prototype,Ka.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Ka.propHooks.scrollTop=Ka.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Ka.prototype.init,n.fx.step={};var La,Ma,Na=/^(?:toggle|show|hide)$/,Oa=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pa=/queueHooks$/,Qa=[Va],Ra={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Oa.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Oa.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sa(){return setTimeout(function(){La=void 0}),La=n.now()}function Ta(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ua(a,b,c){for(var d,e=(Ra[b]||[]).concat(Ra["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Va(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||ta(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Na.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?ta(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ua(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wa(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xa(a,b,c){var d,e,f=0,g=Qa.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=La||Sa(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:La||Sa(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wa(k,j.opts.specialEasing);g>f;f++)if(d=Qa[f].call(j,a,k,j.opts))return d;return n.map(k,Ua,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xa,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Ra[c]=Ra[c]||[],Ra[c].unshift(b)},prefilter:function(a,b){b?Qa.unshift(a):Qa.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xa(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pa.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Ta(b,!0),a,d,e)}}),n.each({slideDown:Ta("show"),slideUp:Ta("hide"),slideToggle:Ta("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(La=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),La=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Ma||(Ma=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Ma),Ma=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Ya,Za,$a=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Za:Ya)),
void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Za={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$a[b]||n.find.attr;$a[b]=function(a,b,d){var e,f;return d||(f=$a[b],$a[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$a[b]=f),e}});var _a=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_a.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ab=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ab," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ab," ").indexOf(b)>=0)return!0;return!1}});var bb=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cb=n.now(),db=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var eb=/#.*$/,fb=/([?&])_=[^&]*/,gb=/^(.*?):[ \t]*([^\r\n]*)$/gm,hb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,ib=/^(?:GET|HEAD)$/,jb=/^\/\//,kb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,lb={},mb={},nb="*/".concat("*"),ob=a.location.href,pb=kb.exec(ob.toLowerCase())||[];function qb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function rb(a,b,c,d){var e={},f=a===mb;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function sb(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function tb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function ub(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:ob,type:"GET",isLocal:hb.test(pb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":nb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?sb(sb(a,n.ajaxSettings),b):sb(n.ajaxSettings,a)},ajaxPrefilter:qb(lb),ajaxTransport:qb(mb),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=gb.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||ob)+"").replace(eb,"").replace(jb,pb[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=kb.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===pb[1]&&h[2]===pb[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(pb[3]||("http:"===pb[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),rb(lb,k,b,v),2===t)return v;i=n.event&&k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!ib.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(db.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=fb.test(d)?d.replace(fb,"$1_="+cb++):d+(db.test(d)?"&":"?")+"_="+cb++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+nb+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=rb(mb,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=tb(k,v,f)),u=ub(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var vb=/%20/g,wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&").replace(vb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Bb=0,Cb={},Db={0:200,1223:204},Eb=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in Cb)Cb[a]()}),k.cors=!!Eb&&"withCredentials"in Eb,k.ajax=Eb=!!Eb,n.ajaxTransport(function(a){var b;return k.cors||Eb&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Bb;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Cb[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Db[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Cb[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Fb=[],Gb=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Fb.pop()||n.expando+"_"+cb++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Gb.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Gb.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Gb,"$1"+e):b.jsonp!==!1&&(b.url+=(db.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Fb.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Hb=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Hb)return Hb.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Ib=a.document.documentElement;function Jb(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Jb(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Ib;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Ib})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Jb(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=ya(k.pixelPosition,function(a,c){return c?(c=xa(a,b),va.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,'function' === typeof h5.define && h5.define.amd&&h5.define("jquery",[],function(){return n});var Kb=a.jQuery,Lb=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Lb),b&&a.jQuery===n&&(a.jQuery=Kb),n},typeof b===U&&(a.jQuery=a.$=n),n});

/*
 * 实现继承的基类
 */
h5.define("util/Class", [], function () {
    var initializing = false;
    var functionTest = /xyz/.test(function () { xyz; }) ? /\b_super\b/ : /.*/;

    var Class = function () { };

    Class.extend = function (properties) {
        var _super = this.prototype;

        initializing = true;
        var prototype = new this();
        initializing = false;

        for (var name in properties) {
            prototype[name] = typeof properties[name] == "function" &&
			typeof _super[name] == "function" && functionTest.test(properties[name]) ?
			(function (name, fun) {
			    return function () {
			        var tmp = this._super;

			        this._super = _super[name];
			        var ret = fun.apply(this, arguments);
			        this._super = tmp;

			        return ret;
			    };
			})(name, properties[name]) :
			properties[name];
        }

        function Class() {
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        Class.prototype = prototype;

        Class.constructor = Class;

        Class.extend = arguments.callee;

        return Class;
    };

    return Class;
});


h5.define("util/util", [], function () {

    var DEFAULT_TRANSITION_TIMEOUT = 15;

    var TRANSFORM_PROPERTY = (function () {
        var div = document.createElement("div");
        var choices = "Webkit Moz O ms".split(" ").map(function (prefix) { return prefix + "Transform"; });

        for (var i = choices.length; i >= 0; --i) {
            if (div.style[choices[i]] !== undefined) {
                return choices[i];
            }
        }

        return "transform";
    }());


    var util = {
        frameRate: 25,
        formatTimeString: function (totalMs) {


            var dateTime = new Date(0, 0, 0, 0, 0, 0, 0);
            dateTime.setMilliseconds(totalMs);

            var str = "";
            var h = dateTime.getHours();
            if (h > 0) {

                var hours = util.padString(dateTime.getHours(), 1, "0");
                str = hours + ":";
            }
            var minutes = util.padString(dateTime.getMinutes(), 2, "0");
            var seconds = util.padString(dateTime.getSeconds(), 2, "0");
            var ms = util.padString(dateTime.getMilliseconds(), 3, "0");

            return str + minutes + ":" + seconds + "." + ms;
        },
        toSmpteString: function (time, frameRate) {
            frameRate = frameRate || util.frameRate || 24;

            var lz = false;
            if (time < 0) {
                time = -time;
                lz = true;
            }

            var dateTime = new Date(0, 0, 0, 0, 0, 0, 0);
            dateTime.setMilliseconds(time);

            var str = "";
            var h = dateTime.getHours();
            if (h > 0) {

                var hours = util.padString(dateTime.getHours(), 1, "0");
                str = hours + ":";
            }
            var minutes = util.padString(dateTime.getMinutes(), 2, "0");
            var seconds = dateTime.getSeconds();
            var ms = dateTime.getMilliseconds();

            var f = Math.round((ms / 1000) * frameRate);

            if (f == frameRate) {
                seconds += 1;
                f = 0;
            }
            seconds = util.padString(seconds, 2, "0");

            return str + minutes + ":" + seconds + "." + util.padString(f, 2, "0");

        },

        toSeconds: function (timeStr, frameRate) {
            var validTimeFormat = /^([0-9]+:){0,2}[0-9]+([.;][0-9]+)?$/,
                errorMessage = lang[_curLang].wrongTimeFormat,
                digitPairs, lastIndex, lastPair, firstPair,
                frameInfo, frameTime,
                frameRate = frameRate || util.frameRate || 24;

            if ( typeof timeStr === "number" ) {
                return timeStr;
            }

            if ( typeof timeStr === "string" &&
                  !validTimeFormat.test( timeStr ) ) {
                throw new Error(errorMessage + ":" + timeStr);
            }

            digitPairs = timeStr.split( ":" );
            lastIndex = digitPairs.length - 1;
            lastPair = digitPairs[ lastIndex ];

            // Fix last element:
            if ( lastPair.indexOf( "." ) > -1 ) {

                frameInfo = lastPair.split( "." );
                frameTime = 0;

                if (frameRate && (typeof frameRate === "number")) {
                    frameTime = parseFloat(frameInfo[1], 10) / frameRate;
                }

                digitPairs[ lastIndex ] = parseInt( frameInfo[ 0 ], 10 ) + frameTime;
            }

            firstPair = digitPairs[ 0 ];

            return {

                1: parseFloat( firstPair, 10 ),

                2: ( parseInt( firstPair, 10 ) * 60 ) +
                      parseFloat( digitPairs[ 1 ], 10 ),

                3: ( parseInt( firstPair, 10 ) * 3600 ) +
                    ( parseInt( digitPairs[ 1 ], 10 ) * 60 ) +
                      parseFloat( digitPairs[ 2 ], 10 )

            }[ digitPairs.length || 1 ];
        },

        roundTime: function (seconds, frameRate) {

            if (typeof seconds === "string") {
                seconds = util.toSeconds(seconds, frameRate);
            }


            //秒帧对齐
            frameRate = frameRate || util.frameRate || 24;

            var ns = Math.round(1000000 * 10 * seconds);

            //等于多少帧
            var f = Math.round((ns / (1000000 * 10)) * frameRate);

            var s = f / frameRate;

            s = Math.round(s * 100000) / 100000;
            return s;
        },
        secondsToFrame: function (s, frameRate) {
            frameRate = frameRate || util.frameRate || 24;
            var ns = Math.round(1000000 * 10 * s);

            //等于多少帧
            var f = Math.round((ns / (1000000 * 10)) * frameRate);

            return f;
        },

        padString: function (value, padLength, padString) {


            var result = new String(value);

            while (result.length < padLength)
                result = padString + result;

            return result;
        },
        merge: function (destination, source) {

            if (!source)
                return;

            for (var i in source) {
                var destinationProperty = destination[i];
                var sourceProperty = source[i];

                if (sourceProperty == null)
                    delete destination[i];
                else if (typeof (destinationProperty) == "object"
                        && typeof (sourceProperty) == "object"
                        && !(destinationProperty instanceof Array))
                    util.merge(destinationProperty, sourceProperty);
                else
                    destination[i] = sourceProperty;
            }
        },
        proxy: function (context, fun) {
            var proxy = function () {
                return fun.apply(context, arguments);
            };
            proxy.source = fun;
            return proxy;
        },
        addEvent: function (obj, type, fun) {

            // 支持IE10的触控事件
            if (window.navigator.msPointerEnabled) {
                switch (type) {
                    case "mousemove":
                        obj.addEventListener("MSPointerMove", fun, false);
                        break;

                    case "mouseup":
                        obj.addEventListener("MSPointerUp", fun, false);
                        break;

                    case "mousedown":
                        obj.addEventListener("MSPointerDown", fun, false);
                        break;

                    case "mouseover":
                        obj.addEventListener("MSPointerOver", fun, false);
                        break;

                    case "mouseout":
                        window.addEventListener("MSPointerOver", function (e) {
                            if (e.srcElement != obj)
                                fun(e);
                        }, true);

                        break;

                    default:
                        obj.addEventListener(type, fun, false);
                        break;
                }
            }
            else if (obj.addEventListener) {
                obj.addEventListener(type, fun, false);
            }
            else if (obj.attachEvent) {
                obj["e" + type + fun] = fun;
                obj[type + fun] = function () { obj["e" + type + fun](window.event); }
                obj.attachEvent("on" + type, obj[type + fun]);
            }
        },
        removeEvent: function (obj, type, fun) {
            if (obj.removeEventListener) {
                obj.removeEventListener(type, fun, false);
            }
            else if (obj.detachEvent) {
                obj.detachEvent("on" + type, obj[type + fun]);
                obj[type + fun] = null;
                obj["e" + type + fun] = null;
            }
        },
        first: function (array, condition) {
            if (!array || array.length == 0) {
                return null;
            }

            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                if (condition(item, i)) {
                    return item;
                }
            }

        },
        forEach: function (array, fun /*, thisp */) {


            "use strict";

            if (array === void 0 || array === null)
                throw new TypeError();

            var t = Object(array);
            var len = t.length >>> 0;
            if (typeof fun !== "function")
                throw new TypeError();

            var thisp = arguments[2];
            for (var i = 0; i < len; i++) {
                if (i in t)
                    fun.call(thisp, t[i], i, t);
            }
        },
        cloneArray: function (array) {
            var a = [];
            if (array && array.length) {
                for (var i = 0; i < array.length; i++) {
                    a.push(array[i]);
                }
            }
            return a;
        },
        applyTransitionEndListener: (function () {
            var div = document.createElement("div"),
                p,
                pre = ["OTransition", "webkitTransition", "MozTransition", "transition"];
            for (p in pre) {
                if (div.style[pre[p]] !== undefined) {
                    return function (element, listener) {
                        element.addEventListener("transitionend", listener);
                        element.addEventListener("oTransitionEnd", listener);
                        element.addEventListener("webkitTransitionEnd", listener);
                    };
                }
            }
            return function (element, listener) {

                var currentTimeout = element.getAttribute("data-transition-end");
                if (typeof currentTimeout === "string" && currentTimeout !== "") {
                    clearTimeout(currentTimeout | 0);
                }

                currentTimeout = setTimeout(function () {
                    element.removeAttribute("data-transition-end");
                    listener.apply(this, arguments);
                }, DEFAULT_TRANSITION_TIMEOUT);

                element.setAttribute("data-transition-end", currentTimeout);
            };
        }()),

        removeTransitionEndListener: function (element, listener) {
            element.removeEventListener("transitionend", listener, false);
            element.removeEventListener("oTransitionEnd", listener, false);
            element.removeEventListener("webkitTransitionEnd", listener, false);
        },
        setTransformProperty: function (element, transform) {
            element.style[TRANSFORM_PROPERTY] = transform;
        },

        getTransformProperty: function (element) {
            return element.style[TRANSFORM_PROPERTY];
        },
        clone: function (obj) {
            var newObj = {};
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    newObj[prop] = obj[prop];
                }
            }
            return newObj;
        },
        deepClone : function(obj, removeElement) {
            var isArray = function(obj) {
                return Object.prototype.toString.call(obj) === "[object Array]";
            };
            var isObj = function(obj) {
                return Object.prototype.toString.call(obj) === "[object Object]";
            };
            var objC = isArray(obj) ? [] : {};
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    if (isObj(obj[prop]) || isArray(obj[prop])) {
                        if (removeElement && obj[prop] instanceof HTMLElement) {
                            continue;
                        } else {
                            objC[prop] = util.deepClone(obj[prop], removeElement);
                        }
                    } else if (removeElement && obj[prop] instanceof HTMLElement) {
                    }
                    else {
                        objC[prop] = obj[prop];
                    }
                }
            }
            return objC;
        },
        domFragment: function (inputString) {
            var range = document.createRange(),
                container = document.body || document.head,
                fragment,
                child;

            range.selectNode(container);
            fragment = range.createContextualFragment(inputString);

            return fragment;
        },
    }


    Array.prototype.indexOf = Array.prototype.indexOf || function (obj) {
        var idx = -1;
        for (var i = 0; i < this.length; i++) {
            if (this[i] === obj) {
                idx = i;
                break;
            }
        }
        return idx;
    };

    return util;
});
/*
 * 对象，实现了事件监听借口
 */
h5.define("util/Object", ["util/Class", "util/util"], function (Class, util) {

    //事件对象
    function H5Event(type, target, data) {
        var _propagationStopped = false;

        Object.defineProperties(this, {
            type: {
                value: type
            },
            target: {
                value: target
            },
            data: {
                value: data
            },
            propagationStopped: {
                get: function () {
                    return _propagationStopped;
                }
            }
        });


        this.stopPropagation = function () {
            _propagationStopped = true;
        };

        this.clone = function () {
            return new H5Event(type, target, data);
        };
    }





    var EventObject = Class.extend({

        init: function (options) {

            this.options = options || {};
            this.eventListeners = [];
        },

        addEventListener: function (type, callback, capture, instance) {

            this.eventListeners.push(
            {
                type: type,
                callback: callback,
                capture: capture,
                instance: instance
            });
        },
        removeEventListener: function (type, callback) {
            var e = [];
            util.forEach(this.eventListeners, function (l) {
                if (l.type === type && (l.callback === callback || l.callback.source === callback)) {
                    e.push(l);
                }
            });
            var es = this.eventListeners;
            util.forEach(e, function (l) {
                var a = es.indexOf(l);
                if (a >= 0) {
                    es.splice(a, 1);
                }
            });
        },

        dispatchEvent: function (eventName, eventObject) {
            var e = eventName;
            var name = eventName;
            if (e instanceof H5Event) {
                name = e.type;
            } else {
                e = new H5Event(eventName, this, eventObject);
            }

            util.forEach(this.eventListeners, function (l) {
                if (l.type === name) {

                    if (l.instance) {
                        l.callback.call(l.instance, e);
                    } else {
                        l.callback(e);
                    }
                }
            });
        },
        //将b的事件传递给次对象
        chain: function(b, events) {


            var i = events.length;
            while (i--) {
                b.addEventListener(events[i], this.dispatchEvent, false, this);
            }
        },
        unchain : function(b, events) {

            var i = events.length;
            while (i--) {
                b.removeEventListener(events[i], this.dispatchEvent);
            }
        },
        mergeOptions: function (userOptions, defaultOptions) {

            util.merge(this.options, defaultOptions);
            util.merge(this.options, userOptions);
        }
    });

    return EventObject;
});
h5.define('templates/H5EditorLayout', [], function () {
    return '<div class="h5editor ani" data-butter-content-state="timeline">\
    <div class="loading-container" dir="ltr"></div>\
    <div class="status-area" dir="ltr"></div>\
    <div class="resize-handle" dir="ltr"></div>\
    <div class="tracks-area" dir="ltr"></div>\
    <div class="toggle-button" dir="ltr">\
        <div class="image-container" dir="ltr"></div>\
    </div>\
</div>';
});
/*
 * 上下高度调节控件
 */
h5.define('util/H5ResizeHandler', [], function () {

    return function (options) {
        options = options || {};
        var _this = this;

        var firstElement = $(options.firstElement);
        var handlerElement = $(options.handlerElement);
        var handlerCssName = options.handlerCss || 'resize-handle';
        var minHeight = options.minHeight || 0,
            initHeight = options.initHeight || 200,
            resizeCallback = options.resize || function () { };

            this.minimized = options.minimized || false;

        var dragHandler = handlerElement.find('.' + handlerCssName);

        function onTrayHandleMousedown(e) {
            e.preventDefault();
            e.stopPropagation();
            handlerElement.removeClass("ani");
            dragHandler.off("mousedown", onTrayHandleMousedown);
            window.addEventListener("mousemove", onTrayHandleMousemove);
            window.addEventListener("mouseup", onTrayHandleMouseup);
            // document.querySelector(".hoverifm").style.display = "block";
        }
        function onTrayHandleMousemove(e) {
            if (e.pageY < 577)
            {
                return;
            }
            var height = window.innerHeight - e.pageY;
            // 如果小于最小高度，最小化
            if (height <= minHeight) {
                _this.minimize(true);
                return;
            } else if (this.minimized) {
                _this.minimize(false);
            } else if (e.pageY < 400) {
                return;
            }

            var offsetTop = firstElement.offset().top;
            if (e.pageY < offsetTop) {
                height = window.innerHeight - offsetTop;
            }
            handlerElement.height(height);
            firstElement.css({ bottom: height + 'px' });
            // trayRoot.style.height = height + "px";
            //top.style.bottom = height + "px";
            resizeCallback();
            // butter.timeline.media.verticalResize();
        }
        function onTrayHandleMouseup(e) {
            e.preventDefault();
            e.stopPropagation();
            var height = window.innerHeight - e.pageY;

            var offsetTop = firstElement.offset().top;
            if (e.pageY < offsetTop) {
                height = window.innerHeight - offsetTop;
            }
            if (height > minHeight) {
                initHeight = height;
            }
            handlerElement.addClass("ani");
            dragHandler.on("mousedown", onTrayHandleMousedown);
            window.removeEventListener("mousemove", onTrayHandleMousemove, false);
            window.removeEventListener("mouseup", onTrayHandleMouseup, false);
            // document.querySelector(".hoverifm").style.display = "none";
        }

        dragHandler.on("mousedown", onTrayHandleMousedown);


        this.minimize = function(state) {
           // _toggler.state = state;
            minimized = state;
            if (state) {
                // document.body.classList.add("tray-minimized");
                handlerElement.height(minHeight);
                firstElement.css({ bottom: minHeight + 'px' });
                //stageWrapper.style.bottom = minHeight + "px";
            } else {
                //  document.body.classList.remove("tray-minimized");
                handlerElement.height(initHeight);
                //stageWrapper.style.bottom = trayHeight + "px";
                firstElement.css({ bottom: initHeight + 'px' });
            }
        }

        if (this.minimized) {
            this.minimize(this.minimized);
        }

        //this.resize = function () {
            //wrapper.style.width = (container.clientWidth - borderOffset - marginOffset) + "px";
           // wrapper.style.margin = margin + "px " + margin + "px";
            // If the current screen size does not fit the aspect ratios height,
            // we need to shrink the height to fit, thus shrink the width.
            //if (container.clientHeight < wrapper.offsetHeight + marginOffset) {
            //    wrapper.style.margin = margin + "px auto";
            //    wrapper.style.width = (16 / 9 * (container.clientHeight - borderOffset - marginOffset)) + "px";
            //}

            //video.style.fontSize = (baseFontSize * (video.offsetWidth / baseVideoWidth)) + "px";
        //};

        //var video = document.querySelector(".video-container"),
        //    wrapper = document.querySelector(".wrapper"),
        //    container = options.topElement,
        //    margin = options.margin || 0,
        //    border = options.border || 0,
        //    marginOffset = margin * 2,
        //    borderOffset = border * 2,
        //    baseFontSize = 14,
        //    baseVideoWidth = 560;

        // This means we're not in the editor...
        //if (!wrapper) {
        //    wrapper = video;
        //}


    };
});

/*
 * 上下高度调节控件
 */
h5.define('util/H5HorizontalResizer', ["util/Object"], function (Obj) {


    var ResizeHelper = Obj.extend({
        init: function (options) {
            options = options || {};
            var _this = this;

            _this._super();

            var firstElement = $(options.firstElement);  //左侧
            var handlerElement = $(options.handlerElement); //右侧
            var handlerCssName = options.handlerCss || 'video-panel-resize';
            var isLeft = false,
                parent = handlerElement.parent();

            if (parent.length === 0) {
                parent = $(window);
            }

            if (handlerElement.offset().left < firstElement.offset().left) {
                isLeft = true;
            }

            var minWidth = 450,
                initWidth = 450,
                maxWidth = 0,
                startPosition,
                oWidth = 0,
                curWidth = 0,
                resizeCallback = options.resize || function () { };

            function hasOption(name) {
                if (typeof options[name] === "undefined") {
                    return false;
                }
                return true;
            }

            var minimized = options.minimized || false;

            if (hasOption("minWidth")) {
                minWidth = options.minWidth;
            }
            if (hasOption("initWidth")) {
                initWidth = options.initWidth;

            }
            if( hasOption("maxWidth")){
                maxWidth = options.maxWidth;
            }
            if (initWidth < minWidth) {
                initWidth = minWidth;
                minimized = true;
            }

            oWidth = initWidth;
            curWidth = initWidth;
            if (minimized) {
                curWidth = minWidth;
            }
            if (!options.isInfo) {
                handlerElement.width(curWidth);
            }


            if (isLeft) {
                var left = parseInt(handlerElement.css("left"));
                firstElement.css({ left: (left + curWidth) + 'px' });
                handlerElement.css({ right: 'auto' });
            } else {
                var right = parseInt(handlerElement.css("right"));
                firstElement.css({ right: (right + curWidth) + 'px' });
                if (options.isInfo) {
                    var width = firstElement.width();
                    handlerElement.css({ left: width});
                }
                else {
                    handlerElement.css({ left: 'auto' });
                }      
            }




            var dragHandler = handlerElement.find('.' + handlerCssName);

            function onTrayHandleMousedown(e) {
                e.preventDefault();
                startPosition = [e.pageX, e.pageY];
                oWidth = handlerElement.width();
                handlerElement.removeClass("ani");
                dragHandler.off("mousedown", onTrayHandleMousedown);
                window.addEventListener("mousemove", onTrayHandleMousemove);
                window.addEventListener("mouseup", onTrayHandleMouseup);
                // document.querySelector(".hoverifm").style.display = "block";
            }
            function onTrayHandleMousemove(e) {

                e.preventDefault();
                e.stopPropagation();
                var diffX = e.pageX - startPosition[0],
                    nWidth = 0;


                if (isLeft) {
                    nWidth = oWidth + diffX;
                    if (nWidth <= minWidth) {
                        _this.minimize(true);
                        return;
                    } else {
                        minimized = false;
                    }
                    if (maxWidth > minWidth && nWidth > maxWidth) {
                        nWidth = maxWidth;
                    }

                    var left = parseInt(handlerElement.css("left"));
                    if (handlerElement[0].getAttribute('id') == 'player') {
                        //setCookie('playerWidth', nWidth);
                    }
                    else {
                        if (nWidth < 230) {
                            nWidth = 231;
                        }
                       // setCookie('propertyWidth', nWidth );
                    }
                    handlerElement.width(nWidth);
                    curWidth = nWidth;
                    firstElement.css({ left: (left + nWidth) + 'px' });
                } else {
                    nWidth = oWidth - diffX;
                    if (handlerElement[0].getAttribute('id') == 'player') {
                        if (e.clientX -  216 < 400) { //(getCookie('treeWidth') || 216) < 400) {
                            return;
                        }
                    }
                    if (nWidth <= minWidth) {
                        _this.minimize(true);
                        return;
                    } else {
                        minimized = false;
                    }
                    if (maxWidth > minWidth && nWidth > maxWidth) {
                        nWidth = maxWidth;
                    }


                    var right = parseInt(handlerElement.css("right"));
                    if (handlerElement[0].getAttribute('id') == 'player') {
                        if ($('.svcontainer').innerWidth() < 645) {
                            $('.markerlist').width(nWidth - 645);
                            //setCookie('markerWidth',nWidth - 645);
                            $('.svcontainer').css({ right: (nWidth - 645) + 'px' });
                            $('.svcontainer').css({ width: 'calc(100% - ' + (nWidth - 645) + 'px)' });
                            if ($('.svcontainer').innerWidth() < 645) {
                                $('.markerlist').width(55);
                               // setCookie('markerWidth', 55);
                                $('.svcontainer').css({ right: '55px' });
                                $('.svcontainer').css({ width: 'calc(100% - ' + 55 + 'px)' });
                            }
                        }
                        //setCookie('playerWidth', nWidth);
                    }
                    else {
                        if (nWidth < 230) {
                            nWidth = 231;
                        }
                        //setCookie('propertyWidth', nWidth);
                    }
                    handlerElement.width(nWidth);
                    curWidth = nWidth;
                    firstElement.css({ right: (right + nWidth) + 'px' });
                }

                _this.dispatchEvent("resize");
                //document.querySelector('.svwindow').style.display = 'block';
            }
            function onTrayHandleMouseup(e) {

                handlerElement.addClass("ani");
                dragHandler.on("mousedown", onTrayHandleMousedown);
                window.removeEventListener("mousemove", onTrayHandleMousemove, false);
                window.removeEventListener("mouseup", onTrayHandleMouseup, false);
                // document.querySelector(".hoverifm").style.display = "none";
            }

            dragHandler.on("mousedown", onTrayHandleMousedown);

            dragHandler.on("dblclick", function () {
                _this.minimize(!minimized);
            });

            this.hide = function () {
                handlerElement.width(0);
                firstElement.css({ right: 0 + 'px' });
                _this.dispatchEvent("resize");
            }
            this.show = function () {
                handlerElement.width(250);
                firstElement.css({ right: 250 + 'px' });
                var width = firstElement.width();
                handlerElement.css({ left: width });
                _this.dispatchEvent("resize");
            }
            this.minimize = function (state) {
                minimized = state;

                if (state) {
                    handlerElement.width(minWidth);
                    //setCookie('playerWidth', minWidth);
                    //setCookie('propertyWidth', 200);
                    curWidth = minWidth;
                    if (isLeft) {
                        var left = parseInt(handlerElement.css("left"));
                        firstElement.css({ left: (left + minWidth) + 'px' });
                    } else {
                        var right = parseInt(handlerElement.css("right"));
                        firstElement.css({ right: (right + minWidth) + 'px' });
                    }
                    setTimeout(function () {
                        _this.dispatchEvent("resize");
                    }, 300);
                    $('.markerlist').width(55);
                    //setCookie('markerWidth', 55);
                    $('.svcontainer').css({ right: '55px' });
                    $('.svcontainer').css({ width: 'calc(100% - ' + 55 + 'px)' });
                } else {
                    if (maxWidth >= minWidth && curWidth > maxWidth) {
                        curWidth = maxWidth;
                    }
                    if (curWidth <= minWidth) {
                        curWidth = initWidth;
                    }
                    if (handlerElement[0].getAttribute('id') == 'player') {
                        //setCookie('playerWidth', curWidth);
                    }
                    else {
                        if (curWidth < 230) {
                            curWidth = 231;
                        }
                        //setCookie('propertyWidth', curWidth);
                        //setCookie('playerWidth', maxWidth + 231);
                    }
                    handlerElement.width(curWidth);
                    if (isLeft) {
                        var left = parseInt(handlerElement.css("left"));
                        firstElement.css({ left: (left + curWidth) + 'px' });
                    } else {
                        var right = parseInt(handlerElement.css("right"));
                        firstElement.css({ right: (right + curWidth) + 'px' });
                    }
                    setTimeout(function () {
                        _this.dispatchEvent("resize");
                    }, 300);
                }

            }

            this.maxWidth = function (n) {
                if (n && n!=maxWidth) {
                    maxWidth = n;
                    if (!minimized) {
                        _this.minimize(false);
                    }
                }
            }

            Object.defineProperties(_this, {
                minimized: {
                    enumerable: true,
                    get: function () {
                        return minimized;
                    },
                    set: function (val) {
                        if (val !== minimized) {
                            _this.minimize(val);
                        }
                    }
                }
            });
        }
    });
    return ResizeHelper;
});

h5.define('templates/H5PlayerLayout', [], function () {
    return '<div class="video-panel-resize resize-handle"></div>\
        <div id="h5-player-panel" class="h5-player-panel">\
            <div id="h5-video-panel-wrapper" class="video-panel-wrapper">\
                <div class="wrapperplayer ">\
                    <div class="player_top">\
                    <div class="h5-player-title"><span id="mvTimeLineTitle">Unnamed</span></div>\
                             <div style="top: -9px; right: 4px; position: absolute; width: 260px; ">\
                            <font class="code_small" style="color:#646464;">DURATION</font>\
                            <font class="code_small" style="margin-right:60px;">POSITION</font>\
                            </div>\
                            <div style="top: 6px; right: -2px; position: absolute; width: 236px;">\
                                <div class="duration">\
                                    00:00:00:00\
                                </div>\
                                <div class="duration_mark">\
                                    /\
                                </div>\
                                <div class="code">\
                                    00:05:12:30\
                                </div>\
                            </div>\
                    </div>\
                     <div class="h5-player-toolbar"><span class="glyphicon glyphicon-play toolbar-btn-play" id="play" title="Play/Pause(Space)">p</span><span class="glyphicon glyphicon-fast-backward toolbar-btn-play" id="startframe"  title="To the beginning(Home)">h</span><span class="glyphicon glyphicon-step-backward toolbar-btn-play" id="prevframe" title="Last frame(←)">l</span><span class="glyphicon glyphicon-step-forward toolbar-btn-play"id="nextframe" title="Next frame(→)">n</span><span class="glyphicon glyphicon-fast-forward toolbar-btn-play" id="endframe" title="To the end(End)">e</span></div>\
                    <div id="h5-video-panel" class="video-panel">\
                        <div class="loading hidden">\
                            <div class="loadingWrapper">\
                                <div class="rect1"></div>\
                                <div class="rect2"></div>\
                                <div class="rect3"></div>\
                                <div class="rect4"></div>\
                                <div class="rect5"></div>\
                            </div>\
                            <span class="info">' + lang[_curLang].buffering + '</span>\
                        </div>\
                    </div>\
                </div>\
            </div>\
            <div id="h5-info-panel-wrapper" class="info-panel-wrapper">\
                <div class="info-panel-resize resize-handle"></div>\
                <div class="wrapper">\
                    <div id="h5-info-panel" class="info-panel">\
                    </div>\
                </div>\
            </div>\
        </div>';
});
h5.define('util/H5Scrollbar', ["jquery", "util/Object"], function ($, Obj) {

    var VERTICAL_SIZE_REDUCTION_FACTOR = 3,
        ACTIVE_CLASS = "scollbar-active",
        SCROLL_MODIFIER = 10;

    var Vertical = Obj.extend({
        init: function (outerElement, innerElement) {
            var _element = document.createElement("div"),
            _handle = document.createElement("div"),
            _elementHeight,
            _parentHeight,
            _childHeight,
            _scrollHeight,
            _handleHeight,
            _dragging = false,
            _mousePos = 0,
            _this = this;

            this._super();

            _element.className = "scroll-bar scroll-bar-v";
            _handle.className = "scroll-handle";

            _element.appendChild(_handle);

            this.update = function () {
                if (!_element.parentElement)
                    return;
                _parentHeight = outerElement.getBoundingClientRect().height;
                _childHeight = innerElement.getBoundingClientRect().height;
                _elementHeight = _element.getBoundingClientRect().height;
                _scrollHeight = outerElement.scrollHeight;
                _handleHeight = _elementHeight - (innerElement.scrollHeight - _parentHeight) / VERTICAL_SIZE_REDUCTION_FACTOR;
                _handleHeight = Math.max(20, Math.min(_elementHeight, _handleHeight));
                _handle.style.height = _handleHeight + "px";

                setHandlePosition();

                if (_childHeight <= _parentHeight) {
                    _element.style.opacity = 0;
                } else {
                    _element.style.opacity = 1;
                }
            };

            this.scroll = function (val) {
                if (typeof val === "undefined") {
                    return outerElement.scrollTop;
                }
                outerElement.scrollTop = val;
            };

            function onMouseUp() {
                _dragging = false;
                window.removeEventListener("mouseup", onMouseUp, false);
                window.removeEventListener("mousemove", onMouseMove, false);
                _handle.addEventListener("mousedown", onMouseDown);
                _handle.classList.remove(ACTIVE_CLASS);
            }

            function onMouseMove(e) {
                var diff = e.pageY - _mousePos,
                    maxDiff = _elementHeight - _handleHeight;
                diff = Math.max(0, Math.min(diff, maxDiff));
                var p = diff / maxDiff;
                _handle.style.top = maxDiff * p + "px";

                outerElement.scrollTop = (_scrollHeight - _parentHeight) * p;
                _this.dispatchEvent("scroll", outerElement.scrollTop);
            }

            function onMouseDown(e) {
                // Stop text selection in chrome.
                e.preventDefault();
                if (e.button === 0) {
                    var handleY = _handle.offsetTop;
                    _mousePos = e.pageY - handleY;
                    _dragging = true;
                    window.addEventListener("mouseup", onMouseUp);
                    window.addEventListener("mousemove", onMouseMove);
                    _handle.removeEventListener("mousedown", onMouseDown, false);
                    _handle.classList.add(ACTIVE_CLASS);
                }
            }

            function setHandlePosition() {
                if (innerElement.scrollHeight - _elementHeight > 0) {
                    _handle.style.top = (_elementHeight - _handleHeight) *
                      (outerElement.scrollTop / (_scrollHeight - _parentHeight)) + "px";
                }
                else {

                    _handle.style.top = "0px";
                }
            }

            outerElement.addEventListener("scroll", function (e) {
                if (!_dragging) {
                    setHandlePosition();
                }
                e.stopPropagation();
            });

            outerElement.addEventListener("mousewheel", function (e) {
                if (!e.ctrlKey) {
                    var delta = e.wheelDeltaY || e.wheelDelta;

                    outerElement.scrollTop -= delta / SCROLL_MODIFIER;
                    setHandlePosition();
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // For Firefox
            outerElement.addEventListener("DOMMouseScroll", function (e) {
                if (!e.ctrlKey) {
                    if (e.axis === e.VERTICAL_AXIS && !e.shiftKey) {
                        outerElement.scrollTop += e.detail * 2;
                        setHandlePosition();
                        e.preventDefault();
                        e.stopPropagation();
                    }
                }
            });

            _element.addEventListener("click", function (e) {
                // bail early if this event is coming from the handle
                if (e.srcElement === _handle || e.button > 0) {
                    return;
                }

                var posY = e.pageY,
                    handleRect = _handle.getBoundingClientRect(),
                    elementRect = _element.getBoundingClientRect(),
                    p;

                if (posY > handleRect.bottom) {
                    _handle.style.top = ((posY - elementRect.top) - _handleHeight) + "px";
                } else if (posY < handleRect.top) {
                    _handle.style.top = posY - elementRect.top + "px";
                }

                p = _handle.offsetTop / (_elementHeight - _handleHeight);
                // outerElement.scrollTop = (_scrollHeight - _elementHeight) * p;
                $(outerElement).scrollTop((_scrollHeight - _elementHeight) * p);
                e.stopPropagation();
            });

            _handle.addEventListener("mousedown", onMouseDown);

            _this.update();

            Object.defineProperties(this, {
                element: {
                    enumerable: true,
                    get: function () {
                        return _element;
                    }
                }
            });
        }


    });




    var Horizontal = Obj.extend({
        init: function(outerElement, innerElement){
            var _element = document.createElement("div"),
                        _handle = document.createElement("div"),
                        _elementWidth,
                        _parentWidth,
                        _childWidth,
                        _scrollWidth,
                        _handleWidth,
                        _mousePos = 0,
                        _dragging = false,
                        _this = this;

            this._super();

            _element.className = "scroll-bar scroll-bar-h";
            _handle.className = "scroll-handle";

            _element.appendChild(_handle);

            this.update = function () {
                if (!_element.parentElement)
                    return;

                _parentWidth = outerElement.getBoundingClientRect().width;
                _childWidth = innerElement.getBoundingClientRect().width;
                _elementWidth = _element.getBoundingClientRect().width;
                _scrollWidth = innerElement.scrollWidth;
                _handleWidth = _elementWidth - (_scrollWidth - _parentWidth);
                _handleWidth = Math.max(20, Math.min(_elementWidth, _handleWidth));
                _handle.style.width = _handleWidth + "px";
                setHandlePosition();
            };

            this.scroll = function (val) {
                if (typeof val === "undefined") {
                    return outerElement.scrollLeft;
                }
                outerElement.scrollLeft = val;
            };

            function onMouseUp() {
                _dragging = false;
                window.removeEventListener("mouseup", onMouseUp, false);
                window.removeEventListener("mousemove", onMouseMove, false);
                _handle.addEventListener("mousedown", onMouseDown);
            }

            function onMouseMove(e) {
                e.preventDefault();
                var diff = e.pageX - _mousePos;
                diff = Math.max(0, Math.min(diff, _elementWidth - _handleWidth));
                _handle.style.left = diff + "px";
                var p = _handle.offsetLeft / (_elementWidth - _handleWidth);
                outerElement.scrollLeft = (_scrollWidth - _elementWidth) * p;
                _this.dispatchEvent("scroll", outerElement.scrollLeft);
            }

            function onMouseDown(e) {
                // Stop text selection in chrome.
                e.preventDefault();
                if (e.button === 0) {
                    var handleX = _handle.offsetLeft;
                    _mousePos = e.pageX - handleX;
                    _dragging = true;
                    window.addEventListener("mouseup", onMouseUp);
                    window.addEventListener("mousemove", onMouseMove);
                    _handle.removeEventListener("mousedown", onMouseDown, false);
                }
            }

            function setHandlePosition() {
                if (_scrollWidth - _elementWidth > 0) {
                    _handle.style.left = (_elementWidth - _handleWidth) *
                      (outerElement.scrollLeft / (_scrollWidth - _elementWidth)) + "px";
                } else {
                    _handle.style.left = "0px";
                }
            }

            outerElement.addEventListener("scroll", function () {
                if (!_dragging) {
                    setHandlePosition();
                }
            });

            outerElement.addEventListener("mousewheel", function (e) {
                if (!e.ctrlKey) {
                    if (e.wheelDeltaX) {
                        outerElement.scrollLeft -= e.wheelDeltaX;
                        setHandlePosition();
                        e.preventDefault();
                    }
                }
            });

            // For Firefox
            outerElement.addEventListener("DOMMouseScroll", function (e) {
                if (!e.ctrlKey) {
                    if (e.axis === e.HORIZONTAL_AXIS || (e.axis === e.VERTICAL_AXIS && e.shiftKey)) {
                        outerElement.scrollLeft += e.detail * 2;
                        setHandlePosition();
                        e.preventDefault();
                    }
                }
            });

            _element.addEventListener("click", function (e) {
                // bail early if this event is coming from the handle
                if (e.srcElement === _handle || e.button > 0) {
                    return;
                }

                var posX = e.pageX,
                    handleRect = _handle.getBoundingClientRect(),
                    elementRect = _element.getBoundingClientRect(),
                    p;

                if (posX > handleRect.right) {
                    _handle.style.left = ((posX - elementRect.left) - _handleWidth) + "px";
                }
                else if (posX < handleRect.left) {
                    _handle.style.left = posX - elementRect.left + "px";
                }

                p = _handle.offsetLeft / (_elementWidth - _handleWidth);
                outerElement.scrollLeft = (_scrollWidth - _elementWidth) * p;
            });

            _handle.addEventListener("mousedown", onMouseDown);

            _this.update();

            Object.defineProperties(this, {
                element: {
                    enumerable: true,
                    get: function () {
                        return _element;
                    }
                }
            });
        }
    });






    return {
        Vertical: Vertical,
        Horizontal: Horizontal
    };

});

/*
 * 信息面板
 */
h5.define('timeline/H5InfoPanel', [
    "jquery",
    "util/Object",
    "util/H5Scrollbar"
],
  function ($, Obj, H5Scrollbar) {

      var H5InfoPanel = Obj.extend({
          /*
           * @description 初始化H5InfoPanel对象
           * @param {element} element 容器元素
          */
          init: function (app,editorPlugin,  element) {
              var _this = this,
                  _app = app,
                  _parentElement = element,
                  _element = document.createElement("div"),
                  _tabsElement = document.createElement("ul"),
                  _framesElement = document.createElement("div"),
                  _framesWrapperElement = document.createElement("div"),
                  _pageElement = document.createElement("div"),
                  _pages = {},
                  _editorPlugin = editorPlugin,
                  _currentPage = null;

              _this._super();

              _element.classList.add("tabcontrol");
              _tabsElement.classList.add("tabs");
              _framesElement.classList.add("frames");
              _pageElement.classList.add("page");
              _framesWrapperElement.classList.add("frames-wrapper");

              _framesWrapperElement.appendChild(_framesElement);
              _element.appendChild(_tabsElement);
              _framesElement.appendChild( _pageElement);
              _element.appendChild(_framesWrapperElement);
              _parentElement.appendChild(_element);

              _pageElement.style.zIndex = 1000;

              var sb = new H5Scrollbar.Vertical(_framesElement, _pageElement);
              _framesWrapperElement.appendChild(sb.element);

              sb.update();

              _this.createPanel = function (id, displayName, desc, disableScroll) {

                  if (_pages[id]) {
                      return _pages[id].pageElement;
                  }

                  var liElement = $('<li><a href="javascript:void(0)">' + displayName + '</a></li>');
                  liElement.data("pageid", id);
                  liElement.click(function () {
                      _this.activePage(id);
                  });

                  //
                  var pageElement = $('<div class="frame"></div>');
                  if (disableScroll) {
                      pageElement.css({
                          position: "relative",
                          width: "100%",
                          height: "100%",
                          padding: "0px",
                          margin: "0px"
                      });
                  }

                  _tabsElement.appendChild(liElement[0]);
                  _framesElement.appendChild(pageElement[0]);

                  pageElement.addClass("hidden");

                  var page = {
                      id: id,
                      displayName: displayName,
                      desc: desc,
                      titleElement: liElement[0],
                      pageElement: pageElement[0],
                      scroll: !disableScroll
                  };

                  _pages[id] = page;

                  return page.pageElement;

              };

              _this.removePanel = function (id) {
                  var p = _pages[id];
                  if (p) {
                      p.titleElement.off("click");
                      _tabsElement.removeChild(p.titleElement);


                      if (p.pageElement.parentNode) {
                          p.pageElement.parentNode.removeChild(p.pageElement);
                      }

                      if (_currentPage === p) {
                          _currentPage = null;
                      }
                  }
              };

              _this.activePage = function (id) {
                  if (!_pages[id]) {
                      return;
                  }

                  if (_currentPage && _currentPage.id === id) {
                  } else {
                      if (_currentPage) {
                          _pageElement.removeChild(_currentPage.pageElement);
                          _currentPage.titleElement.classList.remove("active");
                      }



                      var p = _pages[id];

                      if (p.scroll) {
                          _this.enableScroll();
                      } else {
                          _this.disableScroll();
                      }

                      _pageElement.appendChild(p.pageElement);
                      p.pageElement.classList.remove("hidden");
                      p.titleElement.classList.add("active");
                      _currentPage = p;

                      _this.update();
                  }
              };

              _this.disableScroll = function () {
                  _pageElement.style.position = "absolute";
                  _pageElement.style.left = "0px";
                  _pageElement.style.top = "0px";
                  _pageElement.style.right = "0px";
                  _pageElement.style.bottom = "0px";
              };

              _this.enableScroll = function () {
                  _pageElement.style.position = "relative";
                  _pageElement.style.width = "auto";
                  _pageElement.style.height = "auto";
              };

              _this.update = function () {
                  sb.update();

                  if (sb.element.style.opacity !== '0') {
                      _framesWrapperElement.style.right = "10px";
                  } else {
                      _framesWrapperElement.style.right = "0px";
                  }
              };

              _editorPlugin._service.createPanel = _this.createPanel;
              _editorPlugin._service.removePanel = _this.removePanel;
              _editorPlugin._service.activePanel = _this.activePage;

              Object.defineProperties(_this, {
                  element: {
                      enumerable: true,
                      get: function () {
                          return _parentElement;
                      }
                  }
              });
          },
      });



      return H5InfoPanel;
  });
/*
 * 播放器面板
 */
h5.define('timeline/H5PlayerPanel', [
    "jquery",
    "util/Object",
    "util/H5HorizontalResizer",
    "util/util",
    "templates/H5PlayerLayout",
    "timeline/H5InfoPanel"
],
  function ($, Obj, Resizer, util, H5_PLAYER_LAYOUT, H5InfoPanel) {

      var sizesDic = {
          "16:9": 16 / 9,
          "4:3": 4 / 3
      };
      var PLAYER_PADDING = 0;

      function sizesConvert(sizes) {
          return sizesDic[sizes];
      }

      var PlayerPanel = Obj.extend({
           /*
            * @description 初始化PlayerPanel对象
            * @param {Object} options 选项配置
            *   parentElement: 面板容器元素
            *   slidingElement: 拖动改变大小时，关联的另一个元素
            *   minWidth: 最小宽度
            *   initWidth: 初始宽度
            *   maxWidth: 最大宽度
            *   {Object} infoPanel: 信息面板参数
            *       minWidth: 最小宽度
            *       maxWidth: 最大宽度
            *       initWidth: 初始宽度
            *   {Object} playerPanel: 播放器面板参数
            *       minWidth: 最小宽度
            *       sizes:  播放器幅面
           */
          init: function (app, editorPlugin, options) {
              var _this = this,
                  options = options || {},
                  _pluginPanel = null,
                  _parentElement = options.parentElement,
                  _clipSizes = { width: 640, height: 480 };

              options.infoPanel = options.infoPanel || {
                  minWidth: 5,
                  maxWidth: 0,
                  initWidth: 390,
              };
              options.playerPanel = options.playerPanel || {
                  minWidth: 120,
                  sizes: "16:9"
              };

              $(_parentElement).append($(H5_PLAYER_LAYOUT));
              var _videoPanel = _parentElement.querySelector(".video-panel"),
                  _videoPanelContainer = _parentElement.querySelector(".video-panel-wrapper"),
                  _infoPanel = _parentElement.querySelector(".info-panel"),
                  _videoLoading = _videoPanel.querySelector(".loading"),
                  _videoPanelId = _videoPanel.id;

              var _startframe = _videoPanelContainer.querySelector("#startframe"),
                  _prevframe = _videoPanelContainer.querySelector("#prevframe"),
                  _play = _videoPanelContainer.querySelector("#play"),
                  _nextframe = _videoPanelContainer.querySelector("#nextframe"),
                  _endframe = _videoPanelContainer.querySelector("#endframe");

              _startframe.addEventListener("click", function () {
                  app.media.startFrame();
              });
              _prevframe.addEventListener("click", function () {
                  app.media.pause();
                  app.media.prevFrame();
              });
              _play.addEventListener("click", function () {
                  if (app.media.duration > 0) {
                      if (app.media.paused) {
                          app.media.play();
                      } else {
                          app.media.pause();
                      }
                  }
              });
              _nextframe.addEventListener("click", function () {
                  app.media.pause();
                  app.media.nextFrame();
              });
              _endframe.addEventListener("click", function () {
                  app.media.endFrame();
              });
              if (!_videoPanelId) {
                  _videoPanelId = "h5_video_player";
                  _videoPanel.id = "h5_video_player";
              }

              _parentElement.classList.add("h5-player-wrapper");

              _this._super();

              var _sizes = options.playerPanel.sizes || "4:3",
                  _sizesRate = sizesConvert(_sizes),
                  _playerSize = { width: 0, height: 0 };

              var _resizer = new Resizer({
                  minWidth: options.minWidth,
                  initWidth: options.initWidth,
                  maxWidth: options.maxWidth,
                  firstElement: options.slidingElement,
                  handlerElement: _parentElement,
              });
              
              window._playerResizer = _resizer;
              var mw = $(_parentElement).width() - options.playerPanel.minWidth;
              if (options.infoPanel.maxWidth > 0) {
                  mw = Math.min(options.infoPanel.maxWidth, mw);
              }
              var _infoResizer = new Resizer({
                  minWidth: options.infoPanel.minWidth,
                  maxWidth: mw,
                  initWidth: options.infoPanel.initWidth || 150,
                  minimized: false,
                  handlerCss: 'info-panel-resize',
                  firstElement: _parentElement.querySelector(".video-panel-wrapper"),
                  handlerElement: _parentElement.querySelector(".info-panel-wrapper"),
                  isInfo :  true,
              });
              window._infoResizer = _infoResizer;
              _pluginPanel = new H5InfoPanel(app, editorPlugin, _infoPanel);

              _resizer.addEventListener("resize", function () {
                  _infoResizer.maxWidth($(_parentElement).width() - options.playerPanel.minWidth);
                  updateVideoPanel();
                  app.dispatchEvent("resize");
                 // _this.dispatchEvent("resize");
              });
              _infoResizer.addEventListener("resize", function () {
                  updateVideoPanel();
                  _this.dispatchEvent("resize");
                  _pluginPanel.dispatchEvent("resize");
                  app.dispatchEvent("resize");
              });

              function changeSizes(newSizes) {
                  var rate = sizesConvert(newSizes);
                  if (rate) {
                      _sizes = newSizes;
                      _sizesRate = rate;
                      updateVideoPanel();
                      _this.dispatchEvent("sizesChanged");
                  }
              }

              function updateVideoPanel() {
                  var wrapper = $(_videoPanelContainer),
                      panel = $(_videoPanel),
                      width = Math.floor( wrapper.width()) - 2 * PLAYER_PADDING,
                      height = Math.floor( wrapper.height()) - 2* PLAYER_PADDING,
                      pWidth = width,
                      pHeight = height;

                  var w = Math.ceil(height * _sizesRate);
                  if (w > width) {
                      pHeight = Math.floor(pWidth / _sizesRate);
                  } else {
                      pWidth = w;
                  }

                  var left = (width - pWidth) / 2 + PLAYER_PADDING,
                      top = (height - pHeight) / 2 + PLAYER_PADDING;

                  panel.css({
                      left: left + 'px',
                      top: top + 'px',
                      width: pWidth + 'px',
                      height: pHeight + 'px',
                      "font-size": pHeight + 'px'//,
                     // overflow: "hidden"

                  });

                  _playerSize.width = pWidth;
                  _playerSize.height = pHeight;



              }

              updateVideoPanel();

              app.addEventListener("resize", function () {
                  updateVideoPanel();
                  _this.dispatchEvent("resize");
                  _pluginPanel.dispatchEvent("resize");
              });

              app.addEventListener("ready", function () {
                  app.media.addEventListener("mediapopcornsettingschanged", function () {
                      if (app.media.popcornOptions.sizes != _sizes) {
                          changeSizes(app.media.popcornOptions.sizes);
                      }
                  });
              });


              this.calcDisplayPixel = function (oriPixel) {
                  var r = _sizes.width / _clipSizes.width;

                  return oriPixel * r;
              };

              this.calcOutputPixel = function (displayPixel) {
                  var r = _sizes.width / _clipSizes.width;
                  return displayPixel / r;
              };

              Object.defineProperties(_this, {
                  sizes: {
                      enumerable: true,
                      get: function(){
                          return _sizes;
                      },
                      set: function (val) {
                          changeSizes(val);
                      }
                  },
                  sizesRate: {
                      enumerable: true,
                      get: function () {
                          return _sizesRate;
                      }
                  },
                  videoPanel: {
                      enumerable: true,
                      get: function () {
                          return _videoPanel;
                      }
                  },
                  infoPanel: {
                      enumerable: true,
                      get: function () {
                          return _infoPanel;
                      }
                  },
                  playerSize: {
                      enumerable: true,
                      get: function () {
                          return {
                              width: _playerSize.width,
                              height: _playerSize.height
                          };
                      }
                  },
                  outputSize: {
                      enumerable: true,
                      get: function () {
                          return {
                              width: _clipSizes.width,
                              height: _clipSizes.height
                          };
                      }
                  },
                  pluginPanel: {
                      enumerable: true,
                      get: function () {
                          return _pluginPanel;
                      }
                  }
              });
          },
      });



      return PlayerPanel;
  });
/*
 * "开关"按钮
 */
h5.define('util/H5Toggler', [], function () {
    //
    return function (rootElement, clickHandler, elementTitle, startState) {
        var _element = rootElement;


        _element.title = elementTitle || lang[_curLang].showOrHide;

        rootElement.addEventListener("mousedown", function (e) {
            // Disable text selection in chrome while clicking.
            e.preventDefault();
        });

        if (clickHandler) {
            _element.addEventListener("click", clickHandler);
        }

        Object.defineProperties(this, {
            element: {
                enumerable: true,
                get: function () {
                    return _element;
                }
            },
            state: {
                enumerable: true,
                get: function () {
                    return _element.classList.contains("toggled");
                },
                set: function (state) {
                    if (state) {
                        _element.classList.add("toggled");
                    }
                    else {
                        _element.classList.remove("toggled");
                    }
                }
            },
            visible: {
                enumerable: true,
                get: function () {
                    return _element.style.display !== "none";
                },
                set: function (val) {
                    _element.style.display = val ? "block" : "none";
                }
            }
        });

        this.state = startState;

    };
});
/*
 * 观察者
 */
h5.define('util/Observer', ['util/Object'], function (Obj) {

    /**
     * 通知对象
     * 当触发一个通知时，订阅者可获取到通知
     *
     * @param {Object} origin: 谁发送的通知.
     * @param {String} type: 通知类型.
     * @param {Object} data: 通知关联的数据.
     */
    function Notification(origin, type, data) {
        var _cancelledReason;

        /**
         * cancel
         *
         * 取消通知的继续传递
         *
         * @param {String} reason: 取消通知的原因.
         */
        this.cancel = function (reason) {
            _cancelledReason = reason || true;
        };

        Object.defineProperties(this, {
            origin: {
                value: origin,
                enumerable: true
            },
            type: {
                value: type,
                enumerable: true
            },
            data: {
                value: data,
                enumerable: true
            },
            cancelledReason: {
                enumerable: true,
                get: function () {
                    return _cancelledReason;
                }
            },
            cancelled: {
                enumerable: true,
                get: function () {
                    return !!_cancelledReason;
                }
            }
        });
    }

    // 从对象继承，支持事件
    var Observer = Obj.extend({
        init: function () {
            this._super();

            this._subscribers = {};


        },
        subscribe: function (type, subscriber) {
            if (!this._subscribers[type]) {
                this._subscribers[type] = [];
            }
            this._subscribers[type].push(subscriber);
        },
        unsubscribe: function (type, subscriber) {
            var idx, subscribers = this._subscribers[type];

            if (subscribers) {
                idx = subscribers.indexOf(subscriber);
                if (idx > -1) {
                    subscribers.splice(idx, 1);
                }
            }
        },
        notify: function (type, data, object) {
            var i, l,
                subscribers = this._subscribers[type],
                notification = new Notification(this, type, data);

            if (subscribers) {
                for (i = 0, l = subscribers.length; i < l; ++i) {
                    subscribers[i](notification);
                    if (notification.cancelled) {
                        break;
                    }
                }
            }

            return notification;
        }
    });

    return Observer;
});

h5.define('util/Time', [], function () {

    var __timeAccuracy = 5;

    /**
     * Member: roundTime
     *
     * Rounds a number to a set accuracy
     * Accuracy of 5:
     * 1.012345 -> 1.01234
     * Accuracy of 2:
     * 1.012345 -> 1.01
     *
     * @param {Number} time: Time which will be rounded
     * @param {Number} accuracy: A one time accuracy to round to
     */
    function roundTime(time, accuracy) {
        accuracy = accuracy >= 0 ? accuracy : __timeAccuracy;
        return Math.round(time * (Math.pow(10, accuracy))) / Math.pow(10, accuracy);
    }

    /**
     * Member: toSeconds
     *
     * toSeconds converts a timecode string to seconds.
     * "HH:MM:SS.DD" -> seconds
     * examples:
     * "1:00:00" -> 3600
     * "-1:00:00" -> -3600
     * it also converts strings with seconds to seconds
     * " 003600.00" -> 3600
     * " 003600.99" -> 3600.99
     *
     * @param {String} time: Timecode to be converted to seconds
     */
    function toSeconds(time) {
        var splitTime,
            seconds,
            minutes,
            hours,
            isNegative = 1;

        if (typeof time === "number") {
            return time;
        }

        if (typeof time !== "string") {
            return 0;
        }

        time = time.trim();
        if (time.substring(0, 1) === "-") {
            time = time.replace("-", "");
            isNegative = -1;
        }

        splitTime = time.split(":");
        seconds = +splitTime[splitTime.length - 1] || 0;
        minutes = +splitTime[splitTime.length - 2] || 0;
        hours = +splitTime[splitTime.length - 3] || 0;

        seconds += hours * 3600;
        seconds += minutes * 60;

        return seconds * isNegative;
    }

    /**
     * Member: toTimecode
     *
     * toTimecode converts seconds to a timecode string.
     * seconds -> "HH:MM:SS.DD"
     * examples:
     * 3600 -> "1:00:00"
     * -3600 -> "-1:00:00"
     * it also converts strings to timecode
     * "  00:00:01" -> "1"
     * "  000:01:01.00" -> "1:01"
     * "3600" -> "1:00:00"
     *
     * Accuracy of 5:
     * 1.012345 -> "0:01.01234"
     * Accuracy of 2:
     * 1.012345 -> "0:01.01"
     * Defaults to 2
     *
     * @param {Number} time: Seconds to be converted to timecode
     * @param {Number} accuracy: A one time accuracy to round to
     */
    function toTimecode(time, accuracy) {
        var hours,
            minutes,
            seconds,
            timeString,
            isNegative = "";

        if (!accuracy && accuracy !== 0) {
            accuracy = 2;
        }

        if (typeof time === "string") {
            time = toSeconds(time);
        }

        if (typeof time !== "number") {
            return 0;
        }

        if (time < 0) {
            isNegative = "-";
            time = -time;
        }

        time = roundTime(time, accuracy);
        hours = Math.floor(time / 3600);
        minutes = Math.floor((time % 3600) / 60);
        seconds = roundTime(time % 60, accuracy);
        timeString = seconds + "";

        if (!minutes && !hours) {
            if (seconds < 10) {
                timeString = "0" + timeString;
            }
            return isNegative + "0:" + timeString;
        }

        if (!seconds) {
            timeString = ":00";
        } else if (seconds < 10) {
            timeString = ":0" + seconds;
        } else {
            timeString = ":" + timeString;
        }

        if (!minutes) {
            timeString = "00" + timeString;
        } else if (hours && minutes < 10) {
            timeString = "0" + minutes + timeString;
        } else {
            timeString = minutes + timeString;
        }

        if (hours) {
            timeString = hours + ":" + timeString;
        }

        return isNegative + timeString;
    }




    /**
     * Member: toPrettyString
     *
     * toPrettyString converts a time in ms to something pretty for display.
     *
     * Examples:
     * 12341 -> "less than a minute"
     * 123411 -> "2 minutes"
     * 123411234 -> "10 hours"
     * 1234112341 -> "14 days"
     *
     * @param {Number} ms: A number of ms
     */
    function toPrettyString(ms) {
        var round = Math.round,
            t, seconds, minutes, hours, days;

        t = ms / 1000;
        seconds = round(t % 60);
        t /= 60;
        minutes = round(t % 60);
        t /= 60;
        hours = round(t % 24);
        t /= 24;
        days = round(t);

        if (days >= 1) {
            return "" + days + (days === 1 ? " day" : " days");
        } else if (hours >= 1) {
            return "" + hours + (hours === 1 ? " hour" : " hours");
        } else if (minutes >= 1) {
            return "" + minutes + (minutes === 1 ? " minute" : " minutes");
        } else {
            return "less than a minute";
        }
    }

    var utils = {
        roundTime: roundTime,
        toSeconds: toSeconds,
        toTimecode: toTimecode,
        toPrettyString: toPrettyString
    }; //utils

    Object.defineProperties(utils, {
        timeAccuracy: {
            enumerable: true,
            get: function () {
                return __timeAccuracy;
            },
            set: function (val) {
                __timeAccuracy = val;
            }
        }
    });

    return utils;

});


h5.define('util/H5ScrollGroup', [], function () {

    function ScrollGroup(scrollElement) {
        this.scrollDiff = [0, 0];
        this.scrollOrigin = [0, 0];
        this.boundingClientRect = null;
        this.scrollElement = scrollElement;
        this.iterationScrollX = 0;
        this.iterationScrollY = 0;
    }

    ScrollGroup.prototype.updateBounds = function () {
        this.scrollOrigin[0] = this.scrollElement.scrollLeft;
        this.scrollOrigin[1] = this.scrollElement.scrollTop;
        this.scrollDiff[0] = 0;
        this.scrollDiff[1] = 0;
        this.boundingClientRect = this.scrollElement.getBoundingClientRect();
    };

    ScrollGroup.prototype.processIteration = function () {
        this.scrollElement.scrollLeft += this.iterationScrollX;
        this.scrollElement.scrollTop += this.iterationScrollY;
        this.scrollDiff[0] = this.scrollElement.scrollLeft - this.scrollOrigin[0];
        this.scrollDiff[1] = this.scrollElement.scrollTop - this.scrollOrigin[1];
        this.iterationScrollX = 0;
        this.iterationScrollY = 0;
    };

    function NullScrollGroup() {
        ScrollGroup.call(this, arguments);
    }

    NullScrollGroup.prototype = Object.create(ScrollGroup);

    NullScrollGroup.prototype.update = function () { };

    return {
        ScrollGroup: ScrollGroup,
        NullScrollGroup: NullScrollGroup
    };

});

/*
 * 拖放功能
 */
h5.define('util/H5DragDrop', ["util/Object", "util/H5ScrollGroup","util/util"],
  function (Obj, ScrollGroup, util) {

      var SCROLL_INTERVAL = 16,
          DEFAULT_SCROLL_AMOUNT = 10,
          SCROLL_WINDOW = 10,
          MIN_SCROLL_ELEMENT_ONSCREEN_HEIGHT = 50,
          MIN_SCROLL_ELEMENT_ONSCREEN_WIDTH = 10,
          MAXIMUM_Z_INDEX = 2147483647,
          MIN_WIDTH = 15,
          RESIZABLE_CLASS = "butter-resizable";

      var NULL_FUNCTION = function () { };

      var DEFAULT_ONSTOP_DRAGGABLE_FUNCTION = function () { return false; };

      var __droppables = [],
          __mouseDown = false,
          __selectedDraggables = [],
          __mousePos = [0, 0],
          __mouseLast = [0, 0],
          __scroll = false,
          __helpers = [],
          __scrollGroups = [],
          __nullScrollGroup = new ScrollGroup.NullScrollGroup();

      // for what seems like a bug in chrome. :/
      // dataTransfer.getData seems to report nothing
      var __currentDraggingHelper;

      var __nullRect = {
          top: 0,
          left: 0,
          bottom: 0,
          right: 0
      };

      var dd = Obj.extend({
          init: function () {
              this._super();
          }
      });
      var H5DragDrop = new dd();

      //获取或创建元素滚动组
      function __getScrollGroup(scrollElement) {
          var i, newScrollGroup;

          if (scrollElement) {
              for (i = __scrollGroups.length - 1; i >= 0; --i) {
                  if (__scrollGroups[i].scrollElement === scrollElement) {
                      return __scrollGroups[i];
                  }
              }
              newScrollGroup = new ScrollGroup.ScrollGroup(scrollElement);
              __scrollGroups.push(newScrollGroup);
              return newScrollGroup;
          }
          else {
              return __nullScrollGroup;
          }
      }

      //拖动动画
      function __draggableUpdateTimeout(e) {
          var i, j,
              draggables = __selectedDraggables,
              draggable,
              droppable;

          if (!draggables.length) {
              __onDraggableMouseUp();
              return;
          }

          __scroll = false;

          if (__mouseDown) {
              for (i = __selectedDraggables.length - 1; i >= 0; --i) {
                  __selectedDraggables[i].update();
              }

              for (i = __scrollGroups.length - 1; i >= 0; --i) {
                  __scrollGroups[i].processIteration();
              }

              for (i = draggables.length - 1; i >= 0; --i) {
                  draggable = draggables[i];
                  draggable.drag(e);
                  for (j = __droppables.length - 1; j >= 0; --j) {
                      droppable = __droppables[j];
                      if (draggable.element === droppable.element ||
                          !droppable.drag(draggable.element.getBoundingClientRect())) {
                          droppable.forget(draggable,e);
                      }
                      else {
                          // If we stumbled on a valid droppable early in the array
                          // and the draggable has a droppable already that is, perhaps
                          // further along in the array, forcefully forget the draggable
                          // before telling another droppable to remember it.
                          if (draggable.droppable && draggable.droppable !== droppable) {
                              draggable.droppable.forget(draggable,e);
                          }
                          droppable.remember(draggable,e);
                          break;
                      }
                  }
              }

              window.setTimeout(function () {
                  __draggableUpdateTimeout(e);
              }, SCROLL_INTERVAL);
          }
      }

      //阻止默认拖动
      function __onWindowDragStart(e) {
          e.preventDefault();
      }

      //拖动中
      function __onDraggableDragged(e) {
          e.preventDefault();



          __mouseLast[0] = __mousePos[0];
          __mouseLast[1] = __mousePos[1];
          __mousePos = [e.clientX, e.clientY];

          var draggables = __selectedDraggables,
              i;

          // 第一次移动，触发开始拖动事件
          if (!__mouseDown) {
              __mouseDown = true;

              for (i = __scrollGroups.length - 1; i >= 0; --i) {
                  //更新滚动位置
                  __scrollGroups[i].updateBounds();
              }

              for (i = draggables.length - 1; i >= 0; --i) {
                  //开始
                  draggables[i].start(e);
              }

              __draggableUpdateTimeout(e);

              window.addEventListener("dragstart", __onWindowDragStart);

              H5DragDrop.dispatchEvent("dragstarted");
          }
      }

      function __onDraggableMouseUp(e) {
          window.removeEventListener("dragstart", __onWindowDragStart, false);
          window.removeEventListener("mousemove", __onDraggableDragged, false);
          window.removeEventListener("mouseup", __onDraggableMouseUp, false);

          if (!__mouseDown) {
              return;
          }


          H5DragDrop.dispatchEvent("dragstopped");

          __mouseDown = false;

          var selectedDraggable,
              selectedDraggables = __selectedDraggables.slice(),
              droppables = [],
              droppable,
              i;

          // Collect all the droppables
          for (i = selectedDraggables.length - 1; i >= 0; --i) {
              selectedDraggable = selectedDraggables[i];
              droppable = selectedDraggable.droppable;
              if (droppable && droppables.indexOf(droppable) === -1) {
                  droppables.push(droppable);
              }
          }

          // Let droppable know that it's about to receive one or more items
          for (i = droppables.length - 1; i >= 0; --i) {
              droppables[i].startDrop();
          }

          for (i = selectedDraggables.length - 1; i >= 0; --i) {
              selectedDraggable = selectedDraggables[i];
              selectedDraggable.stop();
          }

          for (i = selectedDraggables.length - 1; i >= 0; --i) {
              selectedDraggable = selectedDraggables[i];
              selectedDraggable.drop(e);
          }

          for (i = selectedDraggables.length - 1; i >= 0; --i) {
              selectedDraggable = selectedDraggables[i];
              selectedDraggable.reset();
          }

          // Let droppable know that we're done dropping
          for (i = droppables.length - 1; i >= 0; --i) {
              droppables[i].stopDrop();
          }

          H5DragDrop.dispatchEvent("dropfinished");
      }

      // 按下鼠标，开始拖拽
      function __onDraggableMouseDown(e) {
          // 只支持左键
          if (e.which !== 1 ) {
              __onDraggableMouseUp(e);
              return;
          }
          //阻止默认事件
          editor.media.pause();
          e.preventDefault();
          e.stopPropagation();
          __mousePos = [e.clientX, e.clientY];
          window.addEventListener("mousemove", __onDraggableDragged);
          window.addEventListener("mouseup", __onDraggableMouseUp);
      }

      function __getPaddingRect(element) {
          var style = getComputedStyle(element),
                top = style.getPropertyValue("padding-top"),
                left = style.getPropertyValue("padding-left"),
                bottom = style.getPropertyValue("padding-bottom"),
                right = style.getPropertyValue("padding-right");

          return {
              top: Number(top.substring(0, top.indexOf("px"))),
              left: Number(left.substring(0, left.indexOf("px"))),
              bottom: Number(bottom.substring(0, bottom.indexOf("px"))),
              right: Number(right.substring(0, right.indexOf("px")))
          };
      }

      function __checkParent(parent, child) {
          var parentNode = child.parentNode;
          while (parentNode) {
              if (parentNode === parent) {
                  return true;
              }
              parentNode = parentNode.parentNode;
          }
          return false;
      }

      function __getHighestZIndex(element) {
          var z = getComputedStyle(element).zIndex;
          if (isNaN(z)) {
              z = 0;
              var parentNode = element.parentNode;
              while (parentNode && [window, document].indexOf(parentNode) === -1) {
                  var style = getComputedStyle(parentNode);
                  if (style) {
                      var nextZ = style.zIndex;
                      if (isNaN(nextZ) && nextZ > z) {
                          z = nextZ;
                      }
                  }
                  parentNode = parentNode.parentNode;
              }
          }
      }

      function __sortDroppables() {
          __droppables = __droppables.sort(function (a, b) {

              var elementA = a.element,
                  elementB = b.element,
                  zA = __getHighestZIndex(elementA),
                  zB = __getHighestZIndex(elementB);

              if (__checkParent(elementA, elementB)) {
                  return -1;
              }
              else if (__checkParent(elementB, elementA)) {
                  return 1;
              }

              return zA - zB;
          });
      }

      function Resizable(element, options) {
          var _leftHandle = element.querySelector(".handle.left-handle"),
              _rightHandle = element.querySelector(".handle.right-handle"),
              _onStart = options.start || NULL_FUNCTION,
              _onStop = options.stop || NULL_FUNCTION,
              app = options.app,
              _onResize = options.resize || NULL_FUNCTION,
              _padding = options.padding || 0,
              _updateInterval = -1,
              _scroll = options.scroll,
              _scrollRect,
              _elementRect,
              _lastDims,
              _iterationBlockX,
              _resizeEvent = {                                                      // Exposed on callbacks of Resizable

                  /**
                   * blockIteration
                   *
                   * Blocks one iteration of the resize loop at the specified value. This function will be exposed and be active
                   * on the `resize` callback of a Resizable.
                   *
                   * @param {Number} value: The value at which resizing should be stopped. For resizing start by the right-handle,
                   *                        this is treated as a width value. For the left-handle, it's a left value.
                   */
                  blockIteration: function (value) {
                      _iterationBlockX = value;
                  },
                  direction: null,
                  altKey: false,
                  ctrlKey: false,
                  metaKey: false,
                  shiftKey: false
              };

          function onLeftMouseDown(e) {
              // Stop text selection in chrome.
              app.media.pause();
              e.preventDefault();
              e.stopPropagation();

              var originalRect = element.getBoundingClientRect(),
                  originalPosition = element.offsetLeft,
                  originalWidth = element.clientWidth,
                  mouseDownPosition = e.clientX,
                  mousePosition,
                  mouseOffset;

              function update() {
                  var diff = mousePosition - mouseDownPosition,
                      newX = originalPosition + diff,
                      newW = originalWidth - diff;

                  // At the beginning of this iteration, _iterationBlockX should be null, assuming no block occured.
                  _iterationBlockX = null;

                  if (newW < MIN_WIDTH) {
                      return;
                  }

                  if (_scroll && _scroll.scrollLeft > 0) {
                      if (originalRect.left + diff < _scrollRect.left - SCROLL_WINDOW) {
                          _scroll.scrollLeft -= DEFAULT_SCROLL_AMOUNT;
                          newX -= DEFAULT_SCROLL_AMOUNT;
                          newW += DEFAULT_SCROLL_AMOUNT;
                          mouseDownPosition += DEFAULT_SCROLL_AMOUNT;
                      }
                  }

                  //if (newX < 0) {
                  //    newW += newX;
                  //    newX = 0;
                  //}

                  // If the size actually changed, use the _onResize callback to notify handlers of this Resizable,
                  // and expose the opportunity to block this iteration from actually resizing the element.
                  if (_lastDims[0] !== newX || _lastDims[1] !== newW) {
                      _onResize(newX, newW, _resizeEvent);
                  }

                  // If _iterationBlockX is non-null, this iteration was meant to be blocked at that value. Since
                  // we're resizing wrt the left side of the element here, _iterationBlockX is used to find the
                  // left side of the resizing element, and subsequently, a corresponding width value.
                  if (_iterationBlockX === null) {
                      element.style.left = newX + "px";
                      element.style.width = newW + _padding + "px";
                      _elementRect = element.getBoundingClientRect();

                      _lastDims[0] = newX;
                      _lastDims[1] = newW;
                  }
                  else {
                      newX = _iterationBlockX;
                      newW = originalWidth + (originalPosition - newX);   //_iterationBlockX - originalPosition;

                      element.style.left = newX + "px";
                      element.style.width = newW + _padding + "px";
                      _elementRect = element.getBoundingClientRect();

                      _lastDims[0] = newX;
                      _lastDims[1] = newW;
                  }
                  //if ($(element).siblings().length > 0) {
                  //    var changwidth = originalPosition + newW - $(element).next().position().left;
                  //    $(element).siblings().each(function () {
                  //        if ($(this).position().left > $(element).position().left) {
                  //            $(this).css("left", $(this).position().left + changwidth);
                  //        }
                  //    });
                  //}
                  //app.undo.push('resize gc');
                          }

              function onMouseUp() {
                  window.removeEventListener("mousemove", onMouseMove, false);
                  window.removeEventListener("mouseup", onMouseUp, false);
                  clearInterval(_updateInterval);
                  _updateInterval = -1;
                  _onStop(_resizeEvent);
                  app.undo.push('resize');
                  element.classList.remove(RESIZABLE_CLASS);
                  //DragNDrop.dispatch("resizestopped");
              }

              function onMouseMove(e) {
                  e.preventDefault();
                  mousePosition = e.clientX;

                  _resizeEvent.altKey = e.altKey;
                  _resizeEvent.ctrlKey = e.ctrlKey;
                  _resizeEvent.metaKey = e.metaKey;
                  _resizeEvent.shiftKey = e.shiftKey;

                  if (_updateInterval === -1) {
                      _lastDims = [];
                      _resizeEvent.direction = "left";
                      _updateInterval = setInterval(update, SCROLL_INTERVAL);
                      _onStart(_resizeEvent);
                  }
              }

              _elementRect = element.getBoundingClientRect();
              mouseOffset = e.clientX - _elementRect.left;
              _scrollRect = _scroll.getBoundingClientRect();

              element.classList.add(RESIZABLE_CLASS);

              window.addEventListener("mousemove", onMouseMove);
              window.addEventListener("mouseup", onMouseUp);

              H5DragDrop.dispatchEvent("resizestarted");
          }

          function onRightMouseDown(e) {
              // Stop text selection in chrome.
              app.media.pause();
              e.preventDefault();
              e.stopPropagation();

              var originalPosition = element.offsetLeft,
                  originalWidth = element.offsetWidth,
                  mouseDownPosition = e.clientX,
                  mousePosition,
                  mouseOffset;

              function update() {
                  var diff = mousePosition - mouseDownPosition,
                      newW = originalWidth + diff;

                  // At the beginning of this iteration, _iterationBlockX should be null, assuming no block occured.
                  _iterationBlockX = null;

                  if (newW < MIN_WIDTH) {
                      return;
                  }

                  if (_scroll && _scroll.scrollLeft < _scroll.scrollWidth - _scrollRect.width) {
                      if (mousePosition > _scrollRect.right + SCROLL_WINDOW) {
                          _scroll.scrollLeft += DEFAULT_SCROLL_AMOUNT;
                          mouseDownPosition -= DEFAULT_SCROLL_AMOUNT;
                      }
                  }

                  if (newW + originalPosition > element.offsetParent.offsetWidth) {
                      newW = element.offsetParent.offsetWidth - originalPosition;
                  }

                  // If the size actually changed, use the _onResize callback to notify handlers of this Resizable,
                  // and expose the opportunity to block this iteration from actually resizing the element.
                  if (_lastDims[1] !== newW) {
                      _onResize(originalPosition, newW, _resizeEvent);
                  }

                  // If _iterationBlockX is non-null, this iteration was meant to be blocked at that value. Since
                  // we're resizing wrt the right side of the element here, _iterationBlockX is used to find the
                  // width of the resizing element.
                  if (_iterationBlockX === null) {
                      element.style.width = newW + "px";
                      _elementRect = element.getBoundingClientRect();
                      _lastDims[1] = newW;
                  }
                  else {
                      newW = _iterationBlockX - originalPosition;
                      element.style.width = newW + "px";
                      _elementRect = element.getBoundingClientRect();
                      _lastDims[1] = newW;
                  }
                  //if ($(element).siblings().length > 0) {
                  //    var changwidth = originalPosition + newW - $(element).next().position().left;
                  //    $(element).siblings().each(function () {
                  //        if ($(this).position().left > $(element).position().left) {
                  //            $(this).css("left", $(this).position().left + changwidth);
                  //        }
                  //    });
                  //}
                          }

              function onMouseUp() {
                  window.removeEventListener("mousemove", onMouseMove, false);
                  window.removeEventListener("mouseup", onMouseUp, false);
                  clearInterval(_updateInterval);
                  _updateInterval = -1;
                  _onStop(_resizeEvent);
                  app.undo.push("resize pic");
                  element.classList.remove(RESIZABLE_CLASS);
                  H5DragDrop.dispatchEvent("resizestopped");
              }

              function onMouseMove(e) {
                  mousePosition = e.clientX;
                  _resizeEvent.altKey = e.altKey;
                  _resizeEvent.ctrlKey = e.ctrlKey;
                  _resizeEvent.metaKey = e.metaKey;
                  _resizeEvent.shiftKey = e.shiftKey;

                  if (_updateInterval === -1) {
                      _lastDims = [];
                      _resizeEvent.direction = "right";

                      _updateInterval = setInterval(update, SCROLL_INTERVAL);
                      _onStart(_resizeEvent);
                  }
              }

              _elementRect = element.getBoundingClientRect();
              if (_scroll) {
                  _scrollRect = _scroll.getBoundingClientRect();
              }
              mouseOffset = e.clientX - _elementRect.left;

              element.classList.add(RESIZABLE_CLASS);

              window.addEventListener("mousemove", onMouseMove);
              window.addEventListener("mouseup", onMouseUp);

              H5DragDrop.dispatchEvent("resizestarted");
          }

          _leftHandle.addEventListener("mousedown", onLeftMouseDown);
          _rightHandle.addEventListener("mousedown", onRightMouseDown);

          return {
              destroy: function () {
                  _leftHandle.removeEventListener("mousedown", onLeftMouseDown, false);
                  _rightHandle.removeEventListener("mousedown", onRightMouseDown, false);
              }
          };
      }

      function Helper(element, options) {
          options = options || {};
          var _image = options.image,
              _onStart = options.start || NULL_FUNCTION,
              _onStop = options.stop || NULL_FUNCTION,
              _id = __helpers.length;

          __helpers[_id] = {
              element: element,
              pluginOptions: options.pluginOptions
          };

          element.setAttribute("draggable", true);

          element.addEventListener("dragstart", function (e) {
              //__currentDraggingHelper = {
              //    element: element,
              //    pluginOptions: options.pluginOptions
              //};
              // document.querySelector(".hoverifm").style.display = "block";
              __currentDraggingHelper = __helpers[_id];
              e.dataTransfer.effectAllowed = "all";
              //e.dataTransfer.setDragImage($("<div></div>")[0], 0, 0);

              _onStart(e, __helpers[_id]);

              var cur = __helpers[_id];

              e.dataTransfer.setData("text", JSON.stringify(cur.data));
             // var ele = e.target.querySelector('.list-icon');
             // if(ele){
                 // e.dataTransfer.setDragImage(ele, ele.clientWidth / 2, ele.clientHeight / 2);
             // }
              // coerce to string so IE9 doesn't throw
              //e.dataTransfer.setData("text", _id + "");
              //if (_image) {
              //    var img = document.createElement("img");
              //    img.src = _image.src;
              //    e.dataTransfer.setDragImage(img, img.width / 2, img.height / 2);
              //}

          });

          element.addEventListener("dragend", function (e) {
              // document.querySelector(".hoverifm").style.display = "none";
              __currentDraggingHelper = null;
              _onStop(e, __helpers[_id]);
          });

          element.addEventListener("drop", function () {
          });

          return __helpers[_id];
      }

      function ClearHelpers() {
          __helpers = [];
      }

      function Droppable(element, options) {
          options = options || {};
          var _hoverClass = options.hoverClass,
              _onDrop = options.drop || NULL_FUNCTION,
              _onOver = options.over || NULL_FUNCTION,
              _canDrop = options.candrop || function () { return true },
              _onOut = options.out || NULL_FUNCTION,
              _onStartDrop = options.startDrop || NULL_FUNCTION,
              _onStopDrop = options.stopDrop || NULL_FUNCTION,
              _droppable = {},
              _data = options.data,
              _rememberedDraggables = [];

          function onDrop(e) {
              var transferData, helper;
              e.stopPropagation();
              e.preventDefault();

              if (_hoverClass) {
                  element.classList.remove(_hoverClass);
              }
              try {
                  transferData = e.dataTransfer.getData("text");
              } catch (err) {
                  return;
              }
              helper = __helpers[transferData] || __currentDraggingHelper;
              if (!helper) {
                  var dataObj = JSON.parse(transferData);
                  _onDrop(dataObj, [e.clientX, e.clientY], null, e);
              }
              if (helper) {
                  _onDrop(helper, [e.clientX, e.clientY]);
              }
          }

          function onDragOver(e) {


              if (_canDrop(e, [e.clientX, e.clientY], __currentDraggingHelper)) {
                  e.preventDefault();
                  e.stopPropagation();
                  e.dataTransfer.dropEffect = "copy";
              }
          }

          function onDragEnter(e) {

              $('#mv').trigger("click");
              var transferData, helper;
              if (_hoverClass) {
                  element.classList.add(_hoverClass);
              }
              try {
                  // This can throw a "SecurityError: The operation is insecure."
                  // error if dataTransfer.effectAllowed is "uninitialized".
                  // Unfortunately, checking effectAllowed in ie9 throws
                  // a "Unexpected call to method or property access."
                  transferData = e.dataTransfer.getData("text");
              } catch (err) {
                  return;
              }
              helper = __helpers[transferData] || __currentDraggingHelper;
              if (helper) {
                  _onOver(helper, [e.clientX, e.clientY]);
              }
          }

          function onDragLeave(e) {
              var transferData, helper;
              if (_hoverClass) {
                  element.classList.remove(_hoverClass);
              }
              try {
                  // This can throw a "SecurityError: The operation is insecure."
                  // error if dataTransfer.effectAllowed is "uninitialized".
                  // Unfortunately, checking effectAllowed in ie9 throws
                  // a "Unexpected call to method or property access."
                  transferData = e.dataTransfer.getData("text");
              } catch (err) {
                  return;
              }
              helper = __helpers[transferData] || __currentDraggingHelper;
              if (helper) {
                  _onOut(helper, [e.clientX, e.clientY],e);
              } else {
                  _onOut(null, [e.clientX, e.clientY],e);
              }
          }

          element.addEventListener("drop", onDrop);
          element.addEventListener("dragover", onDragOver);
          element.addEventListener("dragenter", onDragEnter);
          element.addEventListener("dragleave", onDragLeave);

          function removeDraggable(draggable) {
              var idx = _rememberedDraggables.indexOf(draggable);
              if (idx > -1) {
                  _rememberedDraggables.splice(idx, 1);
                  if (_rememberedDraggables.length === 0) {
                      element.classList.remove(_hoverClass);
                  }
              }
              return idx > -1;
          }

          _droppable = {
              element: element,
              startDrop: _onStartDrop,
              stopDrop: _onStopDrop,
              remember: function (draggable, e) {
                  var idx = _rememberedDraggables.indexOf(draggable);
                  if (idx === -1) {
                      _rememberedDraggables.push(draggable);
                      element.classList.add(_hoverClass);
                      draggable.droppable = _droppable;
                      _onOver(null, draggable.element, e);
                  }
              },
              forget: function (draggable, e) {
                  if (removeDraggable(draggable)) {
                      draggable.droppable = null;
                      _onOut(null, draggable.element, e);
                  }
              },
              drop: function (draggable, e) {
                  if (removeDraggable(draggable)) {
                      _onDrop(draggable, __mousePos, null, e);
                  }
              },
              drag: function (dragElementRect) {
                  var rect = element.getBoundingClientRect();

                  var maxL = Math.max(dragElementRect.left, rect.left),
                      maxT = Math.max(dragElementRect.top, rect.top),
                      minR = Math.min(dragElementRect.right, rect.right),
                      minB = Math.min(dragElementRect.bottom, rect.bottom);

                  if (minR < maxL || minB < maxT) {
                      return false;
                  }

                  // TODO: to check for half x-axis overlap
                  // use ( minR - maxL ) > dragElementRect.width / 2
                  // or height * width / 2 for area check.
                  if ((minB - maxT) > dragElementRect.height / 2) {
                      return true;
                  }

                  return false;
              },
              destroy: function () {
                  var idx = __droppables.indexOf(_droppable);
                  if (idx > -1) {
                      __droppables.splice(idx, 1);
                  }
                  element.removeEventListener("drop", onDrop, false);
                  element.removeEventListener("dragover", onDragOver, false);
                  element.removeEventListener("dragenter", onDragEnter, false);
                  element.removeEventListener("dragleave", onDragLeave, false);
              }
          };

          Object.defineProperties(_droppable, {
              data: {
                  enumerable: true,
                  get: function () {
                      return _data;
                  }
              }
          });

          __droppables.push(_droppable);
          __sortDroppables();

          return _droppable;
      }

      function Draggable(element, options) {
          options = options || {};

          var _containment = options.containment,
              _scrollGroup = __getScrollGroup(options.scroll),
              _xAxis = !options.axis || options.axis.indexOf("x") > -1 ? true : false,
              _yAxis = !options.axis || options.axis.indexOf("y") > -1 ? true : false,
              _xOffsetBounds = [],
              _yOffsetBounds = [],
              _xOffsetScrollBounds = [],
              _yOffsetScrollBounds = [],
              _draggingPositionOffset = [],
              _revert = options.revert,
              _mouseOffset = [0, 0],
              _element = element,
              _elementRect,
              _scrollAmount = options.scrollAmount || DEFAULT_SCROLL_AMOUNT,
              _oldZIndex,
              _onStart = options.start || NULL_FUNCTION,
              _onStop = options.stop || DEFAULT_ONSTOP_DRAGGABLE_FUNCTION,
              _onDrag = options.drag || NULL_FUNCTION,
              _originalPosition,
              _draggable = {},
              _data = options.data,
              _containmentPadding = __nullRect,
              _diffRect = {
                  top: 0, bottom: 0, left: 0, right: 0
              };

          if (_containment) {
              _containmentPadding = __getPaddingRect(_containment);
          }

          _draggable.updateRects = function () {
              var containmentRect, scrollRect;

              //拖动项的位置
              _elementRect = element.getBoundingClientRect();

              if (_containment) {
                  //容器位置
                  containmentRect = _containment.getBoundingClientRect();

                  _xOffsetBounds[0] = containmentRect.left - _elementRect.left;
                  _xOffsetBounds[1] = containmentRect.right - _elementRect.right;
                  _yOffsetBounds[0] = containmentRect.top - _elementRect.top;
                  _yOffsetBounds[1] = containmentRect.bottom - _elementRect.bottom;
              }

              if (_scrollGroup) {
                  //滚动上层容器位置
                  scrollRect = _scrollGroup.boundingClientRect;
                  _xOffsetScrollBounds[0] = scrollRect.left - _elementRect.left - _elementRect.width + MIN_SCROLL_ELEMENT_ONSCREEN_WIDTH;
                  _xOffsetScrollBounds[1] = scrollRect.right - _elementRect.right + _elementRect.width - MIN_SCROLL_ELEMENT_ONSCREEN_WIDTH;
                  _yOffsetScrollBounds[0] = scrollRect.top - _elementRect.top + _elementRect.height - MIN_SCROLL_ELEMENT_ONSCREEN_HEIGHT;
                  _yOffsetScrollBounds[1] = scrollRect.bottom - _elementRect.bottom - _elementRect.height + MIN_SCROLL_ELEMENT_ONSCREEN_HEIGHT;
              }
          };

          function updatePosition() {
              //当前鼠标位置 减去 开始时鼠标位置 加上已滚动位移
              var x = __mousePos[0] - _mouseOffset[0] + _scrollGroup.scrollDiff[0],
                  y = __mousePos[1] - _mouseOffset[1] + _scrollGroup.scrollDiff[1];

              // Only accept offsets for axes for which we need to provide movement
              _draggingPositionOffset[0] = _xAxis ? x : 0;
              _draggingPositionOffset[1] = _yAxis ? y : 0;
          }

          function checkScroll() {
              var scrollRect;
              scrollRect = _scrollGroup.boundingClientRect;

              // 鼠标大于包裹元素右侧+
              if (_xAxis) {
                  if (__mousePos[0] > scrollRect.right + SCROLL_WINDOW) {
                      __scroll = true;
                      _scrollGroup.iterationScrollX = _scrollAmount;
                  }
                  else if (__mousePos[0] < scrollRect.left - SCROLL_WINDOW) {
                      __scroll = true;
                      _scrollGroup.iterationScrollX = -_scrollAmount;
                  }
              }

              if (_yAxis) {
                  if (__mousePos[1] > scrollRect.bottom + SCROLL_WINDOW) {
                      __scroll = true;
                      _scrollGroup.iterationScrollY = _scrollAmount;
                  }
                  else if (__mousePos[1] < scrollRect.top - SCROLL_WINDOW) {
                      __scroll = true;
                      _scrollGroup.iterationScrollY = -_scrollAmount;
                  }
              }
          }

          function checkContainment() {
              var x = _draggingPositionOffset[0],
                  y = _draggingPositionOffset[1];

              if ( _yAxis) {

                  // If the y scrolling bound is crossed, lock the element's y movement.
                  if (y < _yOffsetScrollBounds[0] + _scrollGroup.scrollDiff[1]) {
                      y = _yOffsetScrollBounds[0] + _scrollGroup.scrollDiff[1] + _scrollGroup.iterationScrollY;
                  }
                  else if (y > _yOffsetScrollBounds[1] + _scrollGroup.scrollDiff[1]) {
                      y = _yOffsetScrollBounds[1] + _scrollGroup.scrollDiff[1] + _scrollGroup.iterationScrollY;
                  }

                  // If the y containment bound is crossed, lock the element's y movement.
                  if (y < _yOffsetBounds[0]) {
                      y = _yOffsetBounds[0];
                  }
                  else if (y > _yOffsetBounds[1]) {
                      y = _yOffsetBounds[1];
                  }

                  // Store the adjusted y value.
                  _draggingPositionOffset[1] = y;
              }

              // If x axis is allowed to move, check it.
              if ( _xAxis) {

                  // If the x scrolling bound is crossed, lock the element's x movement.
                  if (x < _xOffsetScrollBounds[0] + _scrollGroup.scrollDiff[0]) {
                      x = _xOffsetScrollBounds[0] + _scrollGroup.scrollDiff[0] + _scrollGroup.iterationScrollX;
                  }
                  else if (x > _xOffsetScrollBounds[1] + _scrollGroup.scrollDiff[0]) {
                      x = _xOffsetScrollBounds[1] + _scrollGroup.scrollDiff[0] + _scrollGroup.iterationScrollX;
                  }

                  // If the x containment bound is crossed, lock the element's x movement.
                  if (x < _xOffsetBounds[0]) {
                      x = _xOffsetBounds[0];
                  }
                  else if (x > _xOffsetBounds[1]) {
                      x = _xOffsetBounds[1];
                  }

                  // Store the adjusted x value.
                  _draggingPositionOffset[0] = x;
              }
          }

          element.addEventListener("mousedown", __onDraggableMouseDown);

          _draggable.droppable = null;

          _draggable.destroy = function () {
              _draggable.selected = false;
              element.removeEventListener("mousedown", __onDraggableMouseDown, false);
          };

          _draggable.update = function () {
              // Find new potential (x,y) for element.
              updatePosition();

              // 是否需要滚动
              if (_scrollGroup) {
                  checkScroll();
              }

              if (_containment) {
                  checkContainment();
              }

              // Set the transform on element.
            //  console.log(_draggingPositionOffset[0]);
              util.setTransformProperty(element, "translate(" + _draggingPositionOffset[0] + "px, " + _draggingPositionOffset[1] + "px)");

              // Set values for diffRect so that position updates are easily reported to listeners.
              _diffRect.top = _elementRect.top + _draggingPositionOffset[1] - _scrollGroup.scrollDiff[1];
              _diffRect.bottom = _elementRect.bottom + _draggingPositionOffset[1] - _scrollGroup.scrollDiff[1];
              _diffRect.left = _elementRect.left + _draggingPositionOffset[0] - _scrollGroup.scrollDiff[0];
              _diffRect.right = _elementRect.right + _draggingPositionOffset[0] - _scrollGroup.scrollDiff[0];
          };

          _draggable.getLastRect = function () {
              return _diffRect;
          };

          _draggable.getLastOffset = function () {
              return _draggingPositionOffset;
          };

          _draggable.start = function (e) {
              _oldZIndex = getComputedStyle(element).getPropertyValue("z-index");
              element.style.zIndex = MAXIMUM_Z_INDEX;
              //原始滚动位置
              _originalPosition = [element.offsetLeft, element.offsetTop];
              _mouseOffset = [e.clientX, e.clientY];

              //通知拖拽开始
              _onStart(e);

              _draggable.updateRects();

              updatePosition();
          };

          _draggable.drag = function (e) {
              if (_draggable.droppable) {
                  _onDrag(_draggable, _draggable.droppable, e);
              }
          };

          _draggable.drop = function (e) {
              if (_draggable.droppable) {
                  _draggable.droppable.drop(_draggable, e);
              }
          };

          _draggable.stop = function (e) {
              element.style.zIndex = _oldZIndex;
              // If originalPosition is not null, start() was called
              if (_originalPosition) {
                  util.setTransformProperty(_element, "");
                  _onStop(e);
              }
          };

          _draggable.reset = function () {
              if (!_draggable.droppable && _revert && _originalPosition) {
                  element.style.left = _originalPosition[0] + "px";
                  element.style.top = _originalPosition[1] + "px";
              }
              _draggable.droppable = null;
              _originalPosition = null;
          };

          Object.defineProperties(_draggable, {
              data: {
                  enumerable: true,
                  get: function () {
                      return _data;
                  }
              },
              selected: {
                  enumerable: true,
                  get: function () {
                      for (var i = __selectedDraggables.length - 1; i >= 0; --i) {
                          if (__selectedDraggables[i].element === _element) {
                              return true;
                          }
                      }
                      return false;
                  },
                  set: function (val) {
                      if (val) {
                          __selectedDraggables.push(_draggable);
                      }
                      else {
                          for (var i = __selectedDraggables.length - 1; i >= 0; --i) {
                              if (__selectedDraggables[i].element === _element) {
                                  __selectedDraggables.splice(i, 1);
                                  return;
                              }
                          }
                      }
                  }
              },
              element: {
                  enumerable: true,
                  get: function () {
                      return _element;
                  }
              }
          });

          return _draggable;
      }

      function Sortable(parentElement, options) {

          var _onChange = options.change || NULL_FUNCTION,
              _items = {},
              _elements = [],
              _instance = {},
              _mouseDownPosition = 0,
              _draggingElement,
              _draggingOriginalPosition,
              _moved,
              _hoverElement,
              _placeHolder,
              _oldZIndex;

          function Item(element, handle) {
              var _this = this;
              this.element = element;
              this.handle = handle || element;

              function onElementMouseMove(e) {
                  if (!_moved) {
                      _moved = true;
                      _placeHolder = createPlaceholder(_draggingElement);
                      parentElement.appendChild(_draggingElement);
                      _draggingElement.style.position = "absolute";
                      _draggingElement.style.zIndex = MAXIMUM_Z_INDEX;
                      positionElement(0);
                  } else {
                      var diff = _mouseDownPosition - e.clientY;
                      positionElement(diff);
                      var dragElementRect = _draggingElement.getBoundingClientRect();
                      for (var i = _elements.length - 1; i >= 0; --i) {
                          var element = _elements[i];

                          if (element === _draggingElement) {
                              continue;
                          }

                          var rect = element.getBoundingClientRect();

                          var maxL = Math.max(dragElementRect.left, rect.left),
                              maxT = Math.max(dragElementRect.top, rect.top),
                              minR = Math.min(dragElementRect.right, rect.right),
                              minB = Math.min(dragElementRect.bottom, rect.bottom);

                          if (minR < maxL || minB < maxT) {
                              continue;
                          }

                          if (minB - maxT > dragElementRect.height / 2) {
                              _hoverElement = element;
                              var newPlaceHolder = createPlaceholder(_hoverElement);
                              parentElement.replaceChild(_hoverElement, _placeHolder);
                              _placeHolder = newPlaceHolder;
                              var orderedElements = [],
                                  childNodes = parentElement.childNodes;
                              for (var j = 0, l = childNodes.length; j < l; ++j) {
                                  var child = childNodes[j];
                                  if (child !== _draggingElement) {
                                      if (child !== _placeHolder) {
                                          orderedElements.push(child);
                                      } else {
                                          orderedElements.push(_draggingElement);
                                      }
                                  }
                              }
                              _onChange(orderedElements);
                          }
                      }
                  }
              }

              function onElementMouseDown(e) {
                  // Stop text selection in chrome.
                  e.preventDefault();
                  if (e.which !== 1) {
                      return;
                  }
                  _moved = false;
                  _draggingElement = _this.element;
                  _draggingOriginalPosition = _draggingElement.offsetTop;

                  var style = getComputedStyle(_draggingElement);

                  _oldZIndex = style.getPropertyValue("z-index");
                  _mouseDownPosition = e.clientY;

                  window.addEventListener("mouseup", onElementMouseUp);
                  window.addEventListener("mousemove", onElementMouseMove);

                  H5DragDrop.dispatchEvent("sortstarted", e);
              }

              function onElementMouseUp() {
                  _draggingElement.style.zIndex = _oldZIndex - 1;
                  window.removeEventListener("mouseup", onElementMouseUp, false);
                  window.removeEventListener("mousemove", onElementMouseMove, false);
                  _moved = false;
                  if (_placeHolder) {
                      _draggingElement.style.zIndex = "";
                      _draggingElement.style.position = "";
                      _draggingElement.style.top = "";
                      parentElement.replaceChild(_draggingElement, _placeHolder);
                      _placeHolder = null;
                  }
                  H5DragDrop.dispatchEvent("sortstopped");
              }
              this.handle.addEventListener("mousedown", onElementMouseDown);
              this.destroy = function () {
                  this.handle.removeEventListener("mousedown", onElementMouseDown, false);
              };
          }

          function createPlaceholder(victim) {
              var placeholder = victim.cloneNode(false);
              placeholder.classList.add("placeholder");
              parentElement.replaceChild(placeholder, victim);
              return placeholder;
          }

          function positionElement(diff) {
              _draggingElement.style.top = _draggingOriginalPosition - diff + "px";
          }

          _instance.addItem = function (id, options) {
              _items[id] = new Item(options.item, options.handle);
              _elements.push(options.item);
          };

          _instance.removeItem = function (id) {
              _elements.splice(_elements.indexOf(_items[id].element), 1);
              _items[id].destroy();
              delete _items[id];
          };

          return _instance;
      }

      H5DragDrop.draggable = Draggable;
      H5DragDrop.droppable = Droppable;
      H5DragDrop.helper = Helper;
      H5DragDrop.clear = ClearHelpers;
      H5DragDrop.resizable = Resizable;
      H5DragDrop.sortable = Sortable;

      Object.defineProperties(H5DragDrop, {
          isDragging: {
              get: function () {
                  return __mouseDown;
              }
          }
      });



      return H5DragDrop;

  });
/*
 * H5TrackEvent使用的布局模板
 */
h5.define('templates/H5TrackEventLayout', [], function ()
{
    return '<div class="track-event" data-draggable-type="trackevent">\
    <div class="track-event-info">\
        <div class="splitWrapper">\
            <div class="split"></div>\
        </div>\
        <span class="track-event-icon"></span>\
        <div class="title"></div>\
    </div>\
    <div class="handle left-handle"></div>\
    <div class="handle right-handle"></div>\
</div>';
});
/*
 * 表示某一轨上的某一项
 */
h5.define('timeline/H5TrackEvent', ["jquery","util/Object", "util/util",
           "util/H5DragDrop",
           "templates/H5TrackEventLayout"],
  function ($, Obj, util, H5DragDrop, H5_TRACKEVENT_LAYOUT) {

      // 项的最小宽度
      var TRACKEVENT_MIN_WIDTH = 50;

      var H5TrackEvent = Obj.extend({
          init: function (app, trackEvent, type, inputOptions) {
              var _element = $(H5_TRACKEVENT_LAYOUT)[0],
              _type = type,
             // _icon = document.getElementById(_type + "-icon"),
             _iconUrl = inputOptions.icon,
              _start = inputOptions.start || 0,
              _end = inputOptions.end || _start + 1,
              _parent,
              _handles,
              _typeElement = _element.querySelector(".title"),
              _splitWrapper = _element.querySelector(".splitWrapper"),
              _split = _element.querySelector(".split"),
              _draggable,
              _resizable,
              _trackEvent = trackEvent,
              _dragging = false,
              _resizing = false,
              _padding = 0,
              _elementText,
              _shadow,
              _onDrag,
              _onResize,
              _this = this;

              this._super();

              function resetContainer() {
                  if (!_trackEvent.track || !_trackEvent.track._media) {
                      return;
                  }
                  if (_trackEvent.track.view.element !== _element.parentNode) {
                      _trackEvent.track.view.element.appendChild(_element);
                  }

                  var left = app.timeToPixel(_start * 1000);
                  var width = app.timeToPixel((_end - _start)*1000);

                  _element.style.left = left + "px";
                  _element.style.width = width + "px";

                  if (_trackEvent.plugin.showSplit &&
                      _trackEvent.plugin.showSplit(app, _trackEvent)) {
                      var v = _trackEvent.plugin.splitValue(app, _trackEvent);
                      var h = $(_element).height();
                      var curTop = h * (1 - v);
                      var _top = parseFloat($(_splitWrapper).css("top"));
                      if (_top != curTop) {
                          $(_splitWrapper).css({ top: curTop + 'px' })
                      }
                  } else {
                      $(_splitWrapper).hide();
                  }

                  _this.setResizeArrows();
              }

              this.setResizeArrows = function () {
                  if (_element.offsetWidth < TRACKEVENT_MIN_WIDTH) {
                      _element.classList.add("trackevent-small");
                  } else {
                      _element.classList.remove("trackevent-small");
                  }
              };

              this.update = function (options) {
                  options = options || {};
                  _element.style.top = "0px";
                  if (!isNaN(options.start)) {
                      _start = options.start;
                  }
                  if (!isNaN(options.end)) {
                      _end = options.end;
                  }
                  resetContainer();
              };


              _element.addEventListener("click", function (e) {
                  e.stopPropagation();
                  return false;
              });

              /*
               * 创建一个拖动时的影子
               */
              this.createShadow = function (left) {
                  if (_shadow) {
                      return _shadow;
                  }

                  var clone = _element.cloneNode(false);
                  clone.style.top = "";

                  if (left || left === 0) {
                      clone.style.left = left + "px";
                  } else {
                      clone.style.left = _element.style.left;
                  }
                  clone.classList.add("track-event-shadow");
                  util.setTransformProperty(clone, "");

                  _shadow = {
                      element: clone
                  };

                  return _shadow;
              };

              /*
               * 清除影子
               */
              this.cleanupShadow = function () {
                  _shadow.track.view.removeTrackEventShadow(_shadow);
                  _shadow = null;
              };

              this.updateShadow = function () {
                  util.setTransformProperty(_shadow.element, "translate(" + _draggable.getLastOffset()[0] + "px, 0px)");
              };

              this.setDragHandler = function (dragHandler) {
                  _onDrag = dragHandler;
              };

              this.setResizeHandler = function (resizeHandler) {
                  _onResize = resizeHandler;
              };

              Object.defineProperties(this, {
                  trackEvent: {
                      enumerable: true,
                      get: function () {
                          return _trackEvent;
                      }
                  },
                  shadow: {
                      enumerable: true,
                      get: function () {
                          return _shadow;
                      }
                  },
                  element: {
                      enumerable: true,
                      get: function () { return _element; }
                  },
                  start: {
                      enumerable: true,
                      get: function () { return _start; },
                      set: function (val) {
                          _start = val;
                          resetContainer();
                      }
                  },
                  end: {
                      enumerable: true,
                      get: function () { return _end; },
                      set: function (val) {
                          _end = val;
                          resetContainer();
                      }
                  },
                  type: {
                      enumerable: true,
                      get: function () { return _type; },
                      set: function (val) {
                          _type = val;
                          _element.setAttribute("data-trackevent-type", _type);
                      }
                  },
                  elementText: {
                      enumerable: true,
                      get: function () {
                          return _elementText;
                      },
                      set: function (val) {
                          _elementText = val;
                          _typeElement.innerHTML =  _elementText;
                      }
                  },
                  selected: {
                      enumerable: true,
                      get: function () { return _draggable.selected; },
                      set: function (val) {
                          if (val) {
                              select();
                          }
                          else {
                              deselect();
                          } //if
                      }
                  },
                  dragging: {
                      enumerable: true,
                      get: function () {
                          return _dragging;
                      }
                  },
                  resizing: {
                      enumerable: true,
                      get: function () {
                          return _resizing;
                      }
                  },
                  parent: {
                      enumerabled: true,
                      get: function () {
                          return _parent;
                      },
                      set: function (val) {
                          _parent = val;

                          if (_draggable) {
                              _draggable.destroy();
                              _draggable = null;
                          }

                          if (_resizable) {
                              _resizable.destroy();
                              _resizable = null;
                              _handles = null;
                          }

                          $(_splitWrapper).hide();
                          if (_trackEvent.plugin.showSplit) {
                              if (_trackEvent.plugin.showSplit(app, _trackEvent)) {
                                  $(_splitWrapper).show();
                              }
                          }

                          if (_parent) {

                              if (_parent.element && _parent.element.parentNode && _parent.element.parentNode.parentNode) {

                                  // Capture the element's computed style on initialization
                                  var elementStyle = getComputedStyle(_element),
                                      paddingLeft = elementStyle.paddingLeft ? +elementStyle.paddingLeft.substring(0, elementStyle.paddingLeft.length - 2) : 0,
                                      paddingRight = elementStyle.paddingRight ? +elementStyle.paddingRight.substring(0, elementStyle.paddingRight.length - 2) : 0;

                                  // Store padding values to negate from width calculations
                                  _padding = paddingLeft + paddingRight;

                                  _draggable = H5DragDrop.draggable(_element, {
                                      axis : 'x',
                                      containment: _parent.element.parentNode,
                                      scroll: _parent.element.parentNode.parentNode, //.wrapper
                                      data: _this,
                                      start: function (e) {
                                          if (_trackEvent.attach) {
                                              return false;
                                          }
                                          if (e.target==_split || e.target == _splitWrapper) {
                                              return false;
                                          }
                                          _dragging = true;
                                          _element.classList.add("trackevent-dragging");
                                          _this.dispatchEvent("trackeventdragstarted", e);
                                      },
                                      stop: function (e) {
                                          _dragging = false;
                                          _element.classList.remove("trackevent-dragging");
                                          _this.dispatchEvent("trackeventdragstopped", e);
                                      },
                                      drag: function (draggable, droppable, e) {
                                          if (_onDrag) {
                                              _onDrag(draggable, droppable, e);
                                          }
                                      },
                                      revert: true
                                  });

                                  _draggable.selected = _trackEvent.selected;

                                  _resizable = H5DragDrop.resizable(_element, {
                                      containment: _parent.element.parentNode,
                                      scroll: _parent.element.parentNode.parentNode,
                                      padding: _padding,
                                      start: function (resizeEvent) {
                                          _resizing = true;
                                          _this.dispatchEvent("trackeventresizestarted", resizeEvent);
                                      },
                                      stop: function (resizeEvent) {
                                          _resizing = false;
                                          _this.dispatchEvent("trackeventresizestopped", resizeEvent);
                                      },
                                      app:app,
                                      resize: function (x, w, resizeEvent) {
                                          _this.setResizeArrows();
                                          if (_onResize) {
                                              _onResize(_trackEvent, x, w, resizeEvent, resizeEvent.direction);
                                          }
                                      }
                                  });

                                  _element.setAttribute("data-draggable-type", "trackevent");
                                  _element.setAttribute("data-trackevent-id", _trackEvent.id);

                              }

                              resetContainer();
                          }
                      }
                  }
              });

              _element.className = "track-event";

              _this.type = _type;

              _this.update(inputOptions);

              _element.addEventListener("mousedown", function (e) {
                  $('#mv').trigger("click");
                  _this.dispatchEvent("trackeventmousedown", { originalEvent: e, trackEvent: _trackEvent });
              }, true);
              _element.addEventListener("mouseup", function (e) {
                  _this.dispatchEvent("trackeventmouseup", { originalEvent: e, trackEvent: _trackEvent });
              });
              _element.addEventListener("mouseover", function (e) {
                  _this.dispatchEvent("trackeventmouseover", { originalEvent: e, trackEvent: _trackEvent });
              });
              _element.addEventListener("mouseout", function (e) {
                  _this.dispatchEvent("trackeventmouseout", { originalEvent: e, trackEvent: _trackEvent });
              });
              //_element.addEventListener("click", function (event) {
              //    $(_element).attr("tabindex", 0);
              //    $(_element).focus();
              //})
              _element.addEventListener("keydown", function (event) {
                  if (event.keyCode == 8 || event.keyCode == 46) {
                      _trackEvent.track.removeTrackEvent(_trackEvent, true);
                  }
              });


              //split
              var _lastSplitY = 0;
              var _lastSplitTop = 0;
              var _canSplitDrag = _trackEvent.plugin.canSplitDrag;
              var _splitChanged = _trackEvent.plugin.splitChanged;
              function dragSplit(e) {
                  var h = $(_element).height();
                  var unit = h / 100;
                  var offset = e.clientY - _lastSplitY;
                  var curTop  = _lastSplitTop + (offset * unit);
                  if (curTop < 0) {
                      curTop = 0;
                  }
                  if (curTop > h) {
                      curTop = h;
                  }
                  var _top = parseFloat($(_splitWrapper).css("top"));
                  if (_top != curTop) {
                      var percent = 1 - curTop / h;
                      function dragUpdate(ct) {
                          $(_splitWrapper).css({ top: ct + 'px' });
                          if (_splitChanged) {
                              _splitChanged(app, percent, _trackEvent);
                          }
                      }

                      if (_canSplitDrag) {
                          if (_canSplitDrag(app, percent, _trackEvent)) {
                              dragUpdate(curTop);
                          }
                      } else {
                          dragUpdate(curTop);
                      }


                  }


              }
              function dragSplitOver(e) {
                  window.removeEventListener("mousemove", dragSplit);
              }
              _splitWrapper.addEventListener("mousedown", function (e) {
                  _lastSplitY = e.clientY;
                  _lastSplitTop = parseFloat($(_splitWrapper).css("top"));
                  window.addEventListener("mousemove", dragSplit);
                  window.addEventListener("mouseup", dragSplitOver);
              }, true);


              function select() {
                  if (_draggable && !_draggable.selected) {
                      _draggable.selected = true;
                  }
                  _element.setAttribute("selected", true);
              }

              function deselect() {
                  if (_draggable && _draggable.selected) {
                      _draggable.selected = false;
                  }
                  _element.removeAttribute("selected");
              }
          }
      });

      return H5TrackEvent;
  });
/*
 * Uri辅助类
 */
h5.define('util/Uri', [], function () {

    // -------------------------------------------------------------
    // parseUri 1.2.2
    // (c) Steven Levithan <stevenlevithan.com>
    // http://blog.stevenlevithan.com/archives/parseuri
    // MIT License

    function parseUri(str) {
        var o = parseUri.options,
            m = o.parser[o.strictMode ? "strict" : "loose"].exec(str),
            uri = {},
            i = 14;

        while (i--) {
            uri[o.key[i]] = m[i] || "";
        }

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) {
                uri[o.q.name][$1] = $2;
            }
        });

        return uri;
    }

    parseUri.options = {
        strictMode: false,
        key: [
          "source", "protocol", "authority", "userInfo", "user", "password",
          "host", "port", "relative", "path", "directory", "file", "query", "anchor"
        ],
        q: {
            name: "queryKey",
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };

    // -------------------------------------------------------------

    // Unique key name for query string
    var UID_KEY_NAME = "h5v";

    // A default seed that won't collide.
    var seed = Date.now();

    // Reconstruct a URI from its parts as a string.
    function uriToString(uri) {
        var s = "";

        // XXX: need to figure out proper rules/exceptions for adding //
        s += uri.protocol ? uri.protocol + "://" : "";
        s += uri.authority || "";
        s += uri.path || "";
        s += uri.query ? "?" + uri.query : "";
        s += uri.anchor ? "#" + uri.anchor : "";

        return s;
    }

    // Rebuild the query string for a uri
    function updateQuery(uriObject) {
        var queryKey = uriObject.queryKey,
            queryString = "",
            queryKeyCount = 0,
            key, value;

        for (key in queryKey) {
            if (queryKey.hasOwnProperty(key)) {
                value = queryKey[key];
                queryString += queryKeyCount > 0 ? "&" : "";
                queryString += key;
                // Allow value=0
                queryString += (!!value || value === 0) ? "=" + value : "";
                queryKeyCount++;
            }
        }
        uriObject.query = queryString;
        return uriObject;
    }

    var URI = {

        // Allow overriding the initial seed (mostly for testing).
        set seed(value) {
            seed = value | 0;
        },
        UID_KEY_NAME: UID_KEY_NAME,
        get seed() {
            return seed;
        },

        // Parse a string into a URI object.
        parse: function (uriString) {
            var uri = parseUri(uriString);
            uri.toString = function () {
                return uriToString(this);
            };
            return uri;
        },

        // Make a URI object (or URI string, turned into a URI object) unique.
        // This will turn http://foo.com into http://foo.com?<UID_KEY_NAME>=<seed number++>.
        makeUnique: function (uriObject) {
            if (typeof uriObject === "string") {
                uriObject = this.parse(uriObject);
            }

            var queryKey = uriObject.queryKey;
            //queryKey[UID_KEY_NAME] = seed++;
            return updateQuery(uriObject);
        },
        getUnique: function () {
            seed++;
            return seed;
        },

        // Remove the butteruid unique identifier from a URL, that is, undo makeUnique
        stripUnique: function (uriObject) {
            if (typeof uriObject === "string") {
                uriObject = this.parse(uriObject);
            }

            var queryKey = uriObject.queryKey;
            if (queryKey) {
                delete queryKey[UID_KEY_NAME];
            }
            return updateQuery(uriObject);
        }
    };

    return URI;

});
/// <reference path="../timelineplayer-wrapped.js" />
/*
 * 保存TrackEvent相关数据，并与PlayerWrapper交互
 */

h5.define('core/TrackEvent', ["util/Object", "util/Observer",
          "util/Time", "timeline/H5TrackEvent", "util/util", "util/Uri"],
  function (Obj, Observer,
            Time, H5TrackEvent, util, uri) {

      var __guid = 0;

      var TrackEventUpdateException = function (reason, msg) {
          this.type = "trackevent-update";
          this.reason = reason;
          this.message = msg;
          this.toString = function () {
              return this.message;
          };
      };


      var TrackEvent = Observer.extend({
          init: function (app, options) {
              this._super();


              options = options || {};

              if ("id" in options) {
                  if (options.id === __guid) {
                      __guid++;
                  }
                  else if (options.id > __guid) {
                      __guid = options.id + 1;
                  }
              } else {
                  options.id = __guid++;
              }

              var _this = this,
                  _id = "TrackEvent" + options.id,
                  _name = options.name || _id,
                  _clipdata = options.clipdata || {},
                  _plugin = options.plugin,
                  _track = null,
                  _attach = false,
                  _attachTrackEvents = [],
                  _app = app,
                  _type = options.type + "";
              var _popcornOptions = options.popcornOptions || {
                  start: 0,
                  end: 1
              };
              _popcornOptions.player = app.playerPanel;
              _popcornOptions.audioVisual = app.audioVisual;
              _popcornOptions.uri = uri;
              _popcornOptions.util = util;

              var _popcornWrapper = null,
              _defaults = options.defaults || {},
              _isDefault = false,
              _selected = false;

              _this.defaults = _defaults;

              _this.clipdata = _clipdata;
              _this.plugin = _plugin;
              _this.popcornOptions = _popcornOptions;
              _this.popcornTrackEvent = null;

              var _view = new H5TrackEvent(app, this, _type, _popcornOptions);


              function defaultValue(prop, manifest) {

                  var item = manifest[prop];

                  //if (_defaults.current &&
                  //     _defaults.current.popcornOptions[prop]) {
                  if (_plugin && _plugin.getDefault()) {

                      return _plugin.getDefault().popcornOptions[prop];
                  } else if (item.hasOwnProperty("default")) {
                      return item.default;
                  }
                  return item.type === "number" ? 0 : "";
              }

              if (!_type) {
              }
              else {

                  _this.manifest = TimelinePlayer.manifest[_type]; //  Popcorn.manifest[_type];
              }

              _popcornOptions.start = _popcornOptions.start || 0;
              _popcornOptions.start = Time.roundTime(_popcornOptions.start);
              _popcornOptions.end = _popcornOptions.end || _popcornOptions.start + 1;
              _popcornOptions.end = Time.roundTime(_popcornOptions.end);



              this.bind = function (track, popcornWrapper) {
                  _track = track;
                  _popcornWrapper = popcornWrapper;
              };


              this.applyDefaults = function () {
                  var newOptions = {},
                      manifestOptions = {},
                      popcornOptions = _this.popcornOptions,
                      foundMissingOptions = false,
                      value;
                  if (!_this.manifest) {
                      return;
                  }
                  manifestOptions = _this.manifest.options;
                  for (var prop in manifestOptions) {
                      if (manifestOptions.hasOwnProperty(prop)) {
                          if (popcornOptions[prop] === null || typeof popcornOptions[prop] === "undefined") {
                              foundMissingOptions = true;
                              value = defaultValue(prop, manifestOptions);
                              if (manifestOptions[prop].elem === "select" &&
                                   manifestOptions[prop].values &&
                                   manifestOptions[prop].values.indexOf(value) !== -1) {
                                  newOptions[prop] = value;
                                  continue;
                              }
                              newOptions[prop] = value;
                          }
                      }
                  }

                  newOptions = foundMissingOptions ? newOptions : null;
                  this.update(newOptions, true);
              };


              this.update = function (updateOptions, foceUpdate) {

                  var newStart,
                      newEnd,
                      manifestOptions,
                      media,
                      preventUpdate = true,
                      updateNotification;

                  if (foceUpdate) {
                      preventUpdate = false;
                  }

                  if (!updateOptions) {
                      updateOptions = {};
                      //preventUpdate = false;
                  }

                  newStart = updateOptions.start;
                  newEnd = updateOptions.end;

                  if (isNaN(newStart)) {
                      if (updateOptions.hasOwnProperty("start")) {
                          throw new TrackEventUpdateException(lang[_curLang].wrongStart, lang[_curLang].wrongStart);
                      }
                      else {
                          newStart = _popcornOptions.start;
                          updateOptions.start = newStart;
                      }
                  }

                  if (isNaN(newEnd)) {
                      if (updateOptions.hasOwnProperty("end")) {
                          throw new TrackEventUpdateException(lang[_curLang].wrongEnd, lang[_curLang].wrongEndk);
                      }
                      else {
                          newEnd = _popcornOptions.end;
                          updateOptions.end = newEnd;
                      }
                  }

                  if (newStart > newEnd) {
                      throw new TrackEventUpdateException(lang[_curLang].startTimeGreater, lang[_curLang].startTimeGreater);
                  }

                  if (newStart !== _popcornOptions.start || newEnd !== _popcornOptions.end) {
                      preventUpdate = false;
                  }

                  updateNotification = _this.notify("update", updateOptions);
                  if (updateNotification.cancelled) {
                      return;
                  }

                  if (_track) {
                      media = _track._media;

                      if (_this.manifest) {
                          manifestOptions = _this.manifest.options;
                          if (manifestOptions) {
                              for (var prop in manifestOptions) {
                                  if (manifestOptions.hasOwnProperty(prop) &&
                                       updateOptions.hasOwnProperty(prop)) {

                                      // If we find an instance were the two properties differ, it means we need to update.
                                      if (_popcornOptions[prop] !== updateOptions[prop]) {
                                          preventUpdate = false;
                                      }
                                      _popcornOptions[prop] = updateOptions[prop];
                                  }
                              }
                              if (!("target" in manifestOptions) && updateOptions.target) {

                                  if (_popcornOptions.target !== updateOptions.target) {
                                      preventUpdate = false;
                                  }

                                  _popcornOptions.target = updateOptions.target;
                              }
                              if ("zindex" in manifestOptions && media) {
                                  var newZIndex = media.maxPluginZIndex - _track.order;

                                  if (_popcornOptions.zindex !== newZIndex) {
                                      preventUpdate = false;
                                  }

                                  _popcornOptions.zindex = updateOptions.zindex = newZIndex;
                              }
                          }
                      }
                  }

                  _popcornOptions.start = newStart;
                  _popcornOptions.end = newEnd;
                  if (_popcornOptions.end - _popcornOptions.start == 0) {
                      _this.track.removeTrackEvent(_this, false, true);
                      return;
                  }

                  if (_popcornWrapper){// && !preventUpdate) {
                      _popcornWrapper.synchronizeEvent(_this, updateOptions);
                  }
                   //删除覆盖的event
                  var t = _this.track;
                  if (t && t.findRangeTrackEvent(newStart, newEnd).length > 1) {
                      t.removeTrackEvent(this, false, true);
                      t.deleteTrackEventsByTime(newStart, newEnd);
                      t.addTrackEvent(this, true);
                  }
                  var _iconUrl = this.popcornOptions.icon;
                  var _element = this.view.element;
                  var inputOptions = this.popcornOptions;
                  //var attachTrack;
                  //if (this.track.trackType == "VA") {
                  //    attachTrack = _app.media.getNextTrack(this.track);
                  //}
                  //else if (this.track.trackType == "A") {
                  //    attachTrack = _app.media.getPreviousTrack(this.track);
                  //}
                  //if (attachTrack && inputOptions.attachEventId) {
                  //    var attachTrackEvent = attachTrack.findTrackEventByAttachEventId(inputOptions.attachEventId);
                  //    if (attachTrackEvent && !optionCompare(attachTrackEvent.popcornOptions, inputOptions)) {
                  //        attachTrackEvent.update(inputOptions);
                  //    }
                  //}
                  if (_iconUrl) {
                      if (_iconUrl.substring(0, 1) === ".") {
                          _element.querySelector(".track-event-icon").classList.add(_iconUrl.substring(1));
                      } else {
                          if (inputOptions.source && !inputOptions.audio && inputOptions.iconfrom != inputOptions.from) {
                              try {
                                  // 自动加载帧图
                                      var video = document.createElement('video');
                                      video.setAttribute("src", inputOptions.source);

                                      video.playbackRate = 0;
                                      video.mute = true;
                                      video.crossOrigin = "anonymous";
                                      video.currentTime = inputOptions.from;
                                      video.oncanplay = function () {
                                          video.play();
                                      }

                                      video.onplaying = function () {
                                          var canvas = document.createElement('canvas');
                                          canvas.width = video.videoWidth;
                                          canvas.height = video.videoHeight;
                                          context = canvas.getContext('2d');
                                          context.drawImage(video, 0, 0);
                                          var icon = canvas.toDataURL('image/jpeg', 0.05);
                                          inputOptions.icon = icon;
                                          inputOptions.iconfrom = inputOptions.from;
                                          video.onplaying = null;
                                          video.pause();
                                          _element.querySelector(".track-event-icon").style.backgroundImage = "url( " + icon + ")";
                                          video = null;
                                          canvas = null;
                                      }
                                  //var a = document.querySelector('.playerCanvas').toDataURL();
                                  //_element.querySelector(".track-event-icon").style.backgroundImage = "url( " + a + ")";
                                  //inputOptions.icon = a;
                                  //inputOptions.cut = false;
                              }
                              catch (e) {
                                  _element.querySelector(".track-event-icon").style.backgroundImage = "url( " + _iconUrl + ")";
                              }
                          }
                          else {
                              _element.querySelector(".track-event-icon").style.backgroundImage = "url( " + _iconUrl + ")";
                          }
                      }
                  }

              };
              function optionCompare(p1, p2) {
                  if (p1.from === p2.from && p1.start === p2.start && p1.end === p2.end) {
                      return true;
                  }
                  return false;
              }
              this.clone = function (cut) {
                  var pop = util.clone(_popcornOptions);
                  if (cut) {
                      pop.cut = true;
                  }
                  var trackEvent = new TrackEvent(app, {
                      type: _type,
                      clipdata: util.clone(_clipdata),
                      name: _name,
                      dropType: options.dropType,
                      pluginType: options.pluginType,
                      plugin: _plugin,
                      popcornOptions: pop
                  });

                  return trackEvent;
              };

              this.updatesign = function () {
                  if (app.isChrome && app.service && app.service.getsignurl && _clipdata.sourceid) {
                      var q = {};
                      q[uri.UID_KEY_NAME] = uri.getUnique();
                      app.service.getsignurl(_clipdata.sourceid, q, function (b, url) {
                          if (b) {
                              _this.update({
                                  source: url
                              });
                          }
                      });
                  }
              };

              this.unbind = function (preventRemove) {
                  if (!preventRemove && _popcornWrapper) {
                      _popcornWrapper.destroyEvent(_this);
                      _popcornWrapper = null;
                  }
                  _track = null;
              };


              this.copy = function () {
                  var popcornOptions = {},
                      manifestOptions = {};
                  if (this.manifest) {
                      manifestOptions = _this.manifest.options;
                      if (manifestOptions) {
                          for (var prop in manifestOptions) {
                              if (manifestOptions.hasOwnProperty(prop)) {
                                  popcornOptions[prop] = _popcornOptions[prop];
                              }
                          }
                      }
                  }
                  return {
                      popcornOptions: popcornOptions,
                      type: _type,
                      track: _track
                  };
              };

              Object.defineProperties(this, {


                  track: {
                      enumerable: true,
                      get: function () {
                          return _track;
                      }
                  },


                  view: {
                      enumerable: true,
                      configurable: false,
                      get: function () {
                          return _view;
                      }
                  },

                  dragging: {
                      enumerable: true,
                      get: function () {
                          return _view.dragging;
                      }
                  },


                  resizing: {
                      enumerable: true,
                      get: function () {
                          return _view.resizing;
                      }
                  },


                  uiInUse: {
                      enumerable: true,
                      get: function () {
                          return _view.resizing || _view.dragging;
                      }
                  },


                  type: {
                      enumerable: true,
                      get: function () {
                          return _type;
                      }
                  },
                  attach: {
                      enumerable: true,
                      get: function () {
                          return _attach;
                      },
                      set: function (val) {
                          _attach = val;
                      }
                  },
                  attachTrackEvents: {
                      enumerable: true,
                      get: function () {
                          return _attachTrackEvents;
                      }
                  },
                  name: {
                      enumerable: true,
                      get: function () {
                          return _name;
                      }
                  },


                  id: {
                      enumerable: true,
                      get: function () {
                          return _id;
                      }
                  },

                  isDefault: {
                      enumerable: true,
                      get: function () {
                          return _isDefault;
                      },
                      set: function (val) {
                          if (_plugin) {
                              if (val) {
                                  _plugin.setDefault(_this);
                              } else {
                                  _plugin.setDefault(null);
                              }
                          }

                          _isDefault = val;
                      }
                  },


                  selected: {
                      enumerable: true,
                      get: function () {
                          return _selected;
                      },
                      set: function (val) {
                          _selected = val;
                          _view.selected = _selected;
                          if (_selected) {
                              _this.notify("selected");
                              _this.dispatchEvent("trackeventselected", this);
                          }
                          else {
                              _this.notify("deselected");
                              _this.dispatchEvent("trackeventdeselected", this);
                             // console.log("deselected");
                          }
                          //console.log(_this.popcornOptions.title + '   ' + _selected);
                      }
                  },


                  json: {
                      enumerable: true,
                      get: function () {

                          var p = util.clone(_popcornOptions);
                          if (p.logger) {
                              delete p.logger;
                          }
                          delete p.audioVisual;
                          delete p.uri;
                          delete p.player;
                          delete p.util;

                          var c =  util.clone(_clipdata);
                          if (c.detail) {
                              delete c.detail;
                          }
                          if (p.source) {
                              p.source = uri.stripUnique(_this.popcornOptions.source).toString();
                          }
                          return {
                              id: _id,
                              type: _type,
                              popcornOptions: p,
                              clipdata: c,
                              attach: _this.attach||false,
                              plugin: _plugin.name(),
                              track: _track ? _track.id : undefined,
                              name: _name
                          };
                      },
                      set: function (importData) {
                          _type = _popcornOptions.type = importData.type;
                          //this.manifest = Popcorn.manifest[_type];
                          this.manifest = TimelinePlayer.manifest[_type];
                          if (importData.name) {
                              _name = importData.name;
                          }
                          _popcornOptions = importData.popcornOptions;
                          _this.popcornOptions = _popcornOptions;
                          _this.attach = importData.attach || false;
                          //Google Chrome Bug
                          if (_plugin && _plugin.loaded) {
                              _plugin.loaded(app, _this);
                          }

                          _view.type = _type;
                          _view.update(_popcornOptions);
                          _this.dispatchEvent("trackeventupdated", _this);
                      }
                  }
              });
          }
      });



      TrackEvent.MINIMUM_TRACKEVENT_SIZE = 0.02;

      return TrackEvent;

  });
/*
 * TrackEvent插件基类
 */
h5.define('core/TrackEventPluginBase', ["util/Object", "core/TrackEvent"],
        function (Obj, TrackEvent) {

            var TrackEventPluginBase = Obj.extend({
                init: function () {
                    this._super();

                    var _default = null;

                    this.setDefault = function (trackEvent) {
                        _default = trackEvent;
                    };
                    this.getDefault = function () {
                        return _default;
                    };

                },
                getPopcornOptions: function (track, data) {
                    return {};
                },
                canProcess: function (dropType, pluginType, data) {
                    return false;
                },
                canDrop: function (trackType) {
                    return false;
                },
                canUpdateStart: function (trackEvent, p) {
                    var start = p.start;
                    var preTrackEvent = trackEvent.track.findPrevTrackEvent(trackEvent);

                    var se = 0;
                    if (preTrackEvent) {
                        se = preTrackEvent.popcornOptions.end;
                    }

                    if (start < se) {
                        return {
                            can: false,
                            start: se
                        };
                    } else {
                        return {
                            can: true,
                            start: start
                        };
                    }

                },
                canUpdateEnd: function (trackEvent, p) {
                    var end = p.end;
                    var nextTrackEvent = trackEvent.track.findNextTrackEvent(trackEvent);

                    var se = end;
                    if (nextTrackEvent) {
                        se = nextTrackEvent.popcornOptions.start;
                    }

                    if (end > se) {
                        return {
                            can: false,
                            end: se
                        };
                    } else {
                        return {
                            can: true,
                            end: end
                        };
                    }
                },
                dragOver: function (helper, mousePosition, data, e) {
                },
                dropped: function (droppedEvent, app, media) {
                    //当TrackEvent被拖动到Track时的处理
                },
                startDrag:function(){
                },
                dragging:function(){
                },
                dragged: function (draggedEvent, app, media) {
                    //当TrackEvent在Track上被拖动后的处理
                },
                resize: function (resizeEvent, app, media, trackEvent) {
                    //大小变更处理
                },
                popcornPlugin: function () {
                    throw new Error(lang[_curLang].subclassMustType);
                },
                name: function () {
                    throw new Error(lang[_curLang].subclassMustName);
                },
                parseData: function (element) {
                    //从元素中获取插件数据
                },
                removeTrackEvent: function (trackEvent, ignoreUndo) {
                    trackEvent.track.removeTrackEvent(trackEvent, true, ignoreUndo);
                },
                adjustTrackEvent: function (app, trackEvent, start, end) {
                    trackEvent.update({
                        start: start,
                        end: end
                    });
                },
                deleteRange: function (app, trackEvent, start, end) {
                    var oldEnd = trackEvent.popcornOptions.end;
                    this.adjustTrackEvent(app, trackEvent, trackEvent.popcornOptions.start, start);
                    var newTrackEvent = trackEvent.clone(trackEvent);
                    newTrackEvent.popcornOptions.start = end;
                    newTrackEvent.popcornOptions.end = oldEnd;

                    var nextTrackEvent = trackEvent.track.findNextTrackEvent(trackEvent);
                    if (nextTrackEvent) {
                        trackEvent.track.insertTrackEvent(newTrackEvent, nextTrackEvent, false, true);
                    } else {
                        trackEvent.track.addTrackEvent(newTrackEvent, true);
                    }

                    return newTrackEvent;
                },
                splitTrackEvent: function (app, trackEvent, time) {
                    //剪刀功能
                    var nextTrackEvent = trackEvent.track.findNextTrackEvent(trackEvent);
                    var ns = time,
                        track = trackEvent.track,
                        ne = trackEvent.popcornOptions.end;
                    var newTrackEvent = trackEvent.clone();
                    newTrackEvent.popcornOptions.start = time;
                    newTrackEvent.popcornOptions.end = trackEvent.popcornOptions.end;

                    trackEvent.update({
                        start: trackEvent.popcornOptions.start,
                        end: time
                    });

                    if (nextTrackEvent) {
                        track.insertTrackEvent(newTrackEvent, nextTrackEvent, false, true);
                    } else {
                        track.addTrackEvent(newTrackEvent, true);
                    }
                    //选中新项  20160924 zxl
                    app.media.deselectAllTrackEvents();
                   // newTrackEvent.selected = true;



                }


            });


            return TrackEventPluginBase;
        });
h5.define('core/DragTrack', ["util/util"], function (util) {
    var DragTrack = function (array) {
        var _array;
        if (array == undefined) {
            _array == [];
        }
        else{
            _array = array;
        }

        this.findTrackEvent = function(time) {
            var array = _array;
            var t = util.first(array, function (item) {
                if (item.start <= time && item.end > time) {
                    return true;
                }
                return false;
            });

            return t;
        }

        this.findNextTrackEventByTime = function(time) {
            var array = _array;

            var trackEvent = util.first(array, function (item) {
                if (item.start >= time) {
                    return true;
                }
                return false;
            });

            return trackEvent;
        }

        this.findNextTrackEvent = function(trackEvent) {
            var array = _array;
            var idx = array.indexOf(trackEvent);
            if (idx >= 0) {
                idx++;
                if (idx < array.length) {
                    return array[idx];
                }
            }
            return null;
        };

        this.findPrevTrackEvent = function(trackEvent) {
            var array = _array;
            var idx = array.indexOf(trackEvent);
            if (idx >= 0) {
                idx--;
                if (idx >= 0) {
                    return array[idx];
                }
            }
            return null;
        };

        this.findNextTrackEvents = function(trackEvent) {
            var array = _array;
            var t = [];
            var b = false;
            for (var i = 0 ; i < array.length; i++) {
                var item = array[i];
                if (item === trackEvent) {
                    b = true;
                }

                if (b) {
                    t.push(item);
                }
            }

            return t;
        }

        this.findRangeTrackEvents =  function(start, end) {
            var array = _array;
            var t = [];
            for (var i = 0 ; i < array.length; i++) {
                var item = array[i];


                if (item.start < end &&
                    item.end > start) {
                    t.push(item);
                }


            }

            return t;
        };

        this.getLastTrackEvent = function() {
            var array = _array;
            if (array.length === 0)
                return null;
            return array[array.length - 1];
        }

        this.restoreOld = function() {
            var array = _array;
            util.forEach(array, function (item) {
                item.trackEvent.view.update({
                    start: item.start,
                    end: item.end
                });
            });
        }

    };


    return DragTrack;
});
/*
 * 视频插件
 */
h5.define('core/VideoTrackEventPlugin', ["jquery", "core/TrackEventPluginBase", "core/TrackEvent", "util/Uri", "util/util", "core/DragTrack","util/Guid"],
        function ($, TrackEventPluginBase, TrackEvent, uri, util, DragTrack, Guid) {
            var DRAG_IGNORE_WIDTH = 10; //拖动时容差 5px
            var DRAG_INSERT_WIDTH = 20; //插入操作

            var VideoTrackEventPlugin = TrackEventPluginBase.extend({
                init: function () {

                    this._super();
                },
                getPopcornOptions: function (track, data) {
                    var f = util.roundTime(data.from),
                        d = util.roundTime(data.duration);
                    //if (data.end) {
                    //    f = util.roundTime(data.from);
                    //    d = util.roundTime(data.duration);
                    //}


                    var options = {
                        start: 0,
                        end: d-f ,
                        from: util.roundTime( f),
                        duration: util.roundTime(d),
                        source: data.source,
                        title: data.title,
                        icon: data.icon,
                        clipid: data.clipid,
                        createdate: data.createdate,
                        zindex: 110 - track.order
                    };
                    if (track.trackType == "VA") {
                        options.mute = true;
                        options.audio = false;
                    } else {
                        options.audio = true;
                        options.icon = '.audioIcon';
                    }

                    return options;

                },
                canProcess: function (dropType, pluginType, data) {
                    if (pluginType === "video" || pluginType === "audio") {
                        return true;
                    }
                    return false;
                },
                canDrop: function (trackType) {
                    if (trackType === 'VA' || trackType === 'A') {
                        return true;
                    }
                    return false;
                },
                dragOver: function (app, helper, mousePosition, data, e) {
                    var track = data.track;

                    if (helper && helper.data && helper.data.data) {
                        if (helper.data.data.audio != undefined) {
                            if (helper.data.data.audio && track.trackType == "VA") {
                                //视频轨不可添加纯音频
                                return false;
                            }
                            else if (!helper.data.data.audio && track.trackType == "A") {
                                //音频轨不可添加视频频
                                return false;
                            }
                        }
                    }

                   /* if (track.trackType == "VA" ||track.trackType == "A") {

                        var len = helper.data.data.duration - helper.data.data.from;

                        if (data.hoverTrackEvent) {
                            var hte = data.hoverTrackEvent;
                            var isAfter = false;
                            var startDis = app.timeToPixel(data.dragTime - hte.popcornOptions.start);
                            var endDis = app.timeToPixel(hte.popcornOptions.end - data.dragTime);

                            if (Math.min(endDis, startDis) >= 40) {
                                return false;
                            }

                            if (endDis < startDis) {
                                isAfter = true;
                            }

                            var ele = $(data.holderElement),
                              w = app.timeToPixel(len * 1000);
                            ele.width(w);

                            var startX = 0;
                            if (isAfter) {
                                startX = app.timeToPixel(hte.popcornOptions.end * 1000);
                            } else {
                                startX = app.timeToPixel(hte.popcornOptions.start * 1000);
                            }
                            ele.css({ left: startX + 'px' });
                            var t = data.track.findNextTrackEvents(hte);
                            if (isAfter) {
                                t.splice(0, 1);
                                data.dropTime = hte.popcornOptions.end;
                                if (t.length > 0) {
                                    data.dropNextTrackEvent = t[0];
                                }
                            } else {
                                data.dropTime = hte.popcornOptions.start;
                                data.dropNextTrackEvent = hte;
                            }
                            hte.view.update({
                                start: hte.popcornOptions.start,
                                end: hte.popcornOptions.end
                            });
                            util.forEach(t, function (item) {
                                item.view.update({
                                    start: item.popcornOptions.start + len,
                                    end: item.popcornOptions.end + len
                                });
                            });
                            return true;
                        } else {

                            util.forEach(track.trackEvents, function (item) {
                                item.view.update({
                                    start: item.popcornOptions.start,
                                    end: item.popcornOptions.end
                                });
                            });
                            var start = data.track.getNextTrackEventStart(),
                              x = app.timeToPixel(start * 1000);
                            data.dropTime = start;

                            var ele = $(data.holderElement),
                                w = app.timeToPixel(len * 1000);
                            ele.width(w);
                            ele.css({ left: x + 'px' });

                            return true;
                        }
                        return false;

                        //if (data.startTrackEvent || data.endTrackEvent) {
                        //    if (data.startTrackEvent === data.endTrackEvent) {
                        //        return false;
                        //    }

                        //    //移动
                        //    var ele = $(data.holderElement),
                        //       w = app.timeToPixel(len * 1000);
                        //    ele.width(w);

                        //    var startX = 0;
                        //    if (data.startTrackEvent) {
                        //        startX = app.timeToPixel(data.startTrackEvent.popcornOptions.end * 1000);
                        //    } else {
                        //        return false;
                        //    }
                        //    console.log("----VA1 " + startX);
                        //    ele.css({ left: startX + 'px' });
                        //    if (data.startTrackEvent) {

                        //        var t = data.track.findNextTrackEvents(data.startTrackEvent, function (te) {
                        //            if (te == data.startTrackEvent) {
                        //                return false;
                        //            }
                        //            return true;
                        //        });

                        //        util.forEach(t, function (item) {
                        //            item.view.update({
                        //                start: item.popcornOptions.start + len,
                        //                end: item.popcornOptions.end + len
                        //            });
                        //        });

                        //    } else if (data.endTrackEvent) {
                        //        console.log("END");
                        //    }


                        //    return true;
                        //} else {

                        //    var start = data.track.getNextTrackEventStart(),
                        //        x = app.timeToPixel(start * 1000);

                        //    var ele = $(data.holderElement),
                        //        w = app.timeToPixel(len * 1000);
                        //    ele.width(w);
                        //    ele.css({ left: x + 'px' });

                        //    console.log("----VA2 " + x);
                        //    return true;
                        //}
                        //return false;
                    } else */{
                        //音频
                        var len = helper.data.data.duration,
                        ctrl = e && e.ctrlKey,
                        track = data.track;

                        //按下ctrl为插入模式
                        //否则为自由模式
                        if (ctrl) {
                            var overTrackEvent = track.findTrackEventByTime(data.dragTime);

                            var nextTrackEvent = null,
                                prevTrackEvent = null,
                                startTime = 0;
                            if (overTrackEvent) {

                                var offsetTime = app.pixelToTime(DRAG_INSERT_WIDTH) / 1000;
                                if (data.dragTime <= (overTrackEvent.popcornOptions.start + offsetTime)) {
                                    nextTrackEvent = overTrackEvent;
                                    startTime = overTrackEvent.popcornOptions.start;
                                } else if (data.dragTime >= (overTrackEvent.popcornOptions.end - offsetTime)) {
                                    nextTrackEvent = track.findNextTrackEvent(overTrackEvent);
                                    startTime = overTrackEvent.popcornOptions.end;
                                } else {
                                    helper._curStatus = null;
                                    return false;
                                }

                            } else {
                                nextTrackEvent = track.findNextTrackEvent(data.dragTime);
                                if (nextTrackEvent) {
                                    prevTrackEvent = track.findPrevTrackEvent(nextTrackEvent);
                                } else {
                                    prevTrackEvent = track.getLastTrackEvent();
                                }

                                startTime = util.roundTime(data.startTime);

                                if (prevTrackEvent) {
                                    if (data.startTime < prevTrackEvent.popcornOptions.end) {
                                        startTime = prevTrackEvent.popcornOptions.end;
                                    }
                                }
                                if (startTime <= (1 / util.frameRate)) {
                                    startTime = 0;
                                }


                            }

                            var autoAlignRs = app.media.autoAlign(overTrackEvent, startTime, startTime + len, 20);
                            startTime = autoAlignRs.startTime;

                            var ele = $(data.holderElement),
                                w = app.timeToPixel(len * 1000),
                                startX = app.timeToPixel(startTime * 1000);
                            ele.width(w);
                            ele.css({ left: startX + 'px' });

                            if (nextTrackEvent) {

                                var t = track.findNextTrackEvents(nextTrackEvent);

                                util.forEach(t, function (item) {
                                    item.view.update({
                                        start: item.popcornOptions.start + len,
                                        end: item.popcornOptions.end + len
                                    });
                                });

                            }

                            helper._curStatus = { start: startTime, end: startTime + len, nextTrackEvent: nextTrackEvent, move: true };


                            return true;

                        } else {
                            var overTrackEvent = track.findTrackEventByTime(data.dragTime);

                            var nextTrackEvent = null,
                                prevTrackEvent = null,
                                startTime = 0,
                                endTime = 0;
                            //if (overTrackEvent) {
                            //    helper._curStatus = null;
                            //    return false;

                            //} else
                            {
                                startTime = util.roundTime(data.startTime);
                                if (startTime <= (1 / util.frameRate)) {
                                    startTime = 0;
                                }

                                endTime = startTime + len;



                                //prevTrackEvent = track.findPrevTrackEvent(data.dragTime);
                                //nextTrackEvent = track.findNextTrackEvent(data.dragTime);

                                //if (prevTrackEvent) {
                                //    if (startTime < prevTrackEvent.popcornOptions.end) {
                                //        startTime = prevTrackEvent.popcornOptions.end;
                                //    }
                                //}
                                //if (nextTrackEvent) {
                                //    if (endTime > nextTrackEvent.popcornOptions.start) {
                                //        endTime = nextTrackEvent.popcornOptions.start;
                                //    }
                                //}


                                //nextTrackEvent = track.findNextTrackEvent(data.startTime);
                                //if (nextTrackEvent) {
                                //    if (endTime > nextTrackEvent.popcornOptions.start) {
                                //        endTime = nextTrackEvent.popcornOptions.start;
                                //    }
                                //}

                                if ((endTime - startTime) <= (1 / util.frameRate)) {
                                    helper._curStatus = null;
                                    return false;
                                }


                            }
                            var autoAlignRs = app.media.autoAlign(overTrackEvent, startTime, endTime, 20);
                            startTime = autoAlignRs.startTime;
                            endTime = autoAlignRs.endTime;

                            len = endTime - startTime;
                            var ele = $(data.holderElement),
                                w = app.timeToPixel(len * 1000),
                                startX = app.timeToPixel(startTime * 1000);
                            ele.width(w);
                            ele.css({ left: startX + 'px' });

                            helper._curStatus = { start: startTime, end: endTime, nextTrackEvent: nextTrackEvent, move: false };


                            return true;


                        }
                    }
                },
                dropped: function (droppedEvent, app, media, e,callback) {
                    var _this = this;
                    if (app.service.getObjectInfo) {
                        app.service.getObjectInfo(droppedEvent.data, function (b, r) {
                            if (b) {
                                if (r.source) {
                                    droppedEvent.data.source = r.source;
                                }
                                if (r.icon) {
                                    droppedEvent.data.icon = r.icon;
                                }
                                if (r.duration) {
                                    droppedEvent.data.duration = r.duration;
                                }
                                if (r.from) {
                                    droppedEvent.data.from = r.from;
                                }

                                var te = __dropped.apply(_this);
                                if (callback) {
                                    callback(te);
                                }

                            } else {
                                console.error("获取对象信息失败");
                            }
                        });
                    } else {
                        var te = __dropped.apply(_this);
                        if (callback) {
                            callback(te);
                        }
                    }

                    function __dropped() {

                        //console.log("dropped");
                        if (droppedEvent.track.trackType == "VAA" || droppedEvent.track.trackType == "AA") {

                            var data = droppedEvent.data,
                                dragData = droppedEvent.dragData,
                                trackEvent = null,
                                track = droppedEvent.track;


                            var start = 0;

                            if (typeof dragData.dropTime == 'number') {
                                start = dragData.dropTime;
                            } else {

                                if (dragData.startTrackEvent || dragData.endTrackEvent) {
                                    if (dragData.startTrackEvent === dragData.endTrackEvent) {
                                        return;
                                    }



                                    if (dragData.startTrackEvent) {
                                        start = dragData.startTrackEvent.popcornOptions.end;
                                    }


                                } else {
                                    start = track.getNextTrackEventStart();
                                }
                            }

                        popcornOptions = this.getPopcornOptions(track, data);
                        if (!popcornOptions) {
                            return;
                        }
                        popcornOptions.start = util.roundTime(start);
                        popcornOptions.end = util.roundTime(start + (popcornOptions.duration - popcornOptions.from));

                        if (app.isChrome) {

                            popcornOptions.source = uri.makeUnique(popcornOptions.source).toString();

                            }
                            if (data.channel) {
                                var nextTrack = media.getNextTrack(track);

                                if (nextTrack && nextTrack.trackType == "A") {
                                } else {
                                    popcornOptions.mute = false;
                                }
                            }

                        var trackEvent = new TrackEvent(app, {
                            type: this.popcornPlugin(),
                            clipdata: util.clone(data),
                            name: data.title,
                            dropType: droppedEvent.dropType,
                            pluginType: droppedEvent.type,
                            plugin: this,
                            popcornOptions: popcornOptions
                        }); //是否保存
                        //自动获取素材信息
                        //if (!data.detail) {
                        if (app.service && app.service.getobject) {
                            app.service.getobject.call(app, data, function (b, clipinfo) {
                                if (b) {
                                    trackEvent.clipdata.detail = clipinfo;
                                    trackEvent.clipdata.detail.__id = data.clipid;
                                    audioTrackEvent.clipdata.detail = clipinfo;
                                    audioTrackEvent.clipdata.detail.__id = data.clipid;
                                }
                            });
                        }
                        //}
                            //自动加音频
                        if (data.channel) {
                            var nextTrack = media.getNextTrack(track);

                            if (nextTrack && nextTrack.trackType == "A") {
                                console.log("Audio track");
                                var po = trackEvent.popcornOptions;
                                var start = po.start;
                                var end = po.end;
                                var teStart = nextTrack.findTrackEventByTime(po.start + 0.03);
                                if (teStart) {
                                   // start = teStart.popcornOptions.start;
                                    //offset有问题   因为是插入的  所以idx有误
                                    nextTrack.offsetTrackEvent(teStart, end - teStart.popcornOptions.start, true);
                                }
                                else {
                                    nextTrack.offsetTrackEventsByTime(start, end);
                                    // nextTrack.removeTrackEventsByTime(start, end);
                                }
                                //var teEnd = nextTrack.findTrackEventByTime(end);
                                //if (teEnd && teEnd.popcornOptions.start != end) {
                                //    nextTrack.removeTrackEvent(teEnd, false, true);
                                //    //end = teEnd.popcornOptions.start;
                                //    //teEnd.track
                                //}
                                if ((end - start) > 0) {
                                    po = util.clone(po);

                                    po.start = start;
                                    po.end = end;
                                    po.audio = true;
                                    po.mute = false;
                                    po.icon = '.audioIcon';


                                    var audioTrackEvent = new TrackEvent(app, {
                                        type: this.popcornPlugin(),
                                        clipdata: util.clone(data),
                                        name: data.title,
                                        dropType: droppedEvent.dropType,
                                        pluginType: droppedEvent.type,
                                        plugin: this,
                                        popcornOptions: po
                                    });
                                    nextTrack.addTrackEvent(audioTrackEvent, true);

                                    if (app.isChrome && app.service && app.service.getsignurl && data.sourceid) {
                                        audioTrackEvent.updatesign();
                                    }

                                }

                                // Object {start: 15, end: 30, from: 0, duration: 15, source: "http://bj-sobey1.oss-cn-beijing.aliyuncs.com/laiqi…f4020b15d9a374742374216_9_1.mp4?h5v=1448077900492"…}audio: falseaudioVisual: Classclipid: "39eb56ebb51144dfbb62ec6d01a4903f"duration: 15end: 30from: 0height: 100hidden: falseicon: "icons/22.jpg"left: 0logger: loggermute: trueplayer: Classsource: "http://bj-sobey1.oss-cn-beijing.aliyuncs.com/laiqiucun_sobey.com/2015/10/12/ac896502e2ef4020b15d9a374742374216_9_1.mp4?h5v=1448077900492"start: 15title: "视频2"top: 0type: "video"uri: Objectutil: Objectvolume: 100width: 100zindex: 107__proto__: Object
                            }

                        }
                         if (dragData.dropNextTrackEvent) {
                             track.insertTrackEvent(trackEvent, dragData.dropNextTrackEvent, false,true);
                             var t = dragData.track.findNextTrackEvents(dragData.dropNextTrackEvent);

                            var len = popcornOptions.end - popcornOptions.start;
                            util.forEach(t, function (item) {
                                item.update({
                                    start: item.popcornOptions.start + len,
                                    end: item.popcornOptions.end + len
                                });
                            });

                            media.updateDuration();
                            app.undo.push('insert video');
                        } else {


                                track.addTrackEvent(trackEvent);
                            }
                            util.forEach(track.trackEvents, function (item) {
                                if (item.attach) {
                                    item.plugin.updateAttach(app, item);
                                }
                            });
                            if (app.isChrome && app.service && app.service.getsignurl && data.sourceid) {
                                trackEvent.updatesign();
                            }

                        return trackEvent;
                    } else {

                        $(app.trackContainer.element).find("div.align-line").remove();
                        //根据left计算项开始时间
                        //如果该处已存在项
                        //  如果是插入模式，自动调整后续项位置
                        //  如果是非插入模式，直接返回
                        //如果该处不存在项
                        //  直接添加项
                        //  检查结束位置，如果存在结束位置，使用结束位置，
                        //  如果结束位置大于后续项开始位置，自动调整
                        var type = droppedEvent.type,
                            track = droppedEvent.track,
                            data = droppedEvent.data,
                            left = droppedEvent.left,
                            dragData = droppedEvent.dragData,
                            insert = true,//(e && e.ctrlKey),
                            popcornOptions = {},
                            minStart = 0,
                            offsetTime = 0,
                            nextTrackEvent,
                            prevTrackEvent;


                        if (dragData && dragData.helper) {
                            var trackEvent = null;
                            if (dragData.helper._curStatus) {
                                popcornOptions = this.getPopcornOptions(track, data);
                                if (!popcornOptions) {
                                    return;
                                }

                                popcornOptions.start = dragData.helper._curStatus.start;
                                popcornOptions.end = dragData.helper._curStatus.end;

                                trackEvent = new TrackEvent(app, {
                                    type: this.popcornPlugin(),
                                    clipdata: util.clone(data),
                                    dropType: droppedEvent.dropType,
                                    pluginType: type,
                                    plugin: this,
                                    popcornOptions: popcornOptions
                                });

                                if (app.service && app.service.getobject) {
                                    app.service.getobject.call(app, data, function (b, clipinfo) {
                                        if (b) {
                                            trackEvent.clipdata.detail = clipinfo;
                                            trackEvent.clipdata.detail.__id = data.clipid;
                                            audioTrackEvent.clipdata.detail = clipinfo;
                                            audioTrackEvent.clipdata.detail.__id = data.clipid;
                                        }
                                    });
                                }
                                var nextTrackEvent = dragData.helper._curStatus.nextTrackEvent;

                                if (nextTrackEvent) {

                                    track.insertTrackEvent(trackEvent, nextTrackEvent, false);
                                    if (dragData.helper._curStatus.move) {

                                        track.offsetTrackEvent(nextTrackEvent, (popcornOptions.end - popcornOptions.start));
                                    }
                                } else {
                                    track.addTrackEvent(trackEvent, true);
                                }

                                dragData.helper._curStatus = null;

                                    if (app.isChrome && app.service && app.service.getsignurl && data.sourceid) {
                                        trackEvent.updatesign();
                                    }
                                }

                            //自动加音频
                            if (data.channel) {
                                var nextTrack = media.getNextTrack(track);

                                if (nextTrack && nextTrack.trackType == "A") {
                                    console.log("Audio track");
                                    var po = trackEvent.popcornOptions;
                                    var start = po.start;
                                    var end = po.end;
                                    var teStart = nextTrack.findTrackEventByTime(po.start + 0.03);
                                    //if (teStart) {
                                    //    // start = teStart.popcornOptions.start;
                                    //    //offset有问题   因为是插入的  所以idx有误
                                    //    nextTrack.offsetTrackEvent(teStart, end - teStart.popcornOptions.start, true);
                                    //}
                                    //else {
                                    //    nextTrack.offsetTrackEventsByTime(start, end);
                                    //    // nextTrack.removeTrackEventsByTime(start, end);
                                    //}
                                    //var teEnd = nextTrack.findTrackEventByTime(end);
                                    //if (teEnd && teEnd.popcornOptions.start != end) {
                                    //    nextTrack.removeTrackEvent(teEnd, false, true);
                                    //    //end = teEnd.popcornOptions.start;
                                    //    //teEnd.track
                                    //}
                                    if ((end - start) > 0) {
                                        po = util.clone(po);

                                        po.start = start;
                                        po.end = end;
                                        po.audio = true;
                                        po.mute = false;
                                        po.icon = '.audioIcon';
                                        //po.attachEventId = trackEvent.popcornOptions.attachEventId = Guid.NewGuid().ToString("N");

                                        var audioTrackEvent = new TrackEvent(app, {
                                            type: this.popcornPlugin(),
                                            clipdata: util.clone(data),
                                            name: data.title,
                                            dropType: droppedEvent.dropType,
                                            pluginType: droppedEvent.type,
                                            plugin: this,
                                            popcornOptions: po
                                        });
                                        nextTrack.addTrackEvent(audioTrackEvent, true);

                                        if (app.isChrome && app.service && app.service.getsignurl && data.sourceid) {
                                            audioTrackEvent.updatesign();
                                        }

                                    }
                                }

                            }
                            app.undo.push("Add TrackEvent");
                            return trackEvent;

                        } else {
                            if (typeof data.start === "number") {
                                popcornOptions = this.getPopcornOptions(track, data);
                                if (!popcornOptions) {
                                    return;
                                }

                                popcornOptions.start = data.start;
                                popcornOptions.end = data.start + data.end -data.from;
                                var nextTrackEvent = track.findNextTrackEvent(data.start);
                                //if (nextTrackEvent && popcornOptions.end > nextTrackEvent.popcornOptions.start) {
                                //    popcornOptions.end = nextTrackEvent.popcornOptions.start;
                                //}





                                trackEvent = new TrackEvent(app, {
                                    type: this.popcornPlugin(),
                                    clipdata: util.clone(data),
                                    dropType: droppedEvent.dropType,
                                    pluginType: type,
                                    plugin: this,
                                    popcornOptions: popcornOptions
                                });

                                //自动获取素材信息
                                //if (!data.detail) {
                                if (app.service && app.service.getobject) {
                                    app.service.getobject.call(app, data, function (b, clipinfo) {
                                        if (b) {
                                            trackEvent.clipdata.detail = clipinfo;
                                            trackEvent.clipdata.detail.__id = data.clipid;
                                        }
                                    });
                                }
                                //}

                                //if (nextTrackEvent) {

                                //    track.insertTrackEvent(trackEvent, nextTrackEvent, false);

                                //    } else {
                                //        track.addTrackEvent(trackEvent);
                                //    }
                                track.addTrackEvent(trackEvent, true);
                                    if (app.isChrome && app.service && app.service.getsignurl && data.sourceid) {
                                        trackEvent.updatesign();
                                    }
                            }
                            //自动加音频
                            if (data.channel) {
                                var nextTrack = media.getNextTrack(track);

                                if (nextTrack && nextTrack.trackType == "A") {
                                    console.log("Audio track");
                                    var po = trackEvent.popcornOptions;
                                    var start = po.start;
                                    var end = po.end;
                                    var teStart = nextTrack.findTrackEventByTime(po.start + 0.03);
                                    //if (teStart) {
                                    //    // start = teStart.popcornOptions.start;
                                    //    //offset有问题   因为是插入的  所以idx有误
                                    //    nextTrack.offsetTrackEvent(teStart, end - teStart.popcornOptions.start, true);
                                    //}
                                    //else {
                                    //    nextTrack.offsetTrackEventsByTime(start, end);
                                    //    // nextTrack.removeTrackEventsByTime(start, end);
                                    //}
                                    //var teEnd = nextTrack.findTrackEventByTime(end);
                                    //if (teEnd && teEnd.popcornOptions.start != end) {
                                    //    nextTrack.removeTrackEvent(teEnd, false, true);
                                    //    //end = teEnd.popcornOptions.start;
                                    //    //teEnd.track
                                    //}
                                    if ((end - start) > 0) {
                                        po = util.clone(po);

                                        po.start = start;
                                        po.end = end;
                                        po.audio = true;
                                        po.mute = false;
                                        po.icon = '.audioIcon';
                                        //po.attachEventId = trackEvent.popcornOptions.attachEventId = Guid.NewGuid().ToString("N");

                                        var audioTrackEvent = new TrackEvent(app, {
                                            type: this.popcornPlugin(),
                                            clipdata: util.clone(data),
                                            name: data.title,
                                            dropType: droppedEvent.dropType,
                                            pluginType: droppedEvent.type,
                                            plugin: this,
                                            popcornOptions: po
                                        });
                                        nextTrack.addTrackEvent(audioTrackEvent, true);

                                        if (app.isChrome && app.service && app.service.getsignurl && data.sourceid) {
                                            audioTrackEvent.updatesign();
                                        }

                                    }
                                }

                            }
                                 app.undo.push("Add TrackEvent");
                                return trackEvent;
                            }
                        }
                    }
                },
                startDrag: function (app, media, dragData, e) {
                    //console.log('startDrag');

                    if (dragData.track.trackType == "VAA") {

                        //先删除
                        var trackEvent = dragData.trackEvent,
                            track = dragData.track;
                        var len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;



                        if (dragData.nextTrackEvent) {
                            var t = track.findNextTrackEvents(dragData.nextTrackEvent);
                            util.forEach(t, function (item) {
                                item.view.update({
                                    start: item.popcornOptions.start - len,
                                    end: item.popcornOptions.end - len
                                });
                            });
                        }

                        var t = [];
                        util.forEach(track.trackEvents, function (item) {
                            if (item === trackEvent) {
                            } else {
                                if (!item.attach) {
                                    var ds = {
                                        trackEvent: item,
                                        start: item.view.start,
                                        end: item.view.end,
                                        offset: $(item.view.element).offset(),
                                        left: parseFloat($(item.view.element).css("left")),
                                        width: $(item.view.element).width()
                                    };
                                    console.log('start: ' + ds.start);
                                    t.push(ds);
                                }
                            }
                        });
                        trackEvent._dragStartStatus = t;
                        trackEvent._curStatus = null;
                    } else {
                        //先删除
                        var trackEvent = dragData.trackEvent,
                            track = dragData.track,
                            ctrl = (e && e.ctrlKey); //true;
                        var len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;

                        if (ctrl) {
                            //自动收缩
                            if (dragData.nextTrackEvent) {
                                var t = track.findNextTrackEvents(dragData.nextTrackEvent);
                                util.forEach(t, function (item) {
                                    item.view.update({
                                        start: item.popcornOptions.start - len,
                                        end: item.popcornOptions.end - len
                                    });
                                });
                            }
                        } else {
                        }

                        //备份
                        var t = [];
                        util.forEach(track.trackEvents, function (item) {
                            if (item === trackEvent) {
                            } else {
                                var ds = {
                                    trackEvent: item,
                                    start: item.view.start,
                                    end: item.view.end,
                                    offset: $(item.view.element).offset(),
                                    left: parseFloat($(item.view.element).css("left")),
                                    width: $(item.view.element).width()
                                };
                                console.log('start: ' + ds.start);
                                t.push(ds);
                            }
                        });
                        trackEvent._dragStartStatus = t;
                        trackEvent._curStatus = null;
                    }
                },
                dragging: function (app, media, dragData, e) {
                    //console.log('dragging');
                    if (dragData.track.trackType == "VAA" || dragData.track.trackType == "AA") {

                        var trackEvent = dragData.trackEvent,
                            track = dragData.track;
                        var len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;

                        var left = $(trackEvent.view.element).offset().left,
                            width = $(trackEvent.view.element).width(),
                            x = parseInt($(trackEvent.view.element).css("left")),
                            right = left + width,
                            len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;

                        function findTrackEvent(array, p) {
                            var t = util.first(array, function (item) {
                                if (item.offset.left <= p && (item.offset.left + item.width) > p) {
                                    return true;
                                }
                                return false;
                            });

                            return t;
                        }

                        function findNextTrackEvent(array, trackEvent) {
                            var idx = array.indexOf(trackEvent);
                            if (idx >= 0) {
                                idx++;
                                if (idx < array.length) {
                                    return array[idx];
                                }
                            }
                            return null;
                        };

                        function findPrevTrackEvent(array, trackEvent) {
                            var idx = array.indexOf(trackEvent);
                            if (idx >= 0) {
                                idx--;
                                if (idx >= 0) {
                                    return array[idx];
                                }
                            }
                            return null;
                        };

                        function findNextTrackEvents(array, trackEvent) {
                            var t = [];
                            var b = false;
                            for (var i = 0 ; i < array.length; i++) {
                                var item = array[i];
                                if (item === trackEvent) {
                                    b = true;
                                }

                                if (b) {
                                    t.push(item);
                                }
                            }

                            return t;
                        }

                        function restoreOld(array) {
                            util.forEach(array, function (item) {
                                item.trackEvent.view.update({
                                    start: item.start,
                                    end: item.end
                                });
                            });
                        }

                        var startTrackEvent = findTrackEvent(trackEvent._dragStartStatus, left),
                            endTrackEvent = findTrackEvent(trackEvent._dragStartStatus, right),
                            _holderElement = track.view.getTrackEventShadow();

                        if (startTrackEvent || endTrackEvent) {
                            if (startTrackEvent === endTrackEvent && startTrackEvent !== trackEvent._dragStartStatus[0]) {
                                restoreOld(trackEvent._dragStartStatus);
                                trackEvent._curStatus = null;
                                return;
                            }

                            if (startTrackEvent === endTrackEvent) {
                                endTrackEvent = null;
                            }

                            if (startTrackEvent && endTrackEvent) {
                                //
                                var endWidth = right - endTrackEvent.offset.left,
                                    startWidth = (startTrackEvent.offset.left + startTrackEvent.width) - left;

                                var idx = trackEvent._dragStartStatus.indexOf(startTrackEvent);
                                var b = false;
                                if (idx === 0) {
                                    if (left < (startTrackEvent.offset.left + 20)) {
                                        endTrackEvent = startTrackEvent;
                                        startTrackEvent = null;
                                        b = true;
                                    }
                                }

                                if (startWidth > endWidth && !b) {
                                    endTrackEvent = findNextTrackEvent(trackEvent._dragStartStatus, startTrackEvent);
                                }
                            } else if (startTrackEvent) {
                                //只有开始没有结束
                                if (left < (startTrackEvent.offset.left + startTrackEvent.width / 2)) {
                                    endTrackEvent = startTrackEvent;
                                    startTrackEvent = findPrevTrackEvent(trackEvent._dragStartStatus, endTrackEvent);

                                } else {
                                    endTrackEvent = findNextTrackEvent(trackEvent._dragStartStatus, startTrackEvent);
                                }
                            }

                            //移动
                            var ele = $(_holderElement);
                            ele.width(width);

                            var startX = 0;
                            var start = 0;
                            if (startTrackEvent) {
                                startX = startTrackEvent.left + startTrackEvent.width;
                                start = startTrackEvent.end;
                            }
                            ele.css({ left: startX + 'px' });
                            ele.removeClass("hidden");
                            trackEvent._curStatus = { start: start, nextTrackEvent: endTrackEvent };

                            restoreOld(trackEvent._dragStartStatus);

                            if (endTrackEvent) {

                                var t = findNextTrackEvents(trackEvent._dragStartStatus, endTrackEvent);
                                util.forEach(t, function (item) {
                                    item.trackEvent.view.update({
                                        start: item.start + len,
                                        end: item.end + len
                                    });
                                });

                            }


                            return true;
                        } else {
                            //console.log('hello');
                            restoreOld(trackEvent._dragStartStatus);
                            var lastX = 0;
                            var start = 0;
                            if (trackEvent._dragStartStatus && trackEvent._dragStartStatus.length > 0) {
                                var lastTrackEvent = trackEvent._dragStartStatus[trackEvent._dragStartStatus.length - 1];

                                lastX = lastTrackEvent.left + lastTrackEvent.width;
                                start = lastTrackEvent.end;
                                console.log("start: " + lastTrackEvent.start + " left: " + lastTrackEvent.left);
                            }

                            var ele = $(_holderElement);
                            ele.width(width);
                            ele.css({ left: lastX + 'px' });
                            ele.removeClass("hidden");
                            trackEvent._curStatus = { start: start, nextTrackEvent: null };


                            return true;
                        }
                        trackEvent._curStatus = null;
                        restoreOld(trackEvent._dragStartStatus);

                    } else {
                        var trackEvent = dragData.trackEvent,
                        track = dragData.track,
                        ctrl = (e && e.ctrlKey),//trackEvent.track.trackType == "A" || (e && e.ctrlKey),
                        dragTrack = new DragTrack(trackEvent._dragStartStatus);




                        if (ctrl) {
                            //插入模式

                            dragTrack.restoreOld();

                            var x = dragData.left;
                            if (x <= 1) {
                                x = 0;
                            }

                            var dragTime = app.pixelToTime(x) / 1000;

                            var overTrackEvent = dragTrack.findTrackEvent(dragTime);


                            var nextTrackEvent = null,
                                prevTrackEvent = null,
                                startTime = 0;
                            if (overTrackEvent) {
                                var offsetTime = app.pixelToTime(DRAG_INSERT_WIDTH) / 1000;
                                if (dragTime <= (overTrackEvent.start + offsetTime)) {
                                    nextTrackEvent = overTrackEvent;
                                    startTime = overTrackEvent.start;
                                } else if (dragTime >= (overTrackEvent.end - offsetTime)) {
                                    nextTrackEvent = dragTrack.findNextTrackEvent(overTrackEvent);
                                    startTime = overTrackEvent.end;
                                } else {
                                    trackEvent._curStatus = null;
                                    dragTrack.restoreOld();
                                    return false;
                                }

                            } else {
                                nextTrackEvent = dragTrack.findNextTrackEventByTime(dragTime);
                                if (nextTrackEvent) {
                                    prevTrackEvent = dragTrack.findPrevTrackEvent(nextTrackEvent);
                                } else {
                                    prevTrackEvent = dragTrack.getLastTrackEvent();
                                }

                                startTime = dragTime;

                                if (prevTrackEvent) {
                                    if (startTime < prevTrackEvent.end) {
                                        startTime = prevTrackEvent.end;
                                    }
                                }
                                if (startTime <= (1 / util.frameRate)) {
                                    startTime = 0;
                                }


                            }

                            var len = dragData.trackEvent.popcornOptions.end - dragData.trackEvent.popcornOptions.start;

                            var autoAlignRs = app.media.autoAlign(trackEvent, startTime, startTime + len, 20);
                            startTime = autoAlignRs.startTime;

                            var ele = $(track.view.getTrackEventShadow()),
                                w = app.timeToPixel(len * 1000),
                                startX = app.timeToPixel(startTime * 1000);
                            ele.width(w);
                            ele.css({ left: startX + 'px' });
                            ele.removeClass("hidden");

                            if (nextTrackEvent) {

                                var t = dragTrack.findNextTrackEvents(nextTrackEvent);

                                util.forEach(t, function (item) {
                                    item.trackEvent.view.update({
                                        start: item.start + len,
                                        end: item.end + len
                                    });
                                });

                            }

                            trackEvent._curStatus = { start: startTime, end: startTime + len, nextTrackEvent: nextTrackEvent, move: true };




                        }
                        else {
                            //自由拖动
                            var x = dragData.left;
                            if (x <= 1) {
                                x = 0;
                            }


                            var dragStartTime = app.pixelToTime(x) / 1000,
                                dragEndTime = dragStartTime + (trackEvent.popcornOptions.end - trackEvent.popcornOptions.start),
                                startTime = dragStartTime,
                                endTime = dragEndTime,
                                ele = $(track.view.getTrackEventShadow()),
                                len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start,
                                nextTrackEvent = null;
                            //console.log("dragStartTime " + dragStartTime);

                            //var rangeTrackEvents = dragTrack.findRangeTrackEvents(dragStartTime, dragEndTime);

                            //if (rangeTrackEvents.length === 0) {
                            //    startTime = util.roundTime(startTime);
                            //    endTime = util.roundTime(endTime);
                            //    //console.log("round");
                            //    nextTrackEvent = dragTrack.findNextTrackEventByTime(endTime);
                            //} else {
                            //    if (rangeTrackEvents.length > 2) {
                            //        startTime = endTime = 0;
                            //    } else if (rangeTrackEvents.length == 2) {
                            //        startTime = rangeTrackEvents[0].end;
                            //        endTime = rangeTrackEvents[1].start;
                            //        console.log(startTime + ' ' + endTime);
                            //    } else {
                            //        if (startTime >= rangeTrackEvents[0].start &&
                            //            endTime <= rangeTrackEvents[0].end) {
                            //            startTime = endTime = 0;
                            //        } else if (startTime <= rangeTrackEvents[0].start) {
                            //            endTime = rangeTrackEvents[0].start;
                            //            startTime = endTime - len; //自由拖动不改变长度
                            //            nextTrackEvent = rangeTrackEvents[0];

                            //        } else {
                            //            startTime = rangeTrackEvents[0].end;
                            //            endTime = startTime + len;
                            //            nextTrackEvent = dragTrack.findNextTrackEventByTime(endTime);
                            //        }
                            //    }
                            //}

                            if (startTime < 0) {
                                startTime = 0;
                            }

                            var sevent = track.findTrackEventByTime(startTime);


                            var len = endTime - startTime;
                            if (len <= (1 / util.frameRate)) {
                                dragTrack.restoreOld();
                                ele.addClass("hidden");
                                trackEvent._curStatus = null;
                            } else {
                                var autoAlignRs = app.media.autoAlign(trackEvent, startTime, endTime, 20);
                                startTime = autoAlignRs.startTime;
                                endTime = autoAlignRs.endTime;

                                var w = app.timeToPixel(len * 1000),
                                startX = app.timeToPixel(startTime * 1000);
                                ele.width(w);
                                ele.css({ left: startX + 'px' });
                                ele.removeClass("hidden");

                                trackEvent._curStatus = { start: startTime, end: endTime, nextTrackEvent: nextTrackEvent, move: false };

                            }

                        }



                    }

                },
                dragged: function (draggedEvent, app, media,e) {
                    //console.log('dragged');
                    if (draggedEvent.data.track.trackType == "VAA" || draggedEvent.track.trackType == "AA") {

                        var trackEvent = draggedEvent.data,
                            track = trackEvent.track;

                        if (!trackEvent._curStatus) {
                            track.view.cancelDrag();
                        } else {
                            //
                          //  app.media.popcorn.suspend();
                            util.forEach(track.trackEvents, function (item) {
                                if (item === trackEvent) {
                                } else if (item.start !== item.view.start ||
                                    item.end !== item.view.end) {
                                    item.update({
                                        start: item.view.start,
                                        end: item.view.end
                                    });
                                }
                            });
                            trackEvent.update({
                                start: trackEvent._curStatus.start,
                                end: trackEvent._curStatus.start + (trackEvent.popcornOptions.end - trackEvent.popcornOptions.start)
                            });

                            //if (trackEvent._curStatus.nextTrackEvent) {
                            var nextTrackEvent = null;
                            if (trackEvent._curStatus.nextTrackEvent) {
                                nextTrackEvent = trackEvent._curStatus.nextTrackEvent.trackEvent;
                            }



                        //    app.media.popcorn.resume();
                            track.moveTrackEvent(trackEvent, nextTrackEvent);

                            util.forEach(track.trackEvents, function (item) {
                                if (item.attach) {
                                    item.plugin.updateAttach(app, item);
                                }
                            });

                            //  }

                        }
                    } else {
                       $(app.trackContainer.element).find("div.align-line").remove();
                        var trackEvent = draggedEvent.data,
                        track = trackEvent.track;
                        if (!trackEvent._curStatus) {
                            track.view.cancelDrag();
                        } else {
                            //
                            util.forEach(track.trackEvents, function (item) {
                                if (item === trackEvent) {
                                } else if (item.start !== item.view.start ||
                                    item.end !== item.view.end) {
                                    item.update({
                                        start: item.view.start,
                                        end: item.view.end
                                    });
                                }
                            });
                           // track.offsetTrackEventsByTime(trackEvent._curStatus.start, trackEvent._curStatus.end);
                            trackEvent.update({
                                start: trackEvent._curStatus.start,
                                end: trackEvent._curStatus.end
                            });
                            console.log("start:" + trackEvent._curStatus.start + "  end:" + trackEvent._curStatus.end);

                            //if (trackEvent._curStatus.nextTrackEvent) {
                            var nextTrackEvent = null;
                            if (trackEvent._curStatus.nextTrackEvent) {
                                nextTrackEvent = trackEvent._curStatus.nextTrackEvent.trackEvent;
                            }
                            track.moveTrackEvent(trackEvent, nextTrackEvent);
                            //  }

                        }
                    }
                },
                resize: function (resizeEvent, app, media, trackEvent) {
                    //console.log('resize');
                    var trackEventView = trackEvent.view,
                        direction = resizeEvent.direction,
                        trackEventStart = trackEvent.popcornOptions.start,
                        trackEventEnd = trackEvent.popcornOptions.end,
                        min, max,
                        track = trackEvent.track,
                        autoMove = (resizeEvent),// && resizeEvent.ctrlKey),
                        trackEvents = trackEvent.track.trackEvents,
                        oldNextTrackEvent = track.findNextTrackEvent(trackEvent),
                        oldPrevTrackEvent = track.findPrevTrackEvent(trackEvent),
                        startTime = trackEvent.popcornOptions.start,
                        endTime = trackEvent.popcornOptions.end,
                        offsetTime = 0;

                    // Only one of these two functions, onTrackEventResizedLeft or onTrackEventResizedRight,
                    // is run during resizing. Since all the max/min data is prepared ahead of time, we know
                    // the w/x values shouldn't grow/shrink past certain points.
                    function onTrackEventResizedLeft(trackEvent, x, w, resizeEvent) {
                        //console.log('onTrackEventResizedLeft');
                        //var diff = app.timeToPixel((trackEvent.popcornOptions.from - trackEvent.clipdata.from) * 1000);
                        //if ((x + diff) < min) {
                        //resizeEvent.blockIteration(min);
                        //    resizeEvent.blockIteration(max);
                        // }

                        if (x < max) {
                            resizeEvent.blockIteration(max);
                            startTime = util.roundTime(app.pixelToTime(max) / 1000);
                        }
                        else {
                            startTime = util.roundTime(app.pixelToTime(x) / 1000);
                        }
                        var autoAlignRs = app.media.autoAlign(trackEvent, startTime, endTime, 20, startTime);
                        startTime = autoAlignRs.startTime;
                    }

                    function onTrackEventResizedRight(trackEvent, x, w, resizeEvent) {
                        //console.log('onTrackEventResizedRight');
                        if (x + w >= max) {
                            resizeEvent.blockIteration(max);
                        }
                        else {
                            endTime = util.roundTime(app.pixelToTime(x + w) / 1000);
                            var autoAlignRs = app.media.autoAlign(trackEvent, startTime, endTime, 20, "", endTime);
                            endTime = autoAlignRs.endTime;
                        }
                    }

                    // Slightly different code paths for left and right resizing.
                    if (direction === "left") {
                        // Use trackEvents.reduce to find a valid minimum left value.
                        _nextEventMin = trackEvents.reduce(function (previousValue, otherTrackEvent) {
                            var popcornOptions = otherTrackEvent.popcornOptions;

                            // [ otherEvent ] [ otherEvent ] |<-- [ thisEvent ] [ otherEvent ]
                            return (otherTrackEvent !== trackEvent &&
                                      popcornOptions.end >= previousValue &&
                                      popcornOptions.end <= trackEventStart) ?
                                popcornOptions.end : previousValue;
                        }, 0);

                        // Rebase min value on pixels instead of time.
                        // Use clientLeft to compensate for border (https://developer.mozilla.org/en-US/docs/DOM/element.clientLeft).
                        //min = _nextEventMin / _media.duration * (_container.offsetWidth + trackEventView.element.clientLeft - TRACKEVENT_BORDER_OFFSET);
                        //min = app.timeToPixel((trackEvent.popcornOptions.start + (trackEvent.clipdata.from - trackEvent.popcornOptions.from)) * 1000);
                        min = app.timeToPixel(_nextEventMin * 1000);
                        //左侧x的最小值
                        //max = app.timeToPixel(((trackEvent.popcornOptions.end + (trackEvent.popcornOptions.from - trackEvent.clipdata.from))*1000));
                        //max = trackEvent.view.element.offsetLeft - app.timeToPixel((trackEvent.popcornOptions.from - trackEvent.clipdata.from) * 1000);
                        max = Math.max(0,trackEvent.view.element.offsetLeft - app.timeToPixel(trackEvent.popcornOptions.from * 1000));

                        // Only use the left handler.
                        trackEventView.setResizeHandler(onTrackEventResizedLeft);
                    }
                    else {
                        // Use trackEvents.reduce to find a valid maximum right value.
                        _nextEventMax = trackEvents.reduce(function (previousValue, otherTrackEvent) {
                            var popcornOptions = otherTrackEvent.popcornOptions;

                            // [ otherEvent ] [ otherEvent ] [ thisEvent ] -->| [ otherEvent ]
                            return (otherTrackEvent !== trackEvent &&
                                      popcornOptions.start <= previousValue &&
                                      popcornOptions.start >= trackEventEnd) ?
                                  (trackEvent.popcornOptions.start + (trackEvent.clipdata.duration - trackEvent.popcornOptions.from)) : previousValue;
                            //popcornOptions.start : previousValue;
                        }, (trackEvent.popcornOptions.start + (trackEvent.clipdata.duration - trackEvent.popcornOptions.from)));

                        // Rebase min value on pixels instead of time.
                        // Use clientLeft to compensate for border (https://developer.mozilla.org/en-US/docs/DOM/element.clientLeft).
                        max = app.timeToPixel(_nextEventMax * 1000);

                        // Only use the right handler.
                        trackEventView.setResizeHandler(onTrackEventResizedRight);
                    }

                    function onTrackEventResizeStopped() {
                        $(app.trackContainer.element).find("div.align-line").remove();
                        var newPopcornOptions = {},
                            newEnd, newStart, offset = false;


                        var w = trackEvent.view.element.clientWidth;
                        var newLen = app.pixelToTime(w) / 1000;

                        if (direction === "right") {
                            newPopcornOptions.start = startTime;
                            newPopcornOptions.end = endTime;

                            if (offsetTime !== 0) {
                                var t = track.findNextTrackEvents(oldNextTrackEvent);
                                util.forEach(t, function (item) {
                                    item.update({
                                        start: item.popcornOptions.start + offsetTime,
                                        end: item.popcornOptions.end + offsetTime
                                    });
                                });
                            }

                        }
                        else {
                            newPopcornOptions.start = startTime;
                            newPopcornOptions.end = endTime;
                            var newlen = (endTime - startTime);
                            var oldlen = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;
                            var from = trackEvent.popcornOptions.from + (oldlen - newlen);

                            newPopcornOptions.from = Math.max(from, 0);
                        }

                        trackEvent.update(newPopcornOptions);

                        media.updateDuration();


                        trackEventView.setResizeHandler(null);

                        trackEventView.removeEventListener("trackeventresizestopped", onTrackEventResizeStopped)


                    }
                    trackEventView.addEventListener("trackeventresizestopped", onTrackEventResizeStopped);

                },
                popcornPlugin: function () {
                    return "PopcornMediaPlugin";
                },
                name: function () {
                    return "VideoTrackEventPlugin";
                },

                parseData: function (element) {
                  var isAudio = element.getAttribute("data-audio") =="true"? true:false;
                  var data = {
                  data: {
                      source: element.getAttribute("data-url"),
                      title: element.getAttribute("data-name"),
                      icon: element.getAttribute("data-icon"),
                      clipid: element.getAttribute("data-id"),
                      audio:isAudio,
                      channel: element.getAttribute("data-channel"),
                      sourceid: element.getAttribute("data-source-id"),
                      createdate: element.getAttribute("data-createdate"),
                      from: +element.getAttribute("data-from"), //开始位置
                      duration: +element.getAttribute("data-duration") //结束位置
                  }
              };

              return data;

                },
                removeTrackEvent: function (trackEvent, ignoreUndo) {
                    if (trackEvent.track.trackType == "VAA" || trackEvent.track.trackType == "AA") {
                        trackEvent.track.removeTrackEvent(trackEvent, true, ignoreUndo);
                    } else {
                        trackEvent.track.removeTrackEvent(trackEvent, false, ignoreUndo);
                    }
                },
                canUpdateStart: function (trackEvent, p) {
                    var r = this._super(trackEvent, p);
                    if (!r.can) {
                        r.duration = p.duration + (r.end - p.end);
                    }

                    r.callback = function () {
                        var n = trackEvent.track.findNextTrackEvent(trackEvent);
                        if (n) {
                            trackEvent.track.offsetTrackEvent(n, -(n.popcornOptions.start - p.end));
                        }
                    };

                    return r;
                },
                canUpdateEnd: function (trackEvent, p) {
                    var r = this._super(trackEvent, p);
                    if (!r.can) {
                        //自动往后延展
                        r.end = p.end;
                        r.can = true;
                        //r.duration =
                        //r.duration = p.duration + (r.end - p.end);
                    }

                    r.callback = function () {
                        var n = trackEvent.track.findNextTrackEvent(trackEvent);
                        if (n) {
                            trackEvent.track.offsetTrackEvent(n, -(n.popcornOptions.start - p.end));
                        }
                    };

                    return r;
                },
                adjustTrackEvent: function (app, trackEvent, start, end) {
                    var offset = start - trackEvent.popcornOptions.start;

                    trackEvent.update({
                        start: start,
                        end: end,
                        from: trackEvent.popcornOptions.from + offset//,
                        //duration: trackEvent.popcornOptions.from + (end - start)

                    });

                },
                deleteRange: function (app, trackEvent, start, end) {
                    var oldEnd = trackEvent.popcornOptions.end,
                        oldStart =trackEvent.popcornOptions.start,
                        oldDuration = trackEvent.popcornOptions.duration,
                        oldFrom = trackEvent.popcornOptions.from,
                        clipDuration = trackEvent.clipdata.duration,
                        clipFrom = trackEvent.clipdata.from;

                    this.adjustTrackEvent(app, trackEvent, trackEvent.popcornOptions.start, start);

                    trackEvent.clipdata.from = clipFrom;
                    trackEvent.clipdata.duration = trackEvent.popcornOptions.duration;


                    var newTrackEvent = trackEvent.clone(trackEvent);
                    if (app.isChrome) {
                        var s = newTrackEvent.popcornOptions.source;
                        s = uri.stripUnique(s);

                        newTrackEvent.popcornOptions.source = uri.makeUnique(s).toString();
                    }
                    newTrackEvent.popcornOptions.start = end;
                    newTrackEvent.popcornOptions.end = oldEnd;
                    newTrackEvent.popcornOptions.from = oldFrom + (end - oldStart);
                    newTrackEvent.popcornOptions.duration = newTrackEvent.popcornOptions.from + (oldEnd - end);
                    newTrackEvent.clipdata.from = oldFrom + (start - oldStart);
                    newTrackEvent.clipdata.duration = oldDuration;

                    var nextTrackEvent = trackEvent.track.findNextTrackEvent(trackEvent);
                    if (nextTrackEvent) {
                        trackEvent.track.insertTrackEvent(newTrackEvent, nextTrackEvent, false, true);
                    } else {
                        trackEvent.track.addTrackEvent(newTrackEvent, true);
                    }

                    if (app.isChrome && app.service && app.service.getsignurl && newTrackEvent.clipdata.sourceid) {
                        newTrackEvent.updatesign();
                    }


                    return newTrackEvent;
                },
                splitTrackEvent: function (app, trackEvent, time) {
                    //剪刀功能
                    var nextTrackEvent = trackEvent.track.findNextTrackEvent(trackEvent);
                    var ns = time,
                        track = trackEvent.track,
                        ne = trackEvent.popcornOptions.end;
                    var newTrackEvent = trackEvent.clone(true);
                    if (app.isChrome) {
                        var s = newTrackEvent.popcornOptions.source;
                        s = uri.stripUnique(s);

                        newTrackEvent.popcornOptions.source = uri.makeUnique(s).toString();
                    }
                    newTrackEvent.popcornOptions.start = time;
                    newTrackEvent.popcornOptions.end = trackEvent.popcornOptions.end;

                    var len = time - trackEvent.popcornOptions.start;
                    //trackEvent.clipdata.duration = trackEvent.popcornOptions.from + len;
                    //var attachTrack;
                    //if (track.trackType == "VA") {
                    //    attachTrack = app.media.getNextTrack(track);
                    //}
                    //else if (track.trackType == "A") {
                    //    attachTrack = app.media.getPreviousTrack(track);
                    //}
                    //if (attachTrack && trackEvent.popcornOptions.attachEventId) {
                    //    var attachTrackEvent = attachTrack.findTrackEventByAttachEventId(trackEvent.popcornOptions.attachEventId);
                    //    if (attachTrackEvent) {
                    //        var newAttachTrackEvent = attachTrackEvent.clone(true);
                    //        if (app.isChrome) {
                    //            var s = newTrackEvent.popcornOptions.source;
                    //            s = uri.stripUnique(s);

                    //            newAttachTrackEvent.popcornOptions.source = uri.makeUnique(s).toString();
                    //        }
                    //        newAttachTrackEvent.popcornOptions.start = time;
                    //        newAttachTrackEvent.popcornOptions.end = trackEvent.popcornOptions.end;
                    //        attachTrackEvent.popcornOptions.attachEventId = trackEvent.popcornOptions.attachEventId = Guid.NewGuid().ToString("N");
                    //        newAttachTrackEvent.popcornOptions.attachEventId = newTrackEvent.popcornOptions.attachEventId = Guid.NewGuid().ToString("N");
                    //        attachTrackEvent.update({
                    //            start: trackEvent.popcornOptions.start,
                    //            from: trackEvent.popcornOptions.from,
                    //            end: time
                    //        });
                    //        newAttachTrackEvent.popcornOptions.from = newAttachTrackEvent.popcornOptions.from + len;
                    //        attachTrack.addTrackEvent(newAttachTrackEvent, true);
                    //    }
                    //}
                    trackEvent.update({
                        start: trackEvent.popcornOptions.start,
                        from: trackEvent.popcornOptions.from,
                        end: time
                    });

                    //len = newTrackEvent.popcornOptions.end - newTrackEvent.popcornOptions.start;
                    newTrackEvent.popcornOptions.from = trackEvent.popcornOptions.from + len;

                    //newTrackEvent.popcornOptions.duration = trackEvent.popcornOptions.duration;
                    //newTrackEvent.clipdata.from = newTrackEvent.popcornOptions.from;

                    if (nextTrackEvent) {
                        track.insertTrackEvent(newTrackEvent, nextTrackEvent, false, true);
                    } else {
                        track.addTrackEvent(newTrackEvent, true);
                    }
                    //选中新项 20160924 zxl
                    app.media.deselectAllTrackEvents();
                    //newTrackEvent.selected = true;

                    if (app.isChrome && app.service && app.service.getsignurl && newTrackEvent.clipdata.sourceid) {
                        newTrackEvent.updatesign();
                    }


                },
                showSplit: function (app, trackEvent) {
                    if (trackEvent.track.trackType == 'A') {
                        return true;
                    }
                },
                splitChanged: function (app, percent, trackEvent) {
                    trackEvent.update({
                        volume: Math.round(percent * 100) / 100
                    });
                },
                splitValue: function (app, trackEvent) {
                    var v = trackEvent.popcornOptions.volume;
                    return v;
                }



            });


            return VideoTrackEventPlugin;
        });
/*
 * 表示静态资源，TextTrackEventPlugin及ImageTrackEventPlugin的基类
 */
h5.define('core/StaticTrackEventPlugin', ["core/TrackEventPluginBase", "core/TrackEvent","util/util","core/DragTrack"],
        function (TrackEventPluginBase, TrackEvent, util, DragTrack) {
            var DRAG_IGNORE_WIDTH = 10; //拖动时容差 5px
            var DRAG_INSERT_WIDTH = 20; //插入操作
            var StaticTrackEventPlugin = TrackEventPluginBase.extend({
                init: function () {

                    this._super();
                },
                getPopcornOptions: function (track, data) {
                    var options = {
                        start: 0,
                        end: data.duration || 10,
                        text: data.text,
                        zindex : 100
                    };

                    return options;

                },
                dragOver: function (app, helper, mousePosition, data, e) {
                    var len = helper.data.data.duration,
                        ctrl = data.track.trackType == "A" || (e && e.ctrlKey), //e && e.ctrlKey,
                        track = data.track;

                    //按下ctrl为插入模式
                    //否则为自由模式
                    if (ctrl) {

                        var overTrackEvent = track.findTrackEventByTime(data.dragTime);


                        var nextTrackEvent = null,
                            prevTrackEvent = null,
                            startTime = 0;
                        if (overTrackEvent) {

                            var offsetTime = app.pixelToTime(DRAG_INSERT_WIDTH) / 1000;
                            if (data.dragTime <= (overTrackEvent.popcornOptions.start + offsetTime)) {
                                nextTrackEvent = overTrackEvent;
                                startTime = overTrackEvent.popcornOptions.start;
                            } else if (data.dragTime >= (overTrackEvent.popcornOptions.end - offsetTime)) {
                                nextTrackEvent = track.findNextTrackEvent(overTrackEvent);
                                startTime = overTrackEvent.popcornOptions.end;
                            } else {
                                helper._curStatus = null;
                                return false;
                            }

                        } else {
                            nextTrackEvent = track.findNextTrackEvent(data.dragTime);
                            if (nextTrackEvent) {
                                prevTrackEvent = track.findPrevTrackEvent(nextTrackEvent);
                            } else {
                                prevTrackEvent = track.getLastTrackEvent();
                            }

                            startTime = util.roundTime(data.startTime);

                            if (prevTrackEvent) {
                                if (data.startTime < prevTrackEvent.popcornOptions.end) {
                                    startTime = prevTrackEvent.popcornOptions.end;
                                }
                            }
                            if (startTime <= (1 / util.frameRate)) {
                                startTime = 0;
                            }


                        }

                        var autoAlignRs = app.media.autoAlign(overTrackEvent, startTime, startTime + len, 20);
                        startTime = autoAlignRs.startTime;

                        var ele = $(data.holderElement),
                            w = app.timeToPixel(len * 1000),
                            startX = app.timeToPixel( startTime * 1000);
                        ele.width(w);
                        ele.css({ left: startX + 'px' });

                        if (nextTrackEvent) {

                            var t = track.findNextTrackEvents(nextTrackEvent);

                            util.forEach(t, function (item) {
                                item.view.update({
                                    start: item.popcornOptions.start + len,
                                    end: item.popcornOptions.end + len
                                });
                            });

                        }

                        helper._curStatus = { start: startTime, end: startTime + len, nextTrackEvent: nextTrackEvent, move:true };


                        return true;

                    } else {

                        var overTrackEvent = track.findTrackEventByTime(data.dragTime);

                        var nextTrackEvent = null,
                            prevTrackEvent = null,
                            startTime = 0,
                            endTime = 0;
                       // if (overTrackEvent) {
                           // helper._curStatus = null;
                           // return false;

                       // } else {
                            startTime = util.roundTime(data.startTime);
                            if (startTime <= (1 / util.frameRate)) {
                                startTime = 0;
                            }

                            endTime = startTime + len;



                            //prevTrackEvent = track.findPrevTrackEvent(data.dragTime);
                            //nextTrackEvent = track.findNextTrackEvent(data.dragTime);

                           // if (prevTrackEvent) {
                               // if (startTime < prevTrackEvent.popcornOptions.end) {
                              //      startTime = prevTrackEvent.popcornOptions.end;
                            //    }
                            //}
                            //if (nextTrackEvent) {
                              //  if (endTime > nextTrackEvent.popcornOptions.start) {
                              //      endTime = nextTrackEvent.popcornOptions.start;
                             //   }
                           // }


                            //nextTrackEvent = track.findNextTrackEvent(data.startTime);
                            //if (nextTrackEvent) {
                            //    if (endTime > nextTrackEvent.popcornOptions.start) {
                            //        endTime = nextTrackEvent.popcornOptions.start;
                            //    }
                            //}

                            if ((endTime - startTime) <= (1 / util.frameRate)) {
                                helper._curStatus = null;
                                return false;
                            }


                        //}

                        var autoAlignRs = app.media.autoAlign(overTrackEvent, startTime, endTime, 20);
                        startTime = autoAlignRs.startTime;
                        endTime = autoAlignRs.endTime;

                        len = endTime - startTime;
                        var ele = $(data.holderElement),
                            w = app.timeToPixel(len * 1000),
                            startX = app.timeToPixel(startTime * 1000);
                        ele.width(w);
                        ele.css({ left: startX + 'px' });

                        helper._curStatus = { start: startTime, end: endTime, nextTrackEvent: nextTrackEvent, move: false };


                        return true;


                    }

                },
                dropped: function (droppedEvent, app, media, e, callback) {
                    var _this = this;
                    if (app.service.getObjectInfo && this.name() == "ImageTrackEventPlugin") {
                        app.service.getObjectInfo(droppedEvent.data, function (b, r) {
                            if (b) {
                                if (r.source) {
                                    droppedEvent.data.source = r.source;
                                }
                                if (r.icon) {
                                    droppedEvent.data.icon = r.icon;
                                }
                                if (r.duration) {
                                    droppedEvent.data.duration = r.duration;
                                }
                                if (r.from) {
                                    droppedEvent.data.from = r.from;
                                }

                                var te = __dropped.apply(_this);
                                if (callback) {
                                    callback(te);
                                }

                            } else {
                                console.error("获取对象信息失败");
                            }
                        });
                    } else {
                        var te = __dropped.apply(_this);
                        if (callback) {
                            callback(te);
                        }
                    }


                    //统一由H5TrackContainer处理
                    //$(app.trackContainer.element).find("div.align-line").remove();
                    //根据left计算项开始时间
                    //如果该处已存在项
                    //  如果是插入模式，自动调整后续项位置
                    //  如果是非插入模式，直接返回
                    //如果该处不存在项
                    //  直接添加项
                    //  检查结束位置，如果存在结束位置，使用结束位置，
                    //  如果结束位置大于后续项开始位置，自动调整
                    function __dropped() {
                        var type = droppedEvent.type,
                            track = droppedEvent.track,
                            data = droppedEvent.data,
                            left = droppedEvent.left,
                            dragData = droppedEvent.dragData,
                            insert = (e && e.ctrlKey) || track.trackType == 'A',//(e && e.ctrlKey),
                            popcornOptions = {},
                            minStart = 0,
                            offsetTime = 0,
                            nextTrackEvent,
                            prevTrackEvent;


                        if (dragData && dragData.helper) {
                            var trackEvent = null;
                            if (dragData.helper._curStatus) {
                                popcornOptions = this.getPopcornOptions(track, data);
                                if (!popcornOptions) {
                                    return;
                                }

                                //addby hzr 20161117 图片第一次加载到时间线上的时候图片保持原有比例
                                var imgwidth = $("img[src='" + dragData.helper.data.data.icon + "']").width();
                                var imgheight = $("img[src='" + dragData.helper.data.data.icon + "']").height();
                                var newheight = (imgheight * 16 * 0.5) / (imgwidth * 9) * 100;

                                if (newheight >= 100) {
                                    popcornOptions.width = ((imgwidth * 9) / (32 * imgheight)) * 100;
                                    popcornOptions.height = 50;
                                }

                                else {
                                    popcornOptions.width = 50;
                                    popcornOptions.height = newheight;
                                }

                                popcornOptions.width = 50;
                                popcornOptions.height = (imgheight * 16 * 0.5) / (imgwidth * 9) * 100;
                                popcornOptions.start = dragData.helper._curStatus.start;
                                popcornOptions.end = dragData.helper._curStatus.end;

                                trackEvent = new TrackEvent(app, {
                                    type: this.popcornPlugin(),
                                    clipdata: util.clone(data),
                                    dropType: droppedEvent.dropType,
                                    pluginType: type,
                                    plugin: this,
                                    popcornOptions: popcornOptions
                                });

                                //自动获取素材信息
                                //if (!data.detail) {
                                if (app.service && app.service.getobject && data && data.clipid) {
                                    app.service.getobject.call(app, data, function (b, clipinfo) {
                                        if (b) {
                                            trackEvent.clipdata.detail = clipinfo;
                                            trackEvent.clipdata.detail.__id = data.clipid;
                                        }
                                    });
                                }
                                //}
                                //track.removeTrackEvent(trackEvent, false, true);
                                //track.deleteTrackEventsByTime(trackEvent.popcornOptions.start, trackEvent.popcornOptions.end);
                                track.addTrackEvent(trackEvent);
                                //var nextTrackEvent = dragData.helper._curStatus.nextTrackEvent;

                                //if (nextTrackEvent) {

                                //    track.insertTrackEvent(trackEvent, nextTrackEvent, false);
                                //    if (dragData.helper._curStatus.move) {

                                //        track.offsetTrackEvent(nextTrackEvent, (popcornOptions.end - popcornOptions.start));
                                //    }
                                //} else {
                                //    track.addTrackEvent(trackEvent);
                                //}

                                dragData.helper._curStatus = null;

                            }

                            return trackEvent;

                        } else {
                            if (typeof data.start === "number") {
                                popcornOptions = this.getPopcornOptions(track, data);
                                if (!popcornOptions) {
                                    return;
                                }

                                popcornOptions.start = data.start;
                                popcornOptions.end = data.start + data.duration;
                               // var nextTrackEvent = track.findNextTrackEvent(data.start);
                               // if (nextTrackEvent && popcornOptions.end > nextTrackEvent.popcornOptions.start) {
                                //    popcornOptions.end = nextTrackEvent.popcornOptions.start;
                               // }





                                trackEvent = new TrackEvent(app, {
                                    type: this.popcornPlugin(),
                                    clipdata: util.clone(data),
                                    dropType: droppedEvent.dropType,
                                    pluginType: type,
                                    plugin: this,
                                    popcornOptions: popcornOptions
                                });


                                //自动获取素材信息
                                //if (!data.detail) {
                                if (app.service && app.service.getobject && data && data.clipid) {
                                    app.service.getobject.call(app, data, function (b, clipinfo) {
                                        if (b) {
                                            trackEvent.clipdata.detail = clipinfo;
                                            trackEvent.clipdata.detail.__id = data.clipid;
                                        }
                                    });
                                }
                                //}
                                //track.removeTrackEvent(trackEvent, false, true);
                                //track.deleteTrackEventsByTime(trackEvent.popcornOptions.start, trackEvent.popcornOptions.end);
                                track.addTrackEvent(trackEvent);
                                //if (nextTrackEvent) {

                                   // track.insertTrackEvent(trackEvent, nextTrackEvent, false);

                                //} else {
                                   // track.addTrackEvent(trackEvent);
                              //  }
                            }
                            return trackEvent;
                        }

                        //left = left - droppedEvent.pos[0];
                        //if (left < 0) {
                        //    left = 0;
                        //}

                        //var time = app.pixelToTime(left ) / 1000;
                        //var t = track.findTrackEventByTime(time);

                        //nextTrackEvent = track.findNextTrackEvent(time);

                        ////拖动容差


                        //var mustInsert = false;
                        //if (t && t.length) {
                        //    var minEnd = t.reduce(function (r, item) {
                        //        return Math.min(r, item.popcornOptions.end);
                        //    }, t[0].popcornOptions.end);

                        //    var pixel = app.timeToPixel((minEnd - time) * 1000);
                        //    if (pixel <= DRAG_IGNORE_WIDTH) {
                        //        time = minEnd;

                        //    }

                        //}

                        //if (insert && nextTrackEvent) {
                        //    mustInsert = true;
                        //}


                        //popcornOptions = this.getPopcornOptions(track, data);
                        //if (!popcornOptions) {
                        //    return;
                        //}

                        //popcornOptions.start = time;
                        //popcornOptions.end +=popcornOptions.start;

                        //nextTrackEvent = track.findNextTrackEvent(time);
                        //prevTrackEvent = track.findPrevTrackEvent(time);


                        ////清除格式
                        //if (nextTrackEvent) {
                        //    $(nextTrackEvent.view.element).removeClass('track-event-highlight');
                        //}
                        //if (prevTrackEvent) {
                        //    $(prevTrackEvent.view.element).removeClass('track-event-highlight');
                        //}

                        //if (mustInsert) {

                        //    if (prevTrackEvent) {
                        //        //自动收缩上一个项
                        //        if (prevTrackEvent.popcornOptions.end > popcornOptions.start) {

                        //            var newLen = popcornOptions.start - prevTrackEvent.popcornOptions.start;
                        //            if (newLen <= 1) {
                        //                //remove
                        //                track.removeTrackEvent(prevTrackEvent);
                        //            } else {

                        //                prevTrackEvent.update({
                        //                    start: prevTrackEvent.popcornOptions.start,
                        //                    end: popcornOptions.start
                        //                });
                        //            }
                        //        }
                        //    }

                        //    offsetTime = popcornOptions.end - popcornOptions.start;

                        //} else {

                        //    if (nextTrackEvent) {
                        //        if (popcornOptions.end > nextTrackEvent.popcornOptions.start) {
                        //            popcornOptions.end = nextTrackEvent.popcornOptions.start;
                        //        }
                        //    }
                        //    if (prevTrackEvent) {
                        //        if (popcornOptions.start < prevTrackEvent.popcornOptions.end) {
                        //            popcornOptions.start = prevTrackEvent.popcornOptions.end;
                        //        }
                        //    }

                        //    if ((popcornOptions.end - popcornOptions.start) < 1) {
                        //        return;
                        //    }
                        //}

                        //var trackEvent = new TrackEvent(app, {
                        //    type: this.popcornPlugin(),
                        //    clipdata: data,
                        //    dropType: droppedEvent.dropType,
                        //    pluginType: type,
                        //    plugin: this,
                        //    popcornOptions: popcornOptions
                        //});





                        //if (nextTrackEvent) {
                        //    track.insertTrackEvent(trackEvent, nextTrackEvent, false);
                        //} else {
                        //    track.addTrackEvent(trackEvent);
                        //}

                        //if (mustInsert && offsetTime && nextTrackEvent) {
                        //    //位移
                        //    track.offsetTrackEvent(nextTrackEvent, offsetTime);

                        //}

                        //return trackEvent;
                    }
                },
                dragged: function (draggedEvent, app, media, e) {
                    $(app.trackContainer.element).find("div.align-line").remove();
                    var trackEvent = draggedEvent.data,
                        left = draggedEvent.left,
                        track = draggedEvent.track,
                        autoMove = true,//(e && e.ctrlKey),
                        nextTrackEvent = null,
                        prevTrackEvent = null,
                        oldNextTrackEvent = track.findNextTrackEvent(trackEvent),
                        oldPrevTrackEvent = track.findPrevTrackEvent(trackEvent);

                    track.removeTrackEvent(trackEvent, false);

                    trackEvent.view.element.style.top = "0";
                    if (left <= 1) {
                        left = 0;
                    }
                    var time = Math.round(app.pixelToTime(left)) / 1000;
                    var len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;
                    nextTrackEvent = track.findNextTrackEvent(time);
                    prevTrackEvent = track.findPrevTrackEvent(time);


                    if (!autoMove) {
                        var range = track.findRangeTrackEvent(time, time + len);


                        if (nextTrackEvent ) {

                            var afterEvent = nextTrackEvent ;
                            //自动移动
                            var handlerTime = app.pixelToTime(DRAG_INSERT_WIDTH) / 1000;


                            var s = afterEvent.popcornOptions.start;
                            var leftLimit = s - handlerTime;

                            if (prevTrackEvent == null) {
                                leftLimit = 0;
                            }else if (prevTrackEvent && prevTrackEvent.popcornOptions.end <(s - handlerTime) ) {
                                leftLimit = prevTrackEvent.popcornOptions.end;

                            }

                            //当前点位于 上一项之后且结束时间在下一个项开始之后
                            if (time >= leftLimit && time <= (s + handlerTime) && (time + len) > nextTrackEvent.popcornOptions.start) {
                                //位于插入操作区

                                var newStart = time;
                                if (prevTrackEvent) {
                                    if (newStart < prevTrackEvent.popcornOptions.end) {
                                        newStart = prevTrackEvent.popcornOptions.end;
                                    }
                                }

                                trackEvent.popcornOptions.start = newStart;
                                trackEvent.popcornOptions.end = newStart + len;

                                track.insertTrackEvent(trackEvent, afterEvent, true);

                                return;

                            }



                        }




                        if (range && range.length > 0) {
                            //不允许
                            if (oldNextTrackEvent) {
                                track.insertTrackEvent(trackEvent, oldNextTrackEvent, false);
                            } else {
                                track.addTrackEvent(trackEvent);
                            }
                        } else {
                            //直接放入新项
                            trackEvent.popcornOptions.start = time;
                            trackEvent.popcornOptions.end = time + len;

                            if (nextTrackEvent) {
                                track.insertTrackEvent(trackEvent, nextTrackEvent, false);
                            } else {
                                track.addTrackEvent(trackEvent);
                            }
                        }



                        return;
                    } else {

                        //拖动时自动移动
                        //if (nextTrackEvent) {
                        //}
                        var leftLimit = 0;
                        if (oldPrevTrackEvent) {
                            leftLimit = oldPrevTrackEvent.popcornOptions.end;
                        }

                        var offsetTime = 0;
                        if (time < leftLimit) {
                            //不允许

                            // track.insertTrackEvent(trackEvent, nextTrackEvent, false);
                            return;
                        } else {
                            offsetTime = time - trackEvent.popcornOptions.start;
                            trackEvent.popcornOptions.start = time;
                            trackEvent.popcornOptions.end = time + len;
                        }


                        if (oldNextTrackEvent) {
                            track.insertTrackEvent(trackEvent, oldNextTrackEvent, false);
                            if (offsetTime !== 0) {
                                track.offsetTrackEvent(oldNextTrackEvent, offsetTime);
                            }
                        } else {
                            track.addTrackEvent(trackEvent);
                        }

                    }

                },
                startDrag: function (app, media, dragData, e) {
                    //先删除
                    var trackEvent = dragData.trackEvent,
                        track = dragData.track,
                        ctrl = dragData.track.trackType == "A" || (e && e.ctrlKey);//(e && e.ctrlKey);
                    var len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;

                    if (ctrl) {
                        //自动收缩
                        if (dragData.nextTrackEvent) {
                            var t = track.findNextTrackEvents(dragData.nextTrackEvent);
                            util.forEach(t, function (item) {
                                item.view.update({
                                    start: item.popcornOptions.start - len,
                                    end: item.popcornOptions.end - len
                                });
                            });
                        }
                    } else {
                    }

                    //备份
                    var t = [];
                    util.forEach(track.trackEvents, function (item) {
                        if (item === trackEvent) {
                        } else {
                            var ds = {
                                trackEvent: item,
                                start: item.view.start,
                                end: item.view.end,
                                offset: $(item.view.element).offset(),
                                left: parseFloat($(item.view.element).css("left")),
                                width: $(item.view.element).width()
                            };
                            console.log('start: ' + ds.start);
                            t.push(ds);
                        }
                    });
                    trackEvent._dragStartStatus = t;
                    trackEvent._curStatus = null;
                },
                dragging: function (app, media, dragData,e) {
                    var trackEvent = dragData.trackEvent,
                        track = dragData.track,
                        ctrl = dragData.track.trackType == "A" || (e && e.ctrlKey),//(e && e.ctrlKey),
                        dragTrack = new DragTrack(trackEvent._dragStartStatus);




                    if (ctrl) {
                        //插入模式

                        dragTrack.restoreOld();

                        var x = dragData.left;
                        if (x <= 1) {
                            x = 0;
                        }

                        var  dragTime = app.pixelToTime(x) / 1000;

                        var overTrackEvent = dragTrack.findTrackEvent(dragTime);


                        var nextTrackEvent = null,
                            prevTrackEvent = null,
                            startTime = 0;
                        if (overTrackEvent) {
                            var offsetTime = app.pixelToTime(DRAG_INSERT_WIDTH) / 1000;
                            if (dragTime <= (overTrackEvent.start + offsetTime)) {
                                nextTrackEvent = overTrackEvent;
                                startTime = overTrackEvent.start;
                            } else if (dragTime >= (overTrackEvent.end - offsetTime)) {
                                nextTrackEvent = dragTrack.findNextTrackEvent(overTrackEvent);
                                startTime = overTrackEvent.end;
                            } else {
                                trackEvent._curStatus = null;
                                dragTrack.restoreOld();
                                return false;
                            }

                        } else {
                            nextTrackEvent = dragTrack.findNextTrackEventByTime(dragTime);
                            if (nextTrackEvent) {
                                prevTrackEvent = dragTrack.findPrevTrackEvent(nextTrackEvent);
                            } else {
                                prevTrackEvent = dragTrack.getLastTrackEvent();
                            }

                            startTime = dragTime;

                            if (prevTrackEvent) {
                                if (startTime < prevTrackEvent.end) {
                                    startTime = prevTrackEvent.end;
                                }
                            }
                            if (startTime <= (1 / util.frameRate)) {
                                startTime = 0;
                            }


                        }

                        var len = dragData.trackEvent.popcornOptions.end - dragData.trackEvent.popcornOptions.start;

                        var autoAlignRs = app.media.autoAlign(trackEvent, startTime, startTime + len, 20);
                        startTime = autoAlignRs.startTime;

                        var ele = $(track.view.getTrackEventShadow()),
                            w = app.timeToPixel(len * 1000),
                            startX = app.timeToPixel(startTime * 1000);
                        ele.width(w);
                        ele.css({ left: startX + 'px' });
                        ele.removeClass("hidden");

                        if (nextTrackEvent) {

                            var t = dragTrack.findNextTrackEvents(nextTrackEvent);

                            util.forEach(t, function (item) {
                                item.trackEvent.view.update({
                                    start: item.start + len,
                                    end: item.end + len
                                });
                            });

                        }

                        trackEvent._curStatus = { start: startTime, end: startTime + len, nextTrackEvent: nextTrackEvent, move: true };




                    }
                    else {
                        //自由拖动
                        var x = dragData.left;
                        if (x <= 1) {
                            x = 0;
                        }


                        var dragStartTime = app.pixelToTime(x) / 1000,
                            dragEndTime = dragStartTime + (trackEvent.popcornOptions.end - trackEvent.popcornOptions.start),
                            startTime = dragStartTime,
                            endTime = dragEndTime,
                            ele = $(track.view.getTrackEventShadow()),
                            len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start,
                            nextTrackEvent = null;

                        var ignoreTrackEvent;
                        //console.log("dragStartTime " + dragStartTime);

                        var rangeTrackEvents = dragTrack.findRangeTrackEvents(dragStartTime, dragEndTime);

                        if (rangeTrackEvents.length === 0) {
                            startTime = util.roundTime(startTime);
                            endTime = util.roundTime(endTime);
                            //console.log("round");
                            nextTrackEvent = dragTrack.findNextTrackEventByTime( endTime);
                        } else {
                            //if (rangeTrackEvents[0].start < startTime) {
                            //    startTime = util.roundTime(rangeTrackEvents[rangeTrackEvents.length-1].end);
                            //    endTime = util.roundTime(endTime);
                            //    //console.log("round");
                            //    nextTrackEvent = dragTrack.findTrackEvent(startTime - 0.03);
                            //    if (nextTrackEvent) {
                            //        ignoreTrackEvent = nextTrackEvent.trackEvent;
                            //    }
                            //}
                            //else {
                                startTime = util.roundTime(startTime);
                                endTime = util.roundTime(endTime);
                                //
                                nextTrackEvent = dragTrack.findNextTrackEventByTime(endTime);
                                if (nextTrackEvent) {
                                    ignoreTrackEvent = nextTrackEvent.trackEvent;
                                }
                            //}
                            //if (rangeTrackEvents.length > 2) {
                            //    startTime = endTime = 0;
                            //} else if (rangeTrackEvents.length == 2) {
                            //    startTime = rangeTrackEvents[0].end;
                            //    endTime = rangeTrackEvents[1].start;
                            //    console.log(startTime + ' ' + endTime);
                            //} else {
                                //if (startTime >= rangeTrackEvents[0].start &&
                                //    endTime <= rangeTrackEvents[0].end) {
                                //    startTime = endTime = 0;
                                //} else if (startTime <= rangeTrackEvents[0].start) {
                                //    endTime = rangeTrackEvents[0].start;
                                //    startTime = endTime - len; //自由拖动不改变长度
                                //    nextTrackEvent = rangeTrackEvents[0];

                                //} else {
                                //    startTime = rangeTrackEvents[0].end;
                                //    endTime = startTime + len;
                                //    nextTrackEvent = dragTrack.findNextTrackEventByTime(endTime);
                                //}
                            //}
                        }
                        //var p = track.findSpaceDuration(dragStartTime, dragEndTime, trackEvent);
                        //startTime = p.start;
                        //endTime = p.end;
                        if (startTime < 0) {
                            startTime = 0;
                        }

                        var sevent = track.findTrackEventByTime(startTime);
                        var len = endTime - startTime;


                        if (len <= (1 / util.frameRate)) {
                            dragTrack.restoreOld();
                            ele.addClass("hidden");
                            trackEvent._curStatus = null;
                        } else {
                            var autoAlignRs = app.media.autoAlign(trackEvent, startTime, endTime, 20, undefined, undefined, ignoreTrackEvent);
                            startTime = autoAlignRs.startTime;
                            endTime = autoAlignRs.endTime;
                            len = endTime - startTime;
                            var w = app.timeToPixel(len * 1000),
                            startX = app.timeToPixel(startTime * 1000);
                            ele.width(w);
                            ele.css({ left: startX + 'px' });
                            ele.removeClass("hidden");

                            trackEvent._curStatus = { start: startTime, end: endTime, nextTrackEvent: nextTrackEvent, move: false };

                        }

                    }




                },
                dragged: function (draggedEvent, app, media, e) {
                    $(app.trackContainer.element).find("div.align-line").remove();
                    var trackEvent = draggedEvent.data,
                        track = trackEvent.track;

                    if (!trackEvent._curStatus) {
                        track.view.cancelDrag();
                    } else {
                        //删除curStatus之前的event
                        util.forEach(track.trackEvents, function (item) {
                            if (item === trackEvent) {
                            } else if (item.start !== item.view.start ||
                                item.end !== item.view.end) {
                                item.update({
                                    start: item.view.start,
                                    end: item.view.end
                                });
                            }
                        });
                        //track.offsetTrackEventsByTime(trackEvent._curStatus.start, trackEvent._curStatus.end);
                        //track.removeTrackEvent(trackEvent, false, true);
                        //track.deleteTrackEventsByTime(trackEvent._curStatus.start, trackEvent._curStatus.end);
                        //track.addTrackEvent(trackEvent, true);
                        //var p = track.findSpaceDuration(trackEvent._curStatus.start, trackEvent._curStatus.end, trackEvent)

                        trackEvent.update({
                            start: trackEvent._curStatus.start,
                            end: trackEvent._curStatus.end
                        });

                        console.log("start:" + trackEvent._curStatus.start + "  end:" + trackEvent._curStatus.end);

                        //if (trackEvent._curStatus.nextTrackEvent) {
                        var nextTrackEvent = null;
                        if (trackEvent._curStatus.nextTrackEvent) {
                            nextTrackEvent = trackEvent._curStatus.nextTrackEvent.trackEvent;
                        }
                        track.moveTrackEvent(trackEvent, nextTrackEvent);
                        //  }

                    }

                },
                resize: function (resizeEvent, app, media, trackEvent) {
                    var trackEventView = trackEvent.view,
                        direction = resizeEvent.direction,
                        trackEventStart = trackEvent.popcornOptions.start,
                        trackEventEnd = trackEvent.popcornOptions.end,
                        min, max,
                        track = trackEvent.track,
                        trackEvents = trackEvent.track.trackEvents,
                        autoMove = trackEvent.track.trackType == "A" &&(resizeEvent), //&& resizeEvent.ctrlKey),
                        oldNextTrackEvent = track.findNextTrackEvent(trackEvent),
                        oldPrevTrackEvent = track.findPrevTrackEvent(trackEvent),
                        startTime = trackEvent.popcornOptions.start,
                        endTime = trackEvent.popcornOptions.end,
                        offsetTime = 0;



                    function onTrackEventResizedLeft(trackEvent, x, w, resizeEvent) {
                        if (x < max) {
                            resizeEvent.blockIteration(max);
                            startTime = util.roundTime(app.pixelToTime(max) / 1000);
                        } else {
                            startTime = util.roundTime(app.pixelToTime(x) / 1000);
                        }
                        var autoAlignRs = app.media.autoAlign(trackEvent, startTime, endTime, 20, startTime);
                        startTime = autoAlignRs.startTime;
                    }

                    function onTrackEventResizedRight(trackEvent, x, w, resizeEvent) {
                        endTime = util.roundTime(app.pixelToTime(x + w) / 1000);

                        if (autoMove) {
                            var diffTime = endTime - trackEvent.popcornOptions.end;
                            if (diffTime != 0 && oldNextTrackEvent) {
                                offsetTime = diffTime;
                                console.log(offsetTime);
                                var t = track.findNextTrackEvents(oldNextTrackEvent);
                                util.forEach(t, function (item) {
                                    item.view.update({
                                        start: item.popcornOptions.start + diffTime,
                                        end: item.popcornOptions.end + diffTime
                                    });
                                });
                            } else {
                                offsetTime = 0;
                                console.log("offset o");
                            }
                        } else {
                            if (max > 0) {
                                if ((x + w) > max) {
                                    //move
                                    var diffTime = endTime - oldNextTrackEvent.popcornOptions.start;
                                    offsetTime = diffTime;
                                    var t = track.findNextTrackEvents(oldNextTrackEvent);
                                    util.forEach(t, function (item) {
                                        item.view.update({
                                            start: item.popcornOptions.start + diffTime,
                                            end: item.popcornOptions.end + diffTime
                                        });
                                    });

                                } else {
                                    offsetTime = 0;
                                }
                            } else {
                                offsetTime = 0;
                            }
                        }
                        var autoAlignRs = app.media.autoAlign(trackEvent, startTime, endTime, 20, "", endTime);
                        endTime = autoAlignRs.endTime;

                        //if (max > 0 && (x + w) > max) {
                        //    resizeEvent.blockIteration(max);
                        //    endTime = util.roundTime(app.pixelToTime(max) / 1000);
                        //} else {
                        //    endTime = util.roundTime(app.pixelToTime(x + w) / 1000);
                        //}
                    }

                    if (direction === "left") {

                        var minTime = 0;
                        //if (oldPrevTrackEvent) {
                        //    minTime = oldPrevTrackEvent.popcornOptions.end;
                        //}


                        max = app.timeToPixel(minTime * 1000);
                        trackEventView.setResizeHandler(onTrackEventResizedLeft);
                    }
                    else {
                        maxTime = -1;

                       // if (!autoMove) {
                            //if (oldNextTrackEvent) {
                            //    maxTime = oldNextTrackEvent.popcornOptions.start;
                            //}
                       // }
                        if (maxTime > 0) {
                            max = app.timeToPixel(maxTime * 1000);
                        }
                        else {
                            max = -1;
                        }

                        trackEventView.setResizeHandler(onTrackEventResizedRight);
                    }

                    function onTrackEventResizeStopped() {
                        $(app.trackContainer.element).find("div.align-line").remove();
                        var newPopcornOptions = {},
                            newEnd, newStart, offset = false;


                        var w = trackEvent.view.element.clientWidth;
                        var newLen = app.pixelToTime(w) / 1000;

                        if (direction === "right") {
                            newPopcornOptions.start = startTime;
                            newPopcornOptions.end = endTime;

                            if (offsetTime !== 0) {
                                var t = track.findNextTrackEvents(oldNextTrackEvent);
                                util.forEach(t, function (item) {
                                    item.update({
                                        start: item.popcornOptions.start + offsetTime,
                                        end: item.popcornOptions.end + offsetTime
                                    });
                                });
                            }

                        }
                        else {
                            newPopcornOptions.start = startTime;
                            newPopcornOptions.end = endTime;
                        }

                        trackEvent.update(newPopcornOptions);

                        media.updateDuration();


                        trackEventView.setResizeHandler(null);

                        trackEventView.removeEventListener("trackeventresizestopped", onTrackEventResizeStopped);
                    }

                    trackEventView.addEventListener("trackeventresizestopped", onTrackEventResizeStopped);

                },
                removeTrackEvent: function (trackEvent, ignoreUndo) {

                    trackEvent.track.removeTrackEvent(trackEvent, false, ignoreUndo);

                }
            });


            return StaticTrackEventPlugin;
        });
/*
 * 字幕插件
 */
h5.define('core/TextTrackEventPlugin', ["core/StaticTrackEventPlugin", "core/TrackEvent", "util/util"],
        function (StaticTrackEventPlugin, TrackEvent, util) {

            var TextTrackEventPlugin = StaticTrackEventPlugin.extend({
                init: function () {

                    this._super();
                },
                getPopcornOptions: function (track, data) {
                    var options = {
                        start: 0,
                        end:  util.roundTime( data.duration || 10),
                        text: data.text,
                        icon: '.textIcon',
                        clipid: data.clipid,
                        zindex: 110 - track.order
                    };

                    if (data.shadow) {
                        options.shadow = data.shadow;
                    }
                    if (data.position) {
                        options.position = data.position;
                    }
                    if (data.shadowColor) {
                        options.shadowColor = data.shadowColor;
                    }
                    if (data.fontColor) {
                        options.fontColor = data.fontColor;
                    }



                    return options;

                },
                canProcess: function (dropType, pluginType, data) {
                    if (pluginType === "text") {
                        return true;
                    }
                    return false;
                },
                canDrop: function (trackType) {
                    if (trackType === 'GC') {
                        return true;
                    }
                    return false;
                },
                popcornPlugin: function () {
                    return "PopcornTextPlugin";
                },
                name: function () {
                    return "TextTrackEventPlugin";
                },
                parseData: function (element) {
                    var ele = $(element);
                    var data = {
                        data: {
                            text: ele.data("text"),
                            clipid: ele.data("id"),
                            duration: +ele.data("duration") //结束位置
                        }
                    };

                    var position = ele.data("position");
                    if (position) {
                        data.data.position = position;
                    }
                    var fontColor = ele.data("fontcolor");
                    if (fontColor) {
                        data.data.fontColor = fontColor;
                    }
                    var shadow = ele.data("shadow");
                    if (shadow && shadow == true) {
                        data.data.shadow = true;
                    }
                    var shadowcolor = ele.data("shadowcolor");
                    if (shadowcolor) {
                        data.data.shadowColor = shadowcolor;
                    }


                    return data;
                }

            });


            return TextTrackEventPlugin;
        });
/*
 * 图片插件
 */
h5.define('core/ImageTrackEventPlugin', ["core/StaticTrackEventPlugin", "util/util"],
        function (StaticTrackEventPlugin, util) {

            var ImageTrackEventPlugin = StaticTrackEventPlugin.extend({
                init: function () {

                    this._super();
                },
                getPopcornOptions: function (track, data) {
                    var options = {
                        start: 0,
                        end: util.roundTime( data.duration || 10),
                        src: data.source,
                        icon: data.icon,
                        title: data.title,
                        clipid: data.clipid,
                        createdate: data.createdate,
                        zindex: 110 - track.order
                    };

                    return options;

                },
                canProcess: function (dropType, pluginType, data) {
                    if (pluginType === "image") {
                        return true;
                    }
                    return false;
                },
                canDrop: function (trackType) {
                    if (trackType === 'PIC') {
                        return true;
                    }
                    return false;
                },
                popcornPlugin: function () {
                    return "PopcornImagePlugin";
                },
                name: function () {
                    return "ImageTrackEventPlugin";
                },
                parseData: function (element) {
                    var ele = $(element);
                    var data = {
                        data: {
                            source: ele.data("url"),
                            title: ele.data("name"),
                            icon: ele.data("icon"),
                            clipid: ele.data("id"),
                            sourceid: ele.data("source-id"),
                            createdate: ele.data("createdate"),
                            duration: +ele.data("duration") //结束位置
                        }
                    };

                    return data;
                }

            });


            return ImageTrackEventPlugin;
        });
/*
 * 特效插件
 */
h5.define('core/EffectTrackEventPlugin', ["core/StaticTrackEventPlugin", "core/TrackEvent", "util/util"],
        function (StaticTrackEventPlugin, TrackEvent, util) {

            var EffectTrackEventPlugin = StaticTrackEventPlugin.extend({
                init: function () {

                    this._super();
                },
                getPopcornOptions: function (track, data) {
                    var options = {
                        start: 0,
                        end:  util.roundTime( data.duration || 10),
                        effectType: data.effectType || 'GRAY',
                        icon: '.effectIcon',
                        title: data.title || '',
                        clipid: data.clipid,
                        zindex: 110 - track.order
                    };

                    if (isNaN(options.duration)) {
                        options.end = 10;
                    }

                    return options;

                },
                canProcess: function (dropType, pluginType, data) {
                    if (pluginType === "effect") {
                        return true;
                    }
                    return false;
                },
                canDrop: function (trackType) {
                    if (trackType === 'ET') {
                        return true;
                    }
                    return false;
                },
                popcornPlugin: function () {
                    return "PopcornEffectPlugin";
                },
                name: function () {
                    return "EffectTrackEventPlugin";
                },
                parseData: function (element) {
                    var ele = $(element);
                    var data = {
                        data: {
                            effectType: ele.data("effect"),
                            title: ele.data("name"),
                            duration: +ele.data("duration") //结束位置
                        }
                    };

                    return data;
                }

            });


            return EffectTrackEventPlugin;
        });
/// <reference path="../timelineplayer-wrapped.js" />
/*
 * 表示转场动画
 */
h5.define('core/TransitionTrackEventPlugin', ["core/TrackEventPluginBase", "core/TrackEvent", "util/util", "core/DragTrack"],
        function (TrackEventPluginBase, TrackEvent, util, DragTrack) {
            var DRAG_IGNORE_WIDTH = 10; //拖动时容差 5px
            var DRAG_WIDTH = 20; //插入操作
            var TransitionTrackEventPlugin = TrackEventPluginBase.extend({
                init: function () {

                    this._super();
                },
                getPopcornOptions: function (track, data) {
                    var options = {
                        start: 0,
                        transition:'',
                        end: data.duration || 10,
                        title: data.title,
                        zindex: 100
                    };
                    options.transition = data.transition;

                    return options;

                },
                canProcess: function (dropType, pluginType, data) {
                    if (pluginType === "transition") {
                        return true;
                    }
                    return false;
                },
                dragOver: function (app, helper, mousePosition, data, e) {
                    var track = data.track,
                        startTime = data.startTime,
                        endTime = data.endTime,
                        _this = this;
                    var transition = helper.data.data.transition,
                        manifest = TimelinePlayer.manifest.transitionManifest,
                        plugin = TimelinePlayer.pluginList[this.popcornPlugin()];
                    if (!plugin) {
                        return false;
                    }

                    var tp = plugin._getPlugin(transition),
                        tm = tp.manifest,
                        len = tm.DURATION ;



                    if (startTime < 0) {
                        startTime = 0;
                    }

                    var trackEvents = track.findRangeTrackEvent(startTime, endTime, function (item) {
                        return true;
                    });
                    var isProcessed = false;
                    helper._ALIGN = 0;
                    helper._STARTTIME = 0;
                    helper._ENDTIME = 0;
                    helper._RIGHTOFFSET = 0;
                    helper._LEFTOFFSET = 0;
                    helper._DURATION = len;
                    helper._RELATIVETRACKEVENTS = [];

                    function attachLeft(te) {
                        helper._ALIGN = manifest.ALIGN_LEFT;
                        helper._STARTTIME = te.popcornOptions.end - len;
                        if (helper._STARTTIME < te.popcornOptions.start) {
                            helper._STARTTIME = te.popcornOptions.start;
                        }
                        helper._ENDTIME = te.popcornOptions.end;
                        helper._RELATIVETRACKEVENTS.push(te);
                    }
                    function attachRight(te) {
                        helper._ALIGN = manifest.ALIGN_RIGHT;
                        helper._STARTTIME = te.popcornOptions.start;
                        helper._ENDTIME = helper._STARTTIME + len;
                        if (helper._ENDTIME > te.popcornOptions.end) {
                            helper._ENDTIME = te.popcornOptions.end;
                        }
                        helper._RELATIVETRACKEVENTS.push(te);
                    }

                    if (trackEvents.length == 0) {
                        return false;
                    }else if (trackEvents.length == 1) {
                        //只有一个
                        //开头  或 结尾
                        var trackEvent = trackEvents[0];
                        var diff1 = startTime - trackEvent.popcornOptions.start;
                        var x1 = app.timeToPixel(diff1 * 1000);
                        var diff2 = trackEvent.popcornOptions.end - endTime;
                        var x2 = app.timeToPixel(diff2 * 1000);
                        if (x1 <= DRAG_WIDTH) {
                            //是attchRight...
                            attachRight(trackEvent);
                        }
                        else if (x2 <= DRAG_WIDTH) {
                            attachLeft(trackEvent);
                        }
                    } else {
                        var mediaEvents = [];
                        var transitionEvents = [];
                        util.forEach(trackEvents, function (item) {
                            if (item.plugin == _this) {
                                transitionEvents.push(item);
                            } else {
                                mediaEvents.push(item);
                            }
                        });


                        if (mediaEvents.length == 1 && transitionEvents.length > 0) {
                            //区间内已经有了转场动画
                            return false;
                        } else {
                            if (transitionEvents.length == 0) {
                                var leftTrackEvent = mediaEvents[0];
                                var rightTrackEvent = mediaEvents[1];
                                //OVERLAPCENTER CENTER LEFT RIGHT
                                if( (tm.ALIGN & manifest.ALIGN_OVERLAP)==manifest.ALIGN_OVERLAP){
                                    //支持覆盖居中

                                    if ((rightTrackEvent.popcornOptions.from - len / 2) > 0 && ( leftTrackEvent.popcornOptions.duration + len /2) < leftTrackEvent.clipdata.duration ) {
                                        helper._ALIGN = manifest.ALIGN_OVERLAP;
                                        helper._RIGHTOFFSET = len / 2;
                                        helper._STARTTIME = leftTrackEvent.popcornOptions.end - len / 2;
                                        helper._ENDTIME = helper._STARTTIME + len;
                                        helper._RELATIVETRACKEVENTS.push(leftTrackEvent, rightTrackEvent);
                                    }
                                }
                                if (helper._ALIGN == 0) {
                                    if ((tm.ALIGN & manifest.ALIGN_CENTER) == manifest.ALIGN_CENTER) {
                                        //一般居中
                                        helper._ALIGN = manifest.ALIGN_CENTER;
                                        helper._STARTTIME = leftTrackEvent.popcornOptions.end - len / 2;
                                        helper._ENDTIME = helper._STARTTIME + len;
                                        helper._RELATIVETRACKEVENTS.push(leftTrackEvent, rightTrackEvent);
                                    }
                                }
                                if (helper._ALIGN == 0) {
                                    //居左或居右
                                    if ((tm.ALIGN & (manifest.ALIGN_LEFT | manifest.ALIGN_RIGHT)) != 0) {
                                        //选最多的一边
                                        var diff1 = endTime - rightTrackEvent.popcornOptions.end;
                                        var diff2 = leftTrackEvent.popcornOptions.end - startTime;
                                        if (diff2 > diff1) {
                                            //居左
                                            attachLeft(leftTrackEvent);
                                        } else {
                                            attachRight(rightTrackEvent);
                                        }

                                    } else if( (tm.ALIGN & manifest.ALIGN_LEFT)== manifest.ALIGN_LEFT)  {
                                        attachLeft(leftTrackEvent);
                                    } else if ((tm.ALIGN & manifest.ALIGN_RIGHT) == manifest.ALIGN_RIGHT) {
                                        attachRight(rightTrackEvent);
                                    }
                                }
                            }
                        }
                    }

                    if (helper._ALIGN == 0) {
                        return false;
                    }


                    var ele = $(data.holderElement),
                            w = app.timeToPixel((helper._ENDTIME - helper._STARTTIME) * 1000),
                            startX = app.timeToPixel(helper._STARTTIME * 1000);
                    ele.width(w);
                    ele.css({ left: startX + 'px' });


                    return true;

                    //[ | ] 转场居中对齐
                    //支持重叠居中，调整 前一个event的duration ，后一个event的start
                    //若不可调整  继续看是否支持非重叠居中
                    //支持非重叠居中，无需调整对应trackEvent的位置 转场长度无需调整
                    //不支持 根据 距离判断放入前一个event 还是后一个event
                    //[ |
                    //放入前一个event
                    //| ]
                    //放入后一个event


                    //开始时间 大于 trackEvent开始时间 并且 开始时间位置没有转场类TrackEvent，可放置

                    return true;
                },
                dropped: function (droppedEvent, app, media, e) {
                    var dragData = droppedEvent.dragData,
                        type = droppedEvent.type,
                        track = droppedEvent.track,
                        data = droppedEvent.data,
                        left = droppedEvent.left,
                        dragData = droppedEvent.dragData,
                        popcornOptions = {};

                    if (dragData && dragData.helper) {
                        var trackEvent = null;
                        var helper = dragData.helper;
                        if (dragData.helper._ALIGN != 0) {
                            popcornOptions = this.getPopcornOptions(track, data);
                            if (!popcornOptions) {
                                return;
                            }

                            popcornOptions.start = helper._STARTTIME;
                            popcornOptions.end = helper._ENDTIME;
                            popcornOptions.duration = helper._DURATION;
                            popcornOptions.align = helper._ALIGN;
                            popcornOptions.leftOffset = helper._LEFTOFFSET;
                            popcornOptions.rightOffset = helper._RIGHTOFFSET;

                            trackEvent = new TrackEvent(app, {
                                type: this.popcornPlugin(),
                                clipdata: util.clone(data),
                                dropType: droppedEvent.dropType,
                                pluginType: type,
                                plugin: this,
                                popcornOptions: popcornOptions
                            });
                            track.addTrackEvent(trackEvent);

                            trackEvent.relativeTrackEvents = [];
                            for (var i = 0; i < helper._RELATIVETRACKEVENTS.length; i++) {
                                var t = helper._RELATIVETRACKEVENTS[i];
                                trackEvent.relativeTrackEvents.push(t.id);
                            }
                        }

                        trackEvent.attach = true;

                        return trackEvent;

                    }
                },
                startDrag: function (app, media, dragData, e) {
                    return false;
                },
                dragging: function (app, media, dragData, e) {

                    return false;
                },
                dragged: function (draggedEvent, app, media, e) {
                    return false;
                },
                resize: function (resizeEvent, app, media, trackEvent) {
                    var trackEventView = trackEvent.view,
                        direction = resizeEvent.direction,
                        min, max,
                        track = trackEvent.track,
                        trackEvents = trackEvent.track.trackEvents,
                        startTime = trackEvent.popcornOptions.start,
                        endTime = trackEvent.popcornOptions.end,
                        offsetTime = 0,
                        leftTrackEvent = trackEvent.relativeTrackEvents[0],
                        rightTrackEvent = trackEvent.relativeTrackEvents[1],
                        manifest = TimelinePlayer.manifest.transitionManifest,
                        plugin = TimelinePlayer.pluginList[this.popcornPlugin()],
                        curStartTime = startTime,
                        curEndTime = endTime;



                    function onTrackEventResizedLeft(trackEvent, x, w, resizeEvent) {
                        if (trackEvent.popcornOptions.align == manifest.ALIGN_RIGHT) {
                            resizeEvent.blockIteration(app.timeToPixel(startTime * 1000));
                        } else if (trackEvent.popcornOptions.align == manifest.ALIGN_OVERLAP) {
                        } else if (trackEvent.popcornOptions.align == manifest.ALIGN_CENTER) {
                            curStartTime = util.roundTime(app.pixelToTime(x) / 1000);
                            curEndTime = endTime + (startTime - curStartTime);
                            resizeEvent.setWidth(app.timeToPixel((startTime - curStartTime) * 1000));
                        } else {
                            curStartTime = util.roundTime(app.pixelToTime(x) / 1000);
                        }

                    }

                    function onTrackEventResizedRight(trackEvent, x, w, resizeEvent) {
                        if (trackEvent.popcornOptions.align == manifest.ALIGN_LEFT) {
                            resizeEvent.blockIteration(app.timeToPixel(endTime * 1000));
                        } else if (trackEvent.popcornOptions.align == manifest.ALIGN_OVERLAP) {
                        } else if (trackEvent.popcornOptions.align == manifest.ALIGN_CENTER) {
                            curEndTime = util.roundTime(app.pixelToTime(x+w) / 1000);
                            curStartTime = startTime + (endTime - curEndTime);
                            resizeEvent.setLeft(app.timeToPixel((curEndTime - endTime) * 1000));
                        } else {
                            curEndTime = util.roundTime(app.pixelToTime(x + w) / 1000);
                        }

                    }

                    if (direction === "left") {
                        trackEventView.setResizeHandler(onTrackEventResizedLeft);
                    }
                    else {
                        trackEventView.setResizeHandler(onTrackEventResizedRight);
                    }

                    function onTrackEventResizeStopped() {

                        if (curStartTime != startTime || curEndTime != endTime) {
                            var newPopcornOptions = {};
                            newPopcornOptions.start = curStartTime;
                            newPopcornOptions.end = curEndTime;
                            newPopcornOptions.duration = curEndTime - curStartTime;
                            trackEvent.update(newPopcornOptions);
                          //  media.updateDuration();


                        }
                        trackEventView.setResizeHandler(null);
                        trackEventView.removeEventListener("trackeventresizestopped", onTrackEventResizeStopped);

                    }

                    trackEventView.addEventListener("trackeventresizestopped", onTrackEventResizeStopped);
                },
                removeTrackEvent: function (trackEvent, ignoreUndo) {
                    trackEvent.track.removeTrackEvent(trackEvent, false, ignoreUndo);
                },
                canDrop: function (trackType) {
                    if (trackType === 'VA') {
                        return true;
                    }
                    return false;
                },
                updateAttach: function (app, trackEvent) {
                    var manifest = TimelinePlayer.manifest.transitionManifest,
                        plugin = TimelinePlayer.pluginList[this.popcornPlugin()],
                        track = trackEvent.track,
                        len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;

                    var rt = track.getTrackEventById(trackEvent.relativeTrackEvents[0]);

                    if (trackEvent.popcornOptions.align == manifest.ALIGN_LEFT ||
                        trackEvent.popcornOptions.align == manifest.ALIGN_RIGHT) {

                        if (rt) {
                            if (trackEvent.popcornOptions.align == manifest.ALIGN_LEFT) {
                                trackEvent.update({
                                    start: rt.popcornOptions.end - len,
                                    end: rt.popcornOptions.end
                                });
                            } else {
                                trackEvent.update({
                                    start: rt.popcornOptions.start,
                                    end: rt.popcornOptions.start + len
                                });
                            }
                        } else {
                            track.removeTrackEvent(trackEvent);
                        }
                    } else if (trackEvent.popcornOptions.align == manifest.ALIGN_CENTER) {
                        var s = rt.popcornOptions.end - len / 2;
                        var e = rt.popcornOptions.end + len / 2;
                        var re = track.getTrackEventById(trackEvent.relativeTrackEvents[1]);
                        if (re && (re.popcornOptions.start < e && re.popcornOptions.end > e)) {
                            trackEvent.update({
                                start: rt.popcornOptions.end - len / 2,
                                end: rt.popcornOptions.end + len / 2
                            });
                        } else {
                            track.removeTrackEvent(trackEvent);
                        }

                    } else {
                        //重叠

                    }


                },
                dragStyle: function () {
                    return {
                        width: 100,
                        height: 56
                    };
                },
                popcornPlugin: function () {
                    return "PopcornTransitionPlugin";
                },
                name: function () {
                    return "TransitionTrackEventPlugin";
                },
                parseData: function (element) {
                    var ele = $(element);
                    var data = {
                        data: {
                            title: ele.data("name"),
                            transition: ele.data("transition"),
                            clipid: ele.data("id"),
                            duration: +ele.data("duration") //结束位置
                        }
                    };

                    //var position = ele.data("position");
                    //if (position) {
                    //    data.data.position = position;
                    //}
                    //var fontColor = ele.data("fontcolor");
                    //if (fontColor) {
                    //    data.data.fontColor = fontColor;
                    //}
                    //var shadow = ele.data("shadow");
                    //if (shadow && shadow == true) {
                    //    data.data.shadow = true;
                    //}
                    //var shadowcolor = ele.data("shadowcolor");
                    //if (shadowcolor) {
                    //    data.data.shadowColor = shadowcolor;
                    //}


                    return data;
                },
                processElement: function (ele, trackEvent) {
                    ele.classList.add("transition");
                },
                loaded: function (app, trackEvent) {
                    trackEvent.attach = true;
                }
            });


            return TransitionTrackEventPlugin;
        });
/*
 * TrackEvent插件基类
 */
h5.define('core/TrackEventPluginManager',
        ["core/TrackEventPluginBase", "util/util",
        "core/VideoTrackEventPlugin",
        "core/TextTrackEventPlugin",
        "core/ImageTrackEventPlugin",
        "core/EffectTrackEventPlugin",
        "core/TransitionTrackEventPlugin"],
        function (TrackEventPluginBase, util,
            VideoTrackEvent,
            TextTrackEvent,
            ImageTrackEvent,
            EffectTrackEvent,
            TransitionTrackEventPlugin) {

            var TrackEventPluginManager = function () {
                var _pluginList = [
                    new VideoTrackEvent(),
                    new TextTrackEvent(),
                    new ImageTrackEvent(),
                    new EffectTrackEvent(),
                    new TransitionTrackEventPlugin()
                ];


                this.registerPlugin = function (plugin) {
                    if (plugin instanceof TrackEventPluginBase) {

                        var old = util.first(_pluginList, function (item, i) {
                            if (item.name() == plugin.name()) {
                                return true;
                            }
                        });

                        if (!old) {
                            _pluginList.push(old);
                        }
                    }
                }

                this.getPlugin = function (dropType, pluginType, data) {
                    var old = util.first(_pluginList, function (item, i) {
                        if ( item.canProcess(dropType,pluginType,data)){
                            return true;
                        }
                    });

                    return old;
                }

                this.getPluginByName = function (name) {
                    var old = util.first(_pluginList, function (item) {
                        if (item.name() == name) {
                            return true;
                        }
                        return false;
                    });

                    return old;
                }

                this.canDrop = function (type) {
                    var old = util.first(_pluginList, function (item, i) {
                        if (item.canDrop(type)) {
                            return true;
                        }
                    });

                    return old!= null;
                }

            };



            return new TrackEventPluginManager();
        });
/*
 * 轨
 */
h5.define('timeline/H5TrackView', ["jquery",
    "util/Object",
    "util/H5DragDrop",
    "util/util",
    "core/TrackEventPluginManager"],
  function ($, Obj, H5DragDrop, util, TrackEventPluginManager) {

      var TRACKEVENT_BORDER_OFFSET = 2;

      var H5TrackView = Obj.extend({
          init: function (app, id, track, trackType) {
              this._super();


              var _id = id,
              _track = track,
              _this = this,
              _trackEvents = [],
              _element = document.createElement("div"),
              _duration = 1,
              _parent,
              _droppable,
              _lastBeforeTrack,
              _oldStatus = [],
              _holderElement = null;



              _element.className = "track";
              _element.classList.add(trackType.toLowerCase());

              //放置项
              function setupDroppable() {
                  _droppable = H5DragDrop.droppable(_element, {
                      hoverClass: "draggable-hover",
                      data: _this,
                      candrop: function (e, mousePosition, helper) {
                          var left = mousePosition[0];
                          var trackRect = _track.view.element.getBoundingClientRect();

                          left = left - trackRect.left;
                         // left = left - _track.view.parent.offsetLeft + _track.view.parent.element.scrollLeft;


                          if (helper) {
                              var p = TrackEventPluginManager.getPlugin(helper.data.type, helper.data.plugin, helper.data);
                              if (p && p.canDrop(_track.trackType, helper)) {
                              } else {

                                  restoreOld();
                                  return false;
                              }



                              var start = left - helper.data.pos[0],
                                  end = start + helper.data.width,
                                  startTime = app.pixelToTime(start) / 1000,
                                  endTime = app.pixelToTime(end) / 1000,
                                  dragTime = util.roundTime(app.pixelToTime(left) / 1000),
                                  startTrackEvent = _track.findTrackEventByTime(startTime),
                                  endTrackEvent = _track.findTrackEventByTime(endTime);

                              var hoverTrackEvent = _track.findTrackEventByTime(dragTime);
                              var dragData = {
                                  start: start,
                                  end: end,
                                  startTime: startTime,
                                  endTime: endTime,
                                  dragTime: dragTime,
                                  startTrackEvent: startTrackEvent,
                                  endTrackEvent: endTrackEvent,
                                  holderElement: _holderElement,
                                  hoverTrackEvent: hoverTrackEvent,
                                  track: _track
                              };
                              var r = p.dragOver(app, helper, mousePosition, dragData, e);

                              if (typeof dragData.dropTime == 'number') {
                                  helper.data.dropTime = dragData.dropTime;
                                  helper.data.dropNextTrackEvent = dragData.dropNextTrackEvent;
                              } else {
                                  helper.data.dropTime = undefined;
                              }

                              if (!r) {
                                  restoreOld();
                                  return false;
                              }

                              return true;

                          }

                          return false;

                      },
                      out: function (helper, pos,e ) {
                          if (e.target !== _element  ) {

                              var wrapper = app.trackContainer.element,
                                  wrapperRect = wrapper.getBoundingClientRect(),
                                  rect = _element.getBoundingClientRect();
                              if (rect.right > wrapperRect.right) {
                                  rect.right = wrapper.right;
                              }
                              if (pos[0] >= rect.left && pos[0] < rect.right &&
                                  pos[1] >= rect.top && pos[1] < rect.bottom) {
                          //        console.log(rect);
                              } else {
                                  console.log("hidden");
                                  $(app.trackContainer.element).find("div.align-line").remove();

                                 // if (_holderElement) {
                                     // $(_holderElement).addClass("hidden");
                                      restoreOld();
                               //   }
                             }

                          }


                          if (_lastBeforeTrack) {
                              $(_lastBeforeTrack.element).removeClass('track-event-highlight');
                              delete _lastBeforeTrack;
                          }
                      },
                      over: function (helper, pos) {
                          if (helper) {
                              _oldStatus.length = 0;
                              util.forEach(_trackEvents, function (item) {
                                  var s = {
                                      left: item.element.offsetLeft,
                                      width: item.element.clientWidth
                                  };
                                  _oldStatus.push(s);
                              });

                              if (!_holderElement) {
                                  _holderElement = $("<div>").addClass("track-event track-event-shadow")[0];
                                  _holderElement.classList.add(track.trackType.toLowerCase());
                                  _element.appendChild(_holderElement);
                                  $(_holderElement).width(0);
                              } else {
                                  var pluginName = _track.name.toLowerCase();
                                  if(pluginName  == 'audio'){
                                      pluginName = 'video';
                                  }
                                  if (helper.data && helper.data.plugin == pluginName) {
                                      $(_holderElement).removeClass("hidden");

                                      for (var i = 0; i < app.media.tracks.length; i++) {
                                          var t = app.media.tracks[i];
                                          if (t == _track) {
                                              if ((helper.data.data.audio && t.name == "Video") || (!helper.data.data.audio && t.name == "Audio")) {
                                                  t.view.cancelDrag();
                                              }
                                          } else {
                                              t.view.cancelDrag();
                                          }

                                      }
                                  }
                              }
                          }

                      },
                      drop: function (dropped, mousePosition, popcornOptions, e) {
                          var draggableType = '',
                              pluginType = '',
                              helper =null,
                             duration, start, end, left, trackRect, trackEvent, trackEventView, trackEventRect;

                    //      if (_holderElement) {

                     //     }

                          if (dropped && dropped.type) {
                              draggableType = dropped.type;
                              pluginType = dropped.plugin;
                          } else {

                              if (dropped.data && dropped.data.element) {
                                  var droppedElement = dropped.data ? dropped.data.element : dropped;
                                  draggableType = droppedElement.getAttribute("data-draggable-type");
                                  if (draggableType === "plugin") {
                                      pluginType = droppedElement.getAttribute("data-popcorn-plugin-type");
                                  }
                              } else {

                                  draggableType = dropped.data.type;
                                  pluginType = dropped.data.plugin;
                                  helper = dropped;
                                  dropped = dropped.data;
                              }

                          }

                          var left = mousePosition[0];
                          left = left - _track.view.parent.offsetLeft + _track.view.parent.element.scrollLeft;

                          var dragData = {};
                          if (helper) {

                              dragData.start = left - helper.data.pos[0];
                              dragData.end = dragData.start + helper.data.width;
                              dragData.helper = helper;
                              dragData.dropTime = helper.data.dropTime;

                              dragData.startTime = util.roundTime(app.pixelToTime(dragData.start) / 1000);
                              dragData.endTime = util.roundTime(app.pixelToTime(dragData.end) / 1000);
                              dragData.dragTime = util.roundTime(app.pixelToTime(left) / 1000);
                              dragData.track = _track;
                              dragData.startTrackEvent = _track.findTrackEventByTime(dragData.startTime);
                              dragData.endTrackEvent = _track.findTrackEventByTime(dragData.endTime);
                              dragData.dropNextTrackEvent = helper.data.dropNextTrackEvent;
                          } else {

                          }

                          //插件 --素材  字幕  图片
                          if (draggableType === "plugin") {

                              restoreOld();

                              var p = TrackEventPluginManager.getPlugin(draggableType, pluginType, dropped.data);
                              if (!p) {
                                  return;
                              }
                              if (!p.canDrop(_track.trackType, dropped)) {
                                  return;
                              }

                              if (!TrackEventPluginManager.canDrop(_track.trackType)) {
                                  return;
                              }

                              //left = mousePosition[0] - trackRect.left;
                             // start = left / trackRect.width * _duration;
                              _this.dispatchEvent("plugindropped", {
                                  start: 0,
                                  plugin: p,
                                  oEvent: e,
                                  track: _track,
                                  dragData: dragData,
                                  left: left,
                                  dropType: draggableType,
                                  type: pluginType,
                                  data: dropped.data,
                                  width: dropped.width,
                                  height: dropped.height,
                                  pos: dropped.pos
                              });
                          }
                          else if (draggableType === "trackevent") {

                              if (_holderElement) {
                                  $(_holderElement).addClass("hidden");
                              }

                              //项之间拖动
                              trackEventRect = dropped.getLastRect();
                              trackEventView = dropped.data;
                              trackEvent = trackEventView.trackEvent;

                              var left = trackEventRect.left;
                              left = left - _track.view.parent.offsetLeft + _track.view.parent.element.scrollLeft;


                              // Avoid using width values to derive end value to circumvent padding/border issues.
                              //duration = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;
                              //if (trackEventView.ghost) {
                              //    left = trackEventView.ghost.element.getBoundingClientRect().left - trackRect.left;
                              //} else {
                              //    left = trackEventRect.left - trackRect.left;
                              //}
                              //start = left / trackRect.width * _duration;
                              //end = start + duration;

                              _this.dispatchEvent("trackeventdropped", {
                                  //start: start,
                                  //end: end,
                                  start: 0,
                                  oEvent: e,
                                  left: left,
                                  track: _track,
                                  data: trackEvent
                              });
                          }
                      }
                  });
              }


              function restoreOld() {
                  util.forEach(_track.trackEvents, function (item) {
                      item.view.update({
                          start: item.popcornOptions.start,
                          end: item.popcornOptions.end
                      });
                  });
                  if (_holderElement) {
                      $(_holderElement).addClass("hidden");
                  }
              }



              this.cancelDrag = restoreOld;

              this.hideTrackHolder = function () {
                  if (_holderElement) {
                      $(_holderElement).addClass("hidden");
                  }
              }

              this.getTrackEventShadow = function () {
                  if (!_holderElement) {
                      _holderElement = $("<div>").addClass("track-event  track-event-shadow")[0];
                      _holderElement.classList.add(track.trackType.toLowerCase());
                      _element.appendChild(_holderElement);
                      $(_holderElement).width(0);
                  }
                  return _holderElement;
              };

              _element.setAttribute("data-track-id", _id);

              Object.defineProperties(this, {
                  id: {
                      enumerable: true,
                      get: function () {
                          return _id;
                      }
                  },
                  element: {
                      enumerable: true,
                      configurable: false,
                      get: function () {
                          return _element;
                      }
                  },
                  duration: {
                      enumerable: true,
                      get: function () {
                          return _duration;
                      },
                      set: function (val) {
                          _duration = val;
                          for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                              _trackEvents[i].update();
                          } //for
                      }
                  },
                  parent: {
                      enumerable: true,
                      get: function () {
                          return _parent;
                      },
                      set: function (val) {
                          _parent = val;
                          if (_droppable) {
                              _droppable.destroy();
                              _droppable = null;
                          }
                          if (_parent) {
                              setupDroppable();
                          }
                          for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                              _trackEvents[i].parent = _this;
                          }
                      }
                  },
                  track: {
                      enumerable: true,
                      get: function () {
                          return _track;
                      }
                  }
              });

              function onTrackEventDragStopped(e) {
                 // _track.removeTrackEvent(e.target.trackEvent, true);
              }

              //this.createShadow = function () {
              //    _this.shadow = this.element.cloneNode(true);
              //    _this.element.parentNode.appendChild(_this.shadow);
              //}

              this.addTrackEvent = function (trackEvent) {
                  var trackEventElement = trackEvent.view.element;
                  trackEventElement.classList.add(trackEvent.track.trackType.toLowerCase());
                  if (trackEvent.plugin.processElement) {
                      trackEvent.plugin.processElement(trackEventElement, trackEvent);
                  }
                  _element.appendChild(trackEventElement);
                  _trackEvents.push(trackEvent.view);
                  trackEvent.view.parent = _this;
                  _this.chain(trackEvent, [
                    "trackeventmousedown",
                    "trackeventmouseover",
                    "trackeventmouseout",
                    "trackeventmoved"
                  ]);

                  trackEvent.view.addEventListener("trackeventdragstopped", onTrackEventDragStopped);
              };


              this.findTrackEvent = function (left) {
                  var trackEvent = util.first(_trackEvents, function (item) {
                      var ele = $(item.element);
                      var x = parseInt(ele.css("left"));
                      var w = ele.width();

                      if (left >= (x - 30) && left <= (x + 30)) {
                          return true;
                      }
                      return false;

                  });

                  return trackEvent;
              }


              // 是否处于忽略区间，如果放置在此区间，将不会插入事件
              this.isIgonreInsert = function (left) {
                  var trackEvent = util.first(_trackEvents, function (item) {
                      var ele = $(item.element);
                      var x = parseInt(ele.css("left"));
                      var w = ele.width();

                      if (left > (x + 30) && left<( x + w - 30) ) {
                          return true;
                      }
                      return false;

                  });

                  return trackEvent != null;
              }

              this.removeTrackEvent = function (trackEvent) {
                  var trackEventElement = trackEvent.view.element;
                  trackEventElement.classList.remove(trackEvent.track.trackType.toLowerCase());
                  // When `trackeventdragstarted` occurs, TrackEvents views are removed from their Track's view
                  // to avoid unnecessary collisions while dragging. So, it may be the case that the TrackEvent's view
                  // is no longer parented by this Track's view.
                  trackEventElement.parentNode.removeChild(trackEventElement);

                  _trackEvents.splice(_trackEvents.indexOf(trackEvent.view), 1);
                  trackEvent.view.parent = null;
                  _this.unchain(trackEvent, [
                    "trackeventmousedown",
                    "trackeventmouseover",
                    "trackeventmouseout",
                    "trackeventmoved"
                  ]);

                  trackEvent.view.removeEventListener("trackeventdragstopped", onTrackEventDragStopped);
              }

              this.updateTrackEvents = function () {
                  var trackEvents = _track.trackEvents;
                  for (var i = 0; i < _trackEvents.length; i++) {
                      if (_trackEvents[i].trackEvent.id != _track.trackEvents[i].id) {
                          this.removeTrackEvent(_trackEvents[i].trackEvent);
                          i--;
                      }
                  }
                  for (var i = 0, l = trackEvents.length; i < l; i++) {
                      trackEvents[i].view.update();
                  }
              };

              //// Creates a ghost trackEvent on this track. This means a cloned representation of a currently overlapping trackEvent
              //// is added to this track.
              //this.addTrackEventGhost = function (ghost) {
              //    ghost.track = _track;
              //    _element.appendChild(ghost.element);
              //};

              //// Removes a ghost trackEvent from this track
              //this.removeTrackEventGhost = function (ghost) {
              //    ghost.track = null;
              //    _element.removeChild(ghost.element);
              //};

              //this.findOverlappingDirection = function (draggingView, draggingOverView) {
              //    var draggingRect = draggingView.element.getBoundingClientRect(),
              //        draggingOverRect = draggingOverView.element.getBoundingClientRect(),
              //        leftDiff, rightDiff, topDiff, bottomDiff;

              //    rightDiff = draggingRect.right - draggingOverRect.left;
              //    leftDiff = draggingOverRect.right - draggingRect.left;
              //    bottomDiff = draggingRect.bottom - draggingOverRect.top;
              //    topDiff = draggingOverRect.bottom - draggingRect.top;

              //    if (rightDiff < leftDiff && rightDiff < topDiff && rightDiff < bottomDiff) {
              //        return "left";
              //    } else if (leftDiff < topDiff && leftDiff < bottomDiff) {
              //        return "right";
              //    } else if (topDiff < bottomDiff) {
              //        return "bottom";
              //    } else {
              //        return "top";
              //    }
              //};



              //this.findOverlappingTrackEvent = function (trackEventView, leftValue, widthValue) {
              //    var otherTrackEventView,
              //        rect1 = trackEventView.element.getBoundingClientRect(),
              //        rect2,
              //        left, right, width;

              //    left = leftValue || rect1.left;
              //    width = widthValue || rect1.width;
              //    right = left + width;

              //    // If the rect's width is 0 here, it's likely that we're not even attached to the DOM
              //    if (width === 0) {
              //        return null;
              //    }

              //    // loop over all the trackevents for this track and see if we overlap
              //    for (var i = 0, l = _trackEvents.length; i < l; i++) {
              //        otherTrackEventView = _trackEvents[i];
              //        // make sure that we don't check against the same trackEvent or other dragging trackEvents
              //        if (!otherTrackEventView.dragging && trackEventView !== otherTrackEventView) {
              //            rect2 = otherTrackEventView.element.getBoundingClientRect();
              //            // if a trackevent overlaps and it's not a ghost...
              //            if (!otherTrackEventView.isGhost &&
              //                 !(left >= (rect2.right - TRACKEVENT_BORDER_OFFSET) ||
              //                  (right <= rect2.left + TRACKEVENT_BORDER_OFFSET))) {
              //                return otherTrackEventView.trackEvent;
              //            }
              //        }
              //    }
              //    return null;
              //};
          }
      });

      return H5TrackView;
  });
/*
 * 清除HTML标记节点
 */
h5.define('util/Sanitizer', [], function () {

    // 创建一个离线文档，防止元素的自动更新
    var offscreenDocument = document.implementation.createHTMLDocument(""),
        unpackDiv = offscreenDocument.createElement("div");

    var Sanitizer = {
        clearHTML: function clearHTML(htmlString) {
            var cleaned = false;
            while (!cleaned) {
                cleaned = true;
                unpackDiv.innerHTML = htmlString;
                // 清除所有非文本的节点
                var children = unpackDiv.childNodes, i;
                for (i = children.length - 1; i >= 0; i--) {
                    if (children[i].nodeType !== 3) {
                        unpackDiv.removeChild(children[i]);
                        cleaned = false;
                    }
                }
                if (htmlString !== unpackDiv.textContent) {
                    htmlString = unpackDiv.textContent;
                    cleaned = false;
                }
            }
            return htmlString;
        }
    };

    return Sanitizer;

});

h5.define('core/Track', ["util/Object", "core/TrackEvent", "timeline/H5TrackView",
    "util/Sanitizer", "util/util", "core/TrackEventPluginManager", "util/Uri"],
        function (Obj, TrackEvent, H5TrackView, Sanitizer, util, TrackEventPluginManager, uri) {

            var __guid = 0,
                NAME_PREFIX = "Track" + " ",
                // Old layer names can be saved as Layer n before l10n existed,
                // these names are default names and should be translated.
                // If we are going to start using this,
                // we should check if it's the translated or english default, and update it.
                defaultNameRegexTranslated = new RegExp("^" + NAME_PREFIX + "(\\d)+$"),
                defaultNameRegex = new RegExp("^" + "Layer " + "(\\d)+$"),
                trackNames = {
                    "VA": lang[_curLang].video,
                    "A": lang[_curLang].audio,
                    "GC": lang[_curLang].subtitle,
                    "PIC": lang[_curLang].picture,
                    "ET": lang[_curLang].effect
                };



            var Track = Obj.extend({
                init: function(app, media, options, trackType){
                    this._super();

                    //轨道类型， VA 音视频  A 音频 GC 字幕 PIC 图片
                    var _trackType = trackType || 'VA';


                    options = options || {};

                    if ("id" in options) {
                        if (options.id === __guid) {
                            __guid++;
                        }
                        else if (options.id > __guid) {
                            __guid = options.id + 1;
                        }
                    } else {
                        options.id = __guid++;
                    }

                    var _trackEvents = [],
                        _target = options.target,
                        _id = "" + options.id,
                        _view = new H5TrackView(app, _id, this, _trackType),
                        _popcornWrapper = null,
                        _this = this,
                        _order = 0,
                        _isLock =false,
                        _name = trackNames[_trackType];

                    _this._selectedTrack = false;

                    _this._media = null;


                    _this.shadow = null;

                    this.setPopcornWrapper = function (newPopcornWrapper) {
                        _popcornWrapper = newPopcornWrapper;
                        for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                            _trackEvents[i].bind(_this, newPopcornWrapper);
                        }
                    };

                    this.updateTrackEvents = function () {
                        var trackEvents = _trackEvents.slice();
                        for (var i = 0, l = trackEvents.length; i < l; i++) {
                            trackEvents[i].update();
                        }
                    };

                    this.updateSelectedTrack = function (booleanSelected) {
                        var tracks = media.tracks;
                        for (var i = 0, l = tracks.length; i < l; ++i) {
                            if (tracks[i].trackType == _trackType) {
                                tracks[i]._selectedTrack = false;
                                $(tracks[i].view.element).removeClass("selected");
                            }

                        }
                        _this._selectedTrack = booleanSelected;
                        if (booleanSelected) {
                            $(_this.view.element).addClass("selected");
                        } else {
                            $(_this.view.element).removeClass("selected");
                        }

                    }

                    Object.defineProperties(this, {
                        view: {
                            enumerable: true,
                            configurable: false,
                            get: function () {
                                return _view;
                            }
                        },
                        target: {
                            enumerable: true,
                            get: function () {
                                return _target;
                            },
                            set: function (val) {
                                _target = val;
                                _this.dispatchEvent("tracktargetchanged", _this);
                                for (var i = 0, l = _trackEvents.length; i < l; i++) {
                                    _trackEvents[i].target = val;
                                    _trackEvents[i].update({ target: val });
                                }
                            }
                        },
                        trackType: {
                            enumerable: true,
                            get: function () {
                                return _trackType;
                            },
                            set: function (t) {
                                if (_trackType !== t) {
                                    _trackType = t;
                                    _this.dispatchEvent("tracktypechanged", _this);
                                }
                            }
                        },
                        selectedTrack: {
                            enumerable: true,
                            get: function () {
                                return _this._selectedTrack;
                            }
                        },
                        isLock: {
                            enumerable: true,
                            get: function () {
                                return _isLock;
                            },
                            set: function (val) {
                                if (_isLock != val) {
                                    _isLock = val;
                                    _this.dispatchEvent("lockchanged", _this);
                                }
                            }
                        },
                        name: {
                            enumerable: true,
                            get: function () {
                                return _name;
                            },
                            set: function (name) {
                                if (_name !== name) {
                                    _name = name;
                                    _this.dispatchEvent("tracknamechanged", _this);
                                }
                            }
                        },
                        id: {
                            enumerable: true,
                            get: function () {
                                return _id;
                            }
                        },
                        json: {
                            enumerable: true,
                            get: function () {
                                var exportJSONTrackEvents = [];
                                //add by zxl resove event  incorretorder
                                _trackEvents.sort(function (e1, e2) {
                                    return e1.popcornOptions.start - e2.popcornOptions.start;
                                })
                                for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                                    exportJSONTrackEvents.push(_trackEvents[i].json);
                                }
                                return {
                                    name: _name,
                                    trackType: _trackType,
                                    id: _id,
                                    order: _order,
                                    trackEvents: exportJSONTrackEvents
                                };
                            },
                            set: function (importData) {
                                var importName = importData.name;

                                _name = importName;
                                _id = importData.id;
                                _order = importData.order;
                                _trackType = importData.trackType;
                                _this.dispatchEvent("tracknamechanged", _this);

                                if (importData.trackEvents) {
                                    var importTrackEvents = importData.trackEvents;
                                    if (Array.isArray(importTrackEvents)) {
                                        for (var i = 0, l = importTrackEvents.length; i < l; ++i) {
                                            var t = importTrackEvents[i];
                                            var p = TrackEventPluginManager.getPluginByName(t.plugin);
                                            if (app.isChrome && _this.trackType == "VA") {
                                                if (t.popcornOptions.source) {
                                                    t.popcornOptions.source = uri.makeUnique(uri.stripUnique(t.popcornOptions.source)).toString();
                                                }
                                            }

                                            var trackEvent = new TrackEvent(app, {
                                                type: t.type,
                                                clipdata: t.clipdata,
                                                name: t.name,
                                                plugin: p,
                                                popcornOptions: t.popcornOptions
                                            });
                                            _this.addTrackEvent(trackEvent, true);

                                            if (app.isChrome && app.service && app.service.getsignurl && t.clipdata.sourceid) {
                                                trackEvent.updatesign();
                                            }

                                            trackEvent.json = t;

                                        }
                                    } else if (console) {
                                        console.warn("Ignored imported track event data. Must be in an Array.");
                                    }
                                }
                            }
                        },
                        trackEvents: {
                            enumerable: true,
                            configurable: false,
                            get: function () {
                                return _trackEvents;
                            }
                        },
                        order: {
                            enumerable: true,
                            get: function () {
                                return _order;
                            },
                            set: function (val) {
                                _order = val;
                            }
                        }
                    });

                    this.getTrackEventById = function (id) {
                        for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                            if (_trackEvents[i].id === id) {
                                return _trackEvents[i];
                            }
                        }
                    };

                    this.getNextTrackEventStart = function () {
                        var max = 0;
                        util.forEach(_trackEvents, function (item) {
                            max = Math.max(max, item.popcornOptions.end);
                        });
                        return max;
                    };
                    this.getLastTrackEvent = function () {
                        if (_trackEvents.length === 0)
                            return null;
                        return _trackEvents[_trackEvents.length - 1];
                    };


                    this.getTrackEventByName = function (name) {
                        for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                            if (_trackEvents[i].name === name) {
                                return _trackEvents[i];
                            }
                        }
                    };


                    //清除属性值中的HTML标签标记
                    this.sanitizeTrackEventData = function (trackEvent) {
                        var manifestOptions = trackEvent.manifest.options,
                            sanitizationList = [],
                            propertyName,
                            option;
                        for (propertyName in manifestOptions) {
                            if (manifestOptions.hasOwnProperty(propertyName)) {
                                option = manifestOptions[propertyName];
                                if (option.elem === "textarea" || option.elem === "input") {
                                    sanitizationList.push(propertyName);
                                }
                            }
                        }

                        sanitizationList.forEach(function (optionName) {
                            var content = trackEvent.popcornOptions[optionName];
                            if (typeof content !== "string") {
                                return;
                            }
                            trackEvent.popcornOptions[optionName] = Sanitizer.clearHTML(content);
                        });
                    },

                    this.addTrackEvent = function (trackEvent, flag) {
                        var oldSelected = false;

                        if (!(trackEvent instanceof TrackEvent)) {
                            trackEvent = new TrackEvent(trackEvent);
                        } else if (trackEvent.selected) {
                            oldSelected = true;
                            trackEvent.selected = false;
                        }


                        if (trackEvent.manifest.deprecated) {
                            return;
                        }

                        if (trackEvent.track) {
                            throw lang[_curLang].trackBelongOtherLayer;
                        }

                        this.sanitizeTrackEventData(trackEvent);

                        trackEvent.bind(_this, _popcornWrapper);

                        if (_target) {
                            trackEvent.target = _target;
                        }



                        _trackEvents.push(trackEvent);

                        _this.chain(trackEvent, [
                          "trackeventupdated",
                          "trackeventselected",
                          "trackeventdeselected"
                        ]);

                        _view.addTrackEvent(trackEvent);

                        trackEvent.selected = oldSelected;

                      //  trackEvent.subscribe("update", trackEventUpdateNotificationHandler);

                        _this.dispatchEvent("trackeventadded", trackEvent);

                        trackEvent.applyDefaults();

                        _this._media.updateDuration();
                        if (!flag) {
                            app.undo.push(lang[_curLang].addItemL + _name + lang[_curLang].addItemR);
                        }
                        return trackEvent;
                    };
                    //改变项大小后更新
                    this.resizeTrackEvent = function (trackEvent, newpopcornOptions) {

                        var _mediaEvents = [];
                        util.forEach(_trackEvents, function (item) {
                            if (!item.attach) {
                                _mediaEvents.push(item);
                            }
                        });

                  //      media.popcorn.suspend();
                        var idx = _mediaEvents.indexOf(trackEvent);

                        util.forEach(_mediaEvents, function (item) {
                            var curIndex = _mediaEvents.indexOf(item);
                            if (curIndex == idx) {
                                item.update({
                                    start: newpopcornOptions.start,
                                    end: newpopcornOptions.end,
                                    from: newpopcornOptions.from,
                                    duration: newpopcornOptions.duration
                                });
                            } else if (curIndex > idx) {
                                var itemPlayTime = item.popcornOptions.end - item.popcornOptions.start;
                                item.update({
                                    start: _trackEvents[curIndex - 1].popcornOptions.end,
                                    end: (_trackEvents[curIndex - 1].popcornOptions.end)+itemPlayTime
                                });
                            }

                        });
                 //       media.popcorn.resume();
                        //app.undo.push(lang[_curLang].adjustInOutPoint);
                    }

                    this.insertTrackEvent = function (trackEvent, beforeTrackEvent, update, flag) {
                        var oldSelected = false,
                            update = (typeof update === "undefined") ? true : update;



                        if (!(trackEvent instanceof TrackEvent)) {
                            trackEvent = new TrackEvent(trackEvent);
                        } else if (trackEvent.selected) {
                            oldSelected = true;
                            trackEvent.selected = false;
                        }


                        if (trackEvent.manifest.deprecated) {
                            return;
                        }

                        if (trackEvent.track) {
                            throw "The track item has already belonged to a layer, please remove the binding first.";
                        }

                 //       media.popcorn.suspend();
                        this.sanitizeTrackEventData(trackEvent);

                        trackEvent.bind(_this, _popcornWrapper);

                        if (_target) {
                            trackEvent.target = _target;
                        }

                        //插入
                        var idx = _trackEvents.indexOf(beforeTrackEvent);

                        //更新
                        if (update) {
                            var offset = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;
                            var beforeStart = beforeTrackEvent.popcornOptions.start;
                            util.forEach(_trackEvents, function (item) {
                                if (item !== trackEvent && item.popcornOptions.start >= beforeTrackEvent.popcornOptions.start) {

                                    item.update({
                                        start: item.popcornOptions.start + offset,
                                        end: item.popcornOptions.end + offset
                                    });


                                }

                            });
                        }
                 //       media.popcorn.resume();
                        _trackEvents.splice(idx, 0, trackEvent);



                       // _trackEvents.push(trackEvent);

                        _this.chain(trackEvent, [
                          "trackeventupdated",
                          "trackeventselected",
                          "trackeventdeselected"
                        ]);

                        _view.addTrackEvent(trackEvent);

                        trackEvent.selected = oldSelected;

                      //  trackEvent.subscribe("update", trackEventUpdateNotificationHandler);

                        _this.dispatchEvent("trackeventadded", trackEvent);

                        trackEvent.applyDefaults();
                        if (update) {
                            _this._media.updateDuration();
                        }
                        if (!flag) {
                            app.undo.push(lang[_curLang].insertItem);
                        }
                        return trackEvent;
                    };

                    // 将一个TrackEvent从当前位置移动到 另一个项之前
                    this.moveTrackEvent = function (oldTrackEvent, newAfterTrackEvent, ignoreUndo) {

                        var idx = _trackEvents.indexOf(oldTrackEvent);

                        if (idx < 0 )
                            return;


                        if (oldTrackEvent === newAfterTrackEvent) {
                            return;
                        }

                        _trackEvents.splice(idx, 1);
                        if (!newAfterTrackEvent) {
                            _trackEvents.push(oldTrackEvent);
                        } else {
                            var idx2 = _trackEvents.indexOf(newAfterTrackEvent);
                            _trackEvents.splice(idx2, 0, oldTrackEvent);
                        }



                        if (!ignoreUndo) {
                            app.undo.push(lang[_curLang].adjustItemLoc);
                        }

                    };

                    this.offsetTrackEvent = function (trackEvent, time, ignoreUndo) {
                        _trackEvents.sort(function (m, n) {
                            return m.popcornOptions.start - n.popcornOptions.start;
                        });
                        var idx = _trackEvents.indexOf(trackEvent);
                    //    media.popcorn.suspend();
                        for (var i = idx; i < _trackEvents.length; i++) {
                            var item = _trackEvents[i];
                            item.update({
                                start: item.popcornOptions.start + time,
                                end: item.popcornOptions.end + time
                            });

                        }
                        //      media.popcorn.resume();
                        if (!ignoreUndo) {
                            app.undo.push(lang[_curLang].moveItem);
                        }
                    };
                    this.removeTrackEventsByTime = function (start, end) {
                        var that = this;
                        var arr = [];
                        util.forEach(_trackEvents, function(item){
                            if (item.popcornOptions.start > start && item.popcornOptions.start < end) {
                                arr.push(item);
                            }
                        });
                        util.forEach(arr, function (item) {
                            that.removeTrackEvent(item, false, true);
                        });

                    }
                    this.splitTrackEventByTime = function (time) {
                        var trackEvent = this.findTrackEventByTime(time);
                        if (!trackEvent) {
                            return null;
                        }

                        var nextTrackEvent = this.findNextTrackEvent(trackEvent);
                        var ns = time,
                            ne = trackEvent.popcornOptions.end;
                        var newTrackEvent = trackEvent.clone();
                        newTrackEvent.popcornOptions.start = time;
                        newTrackEvent.popcornOptions.end = trackEvent.popcornOptions.end;
                        if (newTrackEvent.popcornOptions.duration) {
                            var from = newTrackEvent.popcornOptions.duration - trackEvent.popcornOptions.end + time;
                            newTrackEvent.popcornOptions.from = Math.max(from, 0);
                        }

                        trackEvent.update({
                            start: trackEvent.popcornOptions.start,
                            end: time
                        });

                        if (nextTrackEvent) {
                            this.insertTrackEvent(newTrackEvent, nextTrackEvent, false, true);
                        } else {
                            this.addTrackEvent(newTrackEvent, true);
                        }
                    }
                    this.deleteTrackEventsByTime = function (start, end) {
                        var that = this;
                        that.splitTrackEventByTime(start);
                        that.splitTrackEventByTime(end);
                        var arr = this.findRangeTrackEvent(start, end);
                        util.forEach(arr, function (item) {
                            that.removeTrackEvent(item, false, true);
                        });
                    }
                    this.findTrackEventByAttachEventId = function (id) {
                        var that = this;
                        var te = null;
                        util.forEach(_trackEvents, function (item) {
                            if (item.popcornOptions.attachEventId === id) {
                                te = item;
                            }
                        });
                        return te;
                    }
                    this.offsetTrackEventsByTime = function (start, end) {
                        _trackEvents.sort(function (m, n) {
                            return m.popcornOptions.start - n.popcornOptions.start;
                        });
                        var that = this;
                        util.forEach(_trackEvents, function (item) {
                            if (item.popcornOptions.start > start && item.popcornOptions.start < end) {
                                that.offsetTrackEvent(item, end - item.popcornOptions.start, true);
                                return;
                            }
                        });
                    }
                    this.findSpaceDuration = function (start, end, te) {
                        _trackEvents.sort(function (m, n) {
                            return m.popcornOptions.start - n.popcornOptions.start;
                        });
                        var that = this;
                        var d = { start: start, end: end };
                        var len = _trackEvents.length;
                        util.forEach(_trackEvents, function (item, index) {
                            if (item.popcornOptions.end > start && item.popcornOptions.end < end && item != te) {
                                d.start = item.popcornOptions.end;
                                var nextTe = _trackEvents[index + 1];
                                if (nextTe && nextTe!= te && nextTe.popcornOptions.start > start && nextTe.popcornOptions.start < end) {
                                    d.end = nextTe.popcornOptions.start;
                                }
                                return d;
                            }
                        });
                        util.forEach(_trackEvents, function (i, index) {
                            var item = _trackEvents[len - index - 1];
                            if (item.popcornOptions.start > start && item.popcornOptions.start < end && item != te) {
                                d.end = item.popcornOptions.start;
                                var nextTe = _trackEvents[len - index - 2];
                                if (nextTe && nextTe != te && nextTe.popcornOptions.end > start && nextTe.popcornOptions.end < end) {
                                    d.start = nextTe.popcornOptions.end;
                                }
                                return d;
                            }
                        });
                        return d;
                    }
                    this.removeTrackEvent = function (trackEvent, autoMove, ignoreUndo) {
                        var idx = _trackEvents.indexOf(trackEvent);

                        if (idx > -1) {


                        //    media.popcorn.suspend();
                            //自动调整后续项位置
                            if (autoMove) {
                                var len = trackEvent.popcornOptions.end - trackEvent.popcornOptions.start;
                                if (idx < _trackEvents.length) {
                                    for (var i = idx + 1; i < _trackEvents.length; i++) {
                                        var item = _trackEvents[i];
                                        item.update({
                                            start: item.popcornOptions.start - len,
                                            end: item.popcornOptions.end - len
                                        });
                                    }
                                }
                            }

                            _trackEvents.splice(idx, 1);
                            _this.unchain(trackEvent, [
                              "trackeventupdated",
                              "trackeventselected",
                              "trackeventdeselected"
                            ]);
                            //trackEvent.unsubscribe("update", trackEventUpdateNotificationHandler);
                            _view.removeTrackEvent(trackEvent);
                            trackEvent.unbind(false);

                     //       media.popcorn.resume();

                            //if (!preventRemove) {
                            //    _this.dispatchEvent("trackeventeditorclose", trackEvent);
                            //}

                            _this.dispatchEvent("trackeventremoved", trackEvent);

                            _this._media.updateDuration();

                            if (!ignoreUndo) {
                                app.undo.push(lang[_curLang].deleteItem);
                            }
                            if (app.media.SelectedTrackEvents.length > 0) {
                                app.editor.openTrackEventProperty(app.media.SelectedTrackEvents[0]);
                            }
                            else {
                                app.editor.openTrackEventProperty(app.media);
                            }
                            return trackEvent;
                        }
                    };


                    //查找包含该点的项列表
                    this.findTrackEventByTime = function (time, condition) {
                        var trackEvent = util.first(_trackEvents, function (item) {
                            var p = item.popcornOptions;

                            if (p.start <= time && p.end > time) {
                                if (condition) {
                                    if (condition(item)) {
                                        return true;
                                    }
                                } else if(!item.attach) {
                                    return true;
                                }
                            }
                            return false;
                        });

                        return trackEvent;


                    };

                    this.findNextTrackEvent = function (time, condition) {

                        if (typeof time === "number") {

                            var trackEvent = util.first(_trackEvents, function (item) {
                                var p = item.popcornOptions;
                                if (p.start >= time  ) {
                                    if (condition) {
                                        if (condition(item)) {
                                            return true;
                                        }
                                    } else if(!item.attach ){
                                        return true;
                                    }
                                }
                                return false;
                            });

                            return trackEvent;
                        } else if (time instanceof TrackEvent) {
                            var idx = _trackEvents.indexOf(time);
                            if (idx >= 0) {

                                if (condition) {
                                    for (var i = idx + 1; i < _trackEvents.length; i++) {
                                        var item = _trackEvents[i];
                                        if (condition(item)) {
                                            return item;
                                        }
                                    }
                                } else {
                                    for (var i = idx + 1; i < _trackEvents.length; i++) {
                                        var item = _trackEvents[i];
                                        if (!item.attach) {
                                            return item;
                                        }
                                    }

                                }
                            }

                            return null;
                        }
                        return null;
                    };

                    this.findNextTrackEvents = function (trackEvent, condition) {
                        var t = [];
                        var idx = _trackEvents.indexOf(trackEvent);

                        for (var i = idx; i < _trackEvents.length; i++) {

                            if (condition) {
                                if (condition(_trackEvents[i])) {
                                    t.push(_trackEvents[i]);
                                }

                            } else if (!_trackEvents[i].attach) {
                                t.push(_trackEvents[i]);
                            }
                        }

                        return t;
                    }

                    this.findPrevTrackEvent = function (time, condition) {
                        if (typeof time === "number") {
                            var trackEvent = null;
                            for (var i = _trackEvents.length - 1; i >= 0; i--) {
                                var item = _trackEvents[i];
                                if (item.popcornOptions.start < time) {
                                    if (condition) {
                                        if (condition(item)) {
                                            trackEvent = item;
                                            break;
                                        }
                                    } else if(!item.attach) {
                                        trackEvent = item;
                                        break;
                                    }
                                }
                            }
                            return trackEvent;
                        } else if (time instanceof TrackEvent) {
                            var idx = _trackEvents.indexOf(time);
                            if (condition) {
                                for (var i = idx - 1; i >= 0; i--) {
                                    var item = _trackEvents[i];
                                    if (condition(item)) {
                                        return item;
                                    }
                                }
                            } else {
                                for (var i = idx - 1; i >= 0; i--) {
                                    var item = _trackEvents[i];
                                    if (!item.attach) {
                                        return item;
                                    }
                                }
                            }
                            return null;
                        }
                        return null;
                    }

                    this.findRangeTrackEvent = function (start, end, condition) {
                        var t = [];

                        for (var i = 0; i < _trackEvents.length; i++) {
                            var item = _trackEvents[i];
                            if (item.popcornOptions.start < end &&
                                item.popcornOptions.end > start  ) {
                                if (condition) {
                                    if (condition(item)) {
                                        t.push(item);
                                    }
                                } else {
                                    if (!item.attach) {
                                        t.push(item);
                                    }
                                }
                            }
                        }
                        return t;

                    };


                    this.deselectEvents = function (except) {
                        var trackEvent;
                        for (var i = 0, l = _trackEvents.length; i < l; ++i) {
                            trackEvent = _trackEvents[i];
                            if (trackEvent !== except && trackEvent.selected) {
                                trackEvent.selected = false;
                            } //if
                        } //for
                    }; //deselectEvents
                }
            });


            Track.setGuid = function (val) {
                __guid = val;
            };

            return Track;

        });

/// <reference path="../../timelineplayer-wrapped.js" />
//淡入 淡出
h5.define('effect/transition/fadeinout', [], function () {

    var tp = TimelinePlayer.pluginList.PopcornTransitionPlugin;
    var m = TimelinePlayer.manifest.transitionManifest;

    tp._registerTransition("FADEINOUT", {
        manifest: {
            ALIGN: m.ALIGN_CENTER | m.ALIGN_OVERLAP | m.ALIGN_LEFT | m.ALIGN_RIGHT,
            DURATION: 4,
            displayName: lang[_curLang].fade
        },
        draw: function (context, time, video, trackGroup, trackEvent) {
            var duration = trackEvent.options.duration;
            var opacity = 0;
            var mid = duration / 2;
            if (time >= mid) {
                //淡入
                opacity = (time - mid) / mid;
            } else {
                //淡出
                opacity = 1 - (time /  mid);
            }
            context.save();
            context.globalAlpha = opacity;
            for (var i = 0; i < video.length; i++) {
                var v = video[i];
                context.drawImage(v.getImage(), 0, 0, context.canvas.width, context.canvas.height);
            }
            context.restore();
        }
    });

});
/// <reference path="../../timelineplayer-wrapped.js" />
//闪白
h5.define('effect/transition/flashlight', [], function () {

    var tp = TimelinePlayer.pluginList.PopcornTransitionPlugin;
    var m = TimelinePlayer.manifest.transitionManifest;

    tp._registerTransition("FLASHLIGHT", {
        manifest: {
            ALIGN: m.ALIGN_LEFT | m.ALIGN_RIGHT,
            DURATION: 2,
            displayName: lang[_curLang].flashWhite
        },
        draw: function (context, time, video, trackGroup, trackEvent) {
            var duration = trackEvent.options.duration;
            var curValue = (time / duration) * 255;
            if (curValue > 255) {
                curValue = 255;
            }
            for (var i = 0; i < video.length; i++) {
                var v = video[i];
                context.drawImage(v.getImage(), 0, 0, context.canvas.width, context.canvas.height);
            }

            var w = context.canvas.width;
            var h = context.canvas.height;
            var sdataId = context.getImageData(0, 0, w, h);
            var sdata = sdataId.data;
            var r,g,b;
            for (var i = 0; i < sdata.length; i += 4) {
                r = sdata[i] + curValue;
                g = sdata[i + 1] + curValue;
                b = sdata[i + 2] + curValue;
                if (r > 255) r = 255;
                if (g > 255) g = 255;
                if (b > 255) b = 255;
                sdata[i] = r;
                sdata[i + 1] = g;
                sdata[i + 2] = b;
            }
            context.putImageData(sdataId, 0, 0);

        }
    });

});
/// <reference path="../../timelineplayer-wrapped.js" />
//闪黑
h5.define('effect/transition/flashdark', [], function () {

    var tp = TimelinePlayer.pluginList.PopcornTransitionPlugin;
    var m = TimelinePlayer.manifest.transitionManifest;

    tp._registerTransition("FLASHDARK", {
        manifest: {
            ALIGN: m.ALIGN_LEFT | m.ALIGN_RIGHT,
            DURATION: 2,
            displayName: lang[_curLang].flashBlack
        },
        draw: function (context, time, video, trackGroup, trackEvent) {
            var duration = trackEvent.options.duration;
            var curValue = (time / duration) * 255;
            if (curValue > 255) {
                curValue = 255;
            }
            for (var i = 0; i < video.length; i++) {
                var v = video[i];
                context.drawImage(v.getImage(), 0, 0, context.canvas.width, context.canvas.height);
            }

            var w = context.canvas.width;
            var h = context.canvas.height;
            var sdataId = context.getImageData(0, 0, w, h);
            var sdata = sdataId.data;
            var r,g,b;
            for (var i = 0; i < sdata.length; i += 4) {
                r = sdata[i] - curValue;
                g = sdata[i + 1] - curValue;
                b = sdata[i + 2] - curValue;
                if (r < 0) r = 0;
                if (g < 0) g = 0;
                if (b < 0) b = 0;
                sdata[i] = r;
                sdata[i + 1] = g;
                sdata[i + 2] = b;
            }
            context.putImageData(sdataId, 0, 0);

        }
    });

});
/// <reference path="../timelineplayer-wrapped.js" />
/*
 * 播放器
 * 我们使用开源的Popcorn播放器<--换成自己的时间线播放器，支持虚拟素材
 */

h5.define('core/PlayerWrapper', ["util/Object", "util/Uri",
    "effect/transition/fadeinout",  //淡入淡出
    "effect/transition/flashlight", //闪白
    "effect/transition/flashdark" //闪黑
    ],
        function (Obj, Uri) {

            // 超时检查间隔
            var STATUS_INTERVAL = 100,
                // Media最长准备时间
                MEDIA_WAIT_DURATION = 10000;


            var PlayerWrapper = Obj.extend({
                init: function (app, mediaId, options) {

                    var _id = mediaId,
                        _app = app,
                        _popcornEvents = options.popcornEvents || {},
                        _onPrepare = options.prepare || function () { },
                        _onFail = options.fail || function () { },
                        _onTimeout = options.timeout || function () { },
                        _popcorn =  null,
                        _mediaReady = false,
                        _interruptLoad = false,
                        _this = this,
                        _isWaiting =false,
                        _videoLoading = null,

                        _makeVideoURLsUnique = options.makeVideoURLsUnique;

                    this._super();

                    /*
                     * 取消与 Popcorn 的绑定
                     */
                    this.unbind = function () {
                        _isWaiting = false;
                        if (_popcorn) {
                            try {
                                //_popcorn.destroy();
                                setPlayerError(null);
                                _popcorn.clear();
                                _popcorn = undefined;
                            }
                            catch (e) {
                            }
                        }
                    };

                    app.addEventListener("resize", function () {
                        if (_popcorn) {
                            _popcorn.resize();
                        }
                    });

                    /*
                     * 将popcorn的指定事件交由PlayerWrapper处理(由options传入)
                     */
                    function addPopcornHandlers() {
                        for (var eventName in _popcornEvents) {
                            if (_popcornEvents.hasOwnProperty(eventName)) {
                                _popcorn.addEventListener(eventName, _popcornEvents[eventName]);
                               // _popcorn.on(eventName, _popcornEvents[eventName]);
                            }
                        }
                        _popcorn.addEventListener("canplaythrough", playerCanplaythrough);
                        _popcorn.addEventListener("waiting", playerWaiting);
                        _popcorn.addEventListener("error", playerError);
                    }

                    var _waitingId = -1;
                    function playerWaiting() {
                        _isWaiting = true;

                        if (_waitingId >= 0) {
                            clearTimeout(_waitingId);
                        }
                        //延迟100毫秒，防止过短的等待，影响用户查看
                        _waitingId = setTimeout(function () {
                            if (_waitingId >= 0) {
                                _waitingId = -1;
                                _videoLoading.classList.remove("hidden");
                            }

                        }, 100);
                    }

                    function setPlayerError(error) {
                        var infoPanel = _videoLoading.querySelector(".info");
                        if (infoPanel) {
                            if (error == null) {
                                infoPanel.innerText = lang[_curLang].buffering;
                                infoPanel.classList.remove("error");
                            } else {
                                var msg = "";
                                if (error.code == 2) {
                                    msg = lang[_curLang].errorOfNetwork;
                                } else if (error.code == 3) {
                                    msg = lang[_curLang].errorOfMedia;
                                } else if (error.code == 4) {
                                    msg = lang[_curLang].errorOfResource;
                                    infoPanel.innerText = msg;
                                    infoPanel.classList.add("error");
                                }
                            }
                        }
                    }

                    function playerError() {
                        setPlayerError(_popcorn.error);
                    }

                    function playerCanplaythrough() {
                        _isWaiting = false;
                        if (_waitingId >= 0) {
                            clearTimeout(_waitingId);
                            _waitingId = -1;
                        }

                        setTimeout(function () {
                            console.log("playerCanplaythrough");
                            _videoLoading.classList.add("hidden");
                            setPlayerError(null);
                        }, 0);
                    }

                    // 取消media的载入
                    this.interruptLoad = function () {
                        _interruptLoad = true;
                    };

                    // 根据TrackEvent更新popcorn的trackEvent
                    this.synchronizeEvent = function (trackEvent, newOptions) {
                        var options = trackEvent.popcornOptions,
                            popcornId = trackEvent.id;
                        var pt = trackEvent.plugin.popcornPlugin();
                        if (_popcorn) {
                            if (_popcorn.getTrackEvent(pt, popcornId)) {
                                _popcorn.addTrackEvent(pt, popcornId, newOptions);
                            } else {
                                _popcorn.addTrackEvent(pt, popcornId, options);
                            }


                            var  popcornEvent = _popcorn.getTrackEvent(pt, popcornId);

                            trackEvent.popcornTrackEvent = popcornEvent;

                            trackEvent.popcornOptions.start = +popcornEvent.startTime;
                            trackEvent.popcornOptions.end = +popcornEvent.endTime;

                            if (trackEvent.view) {
                                trackEvent.view.update(trackEvent.popcornOptions);
                                if (trackEvent.popcornTrackEvent) {
                                    trackEvent.view.elementText = trackEvent.popcornTrackEvent.toString();
                                    trackEvent.dispatchEvent("trackeventupdated", trackEvent);
                                }
                            }
                        }

                    };

                    // 取消Popcorn 轨道事件
                    this.destroyEvent = function (trackEvent) {
                        var popcornId = trackEvent.id;

                        // ensure the trackevent actually exists before we remove it
                        if (_popcorn) {
                            if (popcornId) {
                                //_popcorn.removeTrackEvent(popcornId);
                                _popcorn.removeTrackEvent(trackEvent.plugin.popcornPlugin(), popcornId);
                            }

                        }
                    };

                    /*
                     * 预处理，生成popcorn对象并等待其就绪
                     */
                    this.prepare = function (duration, target, popcornOptions, callbacks, scripts) {
                        var urlsFromString;

                        _mediaReady = false;



                        // if there isn't a target, we can't really set anything up, so stop here
                        if (!target) {
                            return;
                        }

                        // 如果popcorn尚未创建
                        if (!_popcorn) {
                            _popcorn = new TimelinePlayer({
                                container: target,
                                logger: _app.logger,
                                useCanvas: _app.useCanvas,
                                useCros: _app.useCros
                            });
                            _videoLoading = target.querySelector(".loading");
                            addPopcornHandlers();

                            _popcorn.duration = duration;

                            setTimeout(function () {
                                _onPrepare();
                            }, 0);

                        }
                    };



                    this.play = function () {
                        _popcorn.play();
                        setPlayerError(null);

                    };

                    // Passthrough to the Popcorn instances pause method
                    this.pause = function () {
                        _popcorn.pause();
                        setPlayerError(null);
                        //if (_mediaReady && !_popcorn.paused()) {
                        //    _popcorn.pause();
                        //}
                    };

                    this.suspend = function () {
                        if (_popcorn) {
                            _popcorn.suspend();
                        }
                    }
                    this.resume = function () {
                        if (_popcorn) {
                            _popcorn.resume();
                        }
                    }

                    Object.defineProperties(this, {
                        volume: {
                            enumerable: true,
                            set: function (val) {
                                if (_popcorn) {
                                    _popcorn.volume = val;
                                } //if
                            },
                            get: function () {
                                if (_popcorn) {
                                    return _popcorn.volume;
                                }
                                return false;
                            }
                        },
                        muted: {
                            enumerable: true,
                            set: function (val) {
                                if (_popcorn) {
                                    _popcorn.muted = val;
                                } //if
                            },
                            get: function () {
                                if (_popcorn) {
                                    return _popcorn.muted;
                                }
                                return false;
                            }
                        },
                        currentTime: {
                            enumerable: true,
                            set: function (val) {
                                if (_popcorn) {
                                    // if (_popcorn.currentTime != val) {
                                    setPlayerError(null);
                                    _popcorn.pause();
                                    _popcorn.currentTime = val;

                                  //  }
                                }
                            },
                            get: function () {
                                if (_popcorn) {
                                    return _popcorn.currentTime
                                }
                                return 0;
                            }
                        },
                        duration: {
                            enumerable: true,
                            get: function () {
                                if (_popcorn) {
                                    return _popcorn.duration;
                                } //if
                                return 0;
                            },
                            set: function (val) {
                                if (_popcorn) {
                                    _popcorn.duration = val;
                                }
                            }
                        },
                        popcorn: {
                            enumerable: true,
                            get: function () {
                                return _popcorn;
                            }
                        },
                        paused: {
                            enumerable: true,
                            get: function () {
                                if (_popcorn) {
                                    return _popcorn.paused;
                                } //if
                                return true;
                            },
                            set: function (val) {
                                if (_popcorn && !_isWaiting) {
                                    if (val) {
                                        _this.pause();
                                    }
                                    else {
                                        _this.play();
                                    } //if
                                } //if
                            }
                        } //paused
                    });

                }
            });


            return PlayerWrapper;
        });
/*
 * 项目信息
 */
h5.define("core/ProjectInfo", [], function () {
    var _manifest = {
        displayName: lang[_curLang].projectInfo,
        options: {
            name: {
                elem: "input",
                type: "text",
                label: lang[_curLang].name,
                readonly: true,
                "default": lang[_curLang].unnamed
            },
            framerate: {
                hidden: !lang[_curLang].isShowVideoStandard,
                elem: "select",
                options: ['23.9', '25', '29.97'],
                values: [23.9, 25, 29.97],
                label: lang[_curLang].frameRate,
                "default": 25
            },
            sizes: {
                hidden: !lang[_curLang].isShowSizes,
                elem: "select",
                options: ["16:9", "4:3"],
                values: ["16:9", "4:3"],
                label: lang[_curLang].breadth,
                "default": '16:9'
            },
            id: {
                hidden: true,
                "default": 0
            }
        }
    };  //项目属性窗口元数据

    var ProjectInfo = function (options) {
        var _this = this;
        options = options || {};
        for (var key in _manifest.options) {
            if (_manifest.options.hasOwnProperty(key)) {
                if (options[key]) {
                    _this[key] = options[key];
                } else {
                    _this[key] = _manifest.options[key]["default"];
                }
            }
        }

        _this.update = function (options) {
            for (var key in _this) {
                if (_this.hasOwnProperty(key)) {
                    if (options[key]) {
                        _this[key] = options[key];
                    }
                }
            }
        };
    };

    ProjectInfo.manifest = _manifest;

    return ProjectInfo;
});
/*
 * H5编辑器的逻辑管理
 */
h5.define('core/Media', [
            "util/Object",
            "core/Track",
            "core/PlayerWrapper",
            "util/Uri",
            "core/ProjectInfo",
            "util/util"
            ],
          function (Obj, Track, PlayerWrapper, URI,ProjectInfo, util ) {

              var __guid = 0;

              var Media = Obj.extend({
                  init: function (app, mediaOptions) {
                      mediaOptions = mediaOptions || {};
                      this._super();

                      var _tracks = [], //轨道
                      _orderedTracks = [], //已排序的轨道
                      _id = "Media" + __guid++,
                      _name = mediaOptions.name || _id,
                      _url = mediaOptions.url,
                      _ready = false,
                      _target = mediaOptions.target,
                      _registry,
                      _saved =false,
                      _currentTime = 0,
                      _duration = mediaOptions.duration || -1,
                      _popcornOptions = new ProjectInfo(),
                      _mediaUpdateInterval,
                      _clipData = {},
                      _this = this,
                      _selectedTrackEvents = [],
                      _popcornWrapper,
                      _type = "ProjectInfo";

                      _popcornOptions.id = _id;



                      function mediaReady() {
                          //_this.duration = _popcornWrapper.duration;
                          _ready = true;
                          for (var i = 0, l = _tracks.length; i < l; i++) {
                              _tracks[i].updateTrackEvents();
                          }

                          // 如果元素存在 data-media-controls属性则显示播放器控制条
                          var targetElement = document.getElementById(_target);
                          if (targetElement &&
                               targetElement.getAttribute("data-media-controls")) {
                              //_popcornWrapper.popcorn.controls(true);
                              if (_popcornWrapper.popcorn && _popcornWrapper.popcorn.controls) {
                                  _popcornWrapper.popcorn.controls(true);
                              }
                          }

                          _this.dispatchEvent("mediaready");
                      }

                      //创建一个播放器代理
                      _popcornWrapper = new PlayerWrapper(app, _id, {
                          popcornEvents: {
                              muted: function () {
                                  //静音
                                  _this.dispatchEvent("mediamuted", _this);
                              },
                              unmuted: function () {
                                  //取消静音
                                  _this.dispatchEvent("mediaunmuted", _this);
                              },
                              volumechange: function () {
                                  //声音大小改变
                                  _this.dispatchEvent("mediavolumechange", _popcornWrapper.volume);
                              },
                              timeupdate: function () {
                                  //当前时间
                                  _currentTime = _popcornWrapper.currentTime;
                                  _this.dispatchEvent("mediatimeupdate", _this);
                              },
                              pause: function () {
                                  //暂停
                                  clearInterval(_mediaUpdateInterval);
                                  _this.dispatchEvent("mediapause");
                              },
                              play: function () {
                                  //播放
                                  //_mediaUpdateInterval = setInterval(function () {
                                  //    _currentTime = _popcornWrapper.currentTime;
                                  //}, 10);
                                  _this.dispatchEvent("mediaplay");
                              },
                              waiting: function () {
                                  _this.dispatchEvent("mediawaiting");
                              },
                              canplaythrough: function () {
                                  _this.dispatchEvent("mediacanplaythrough");
                              },
                              ended: function () {
                                  //结束
                                  _this.pause();
                                  _this.dispatchEvent("mediaended");
                              },
                              seeked: function () {
                                  //跳转
                                  _this.dispatchEvent("mediaseeked");
                              }
                          },
                          prepare: mediaReady,
                          timeout: function () {
                              _this.dispatchEvent("mediatimeout");
                          },
                          fail: function () {
                              _this.dispatchEvent("mediafailed", "error");
                          },
                          setup: {
                              target: _target,
                              url: _url
                          },
                          makeVideoURLsUnique: mediaOptions.makeVideoURLsUnique
                      });

                      this.popcornCallbacks = null;
                      this.popcornScripts = null;
                      this.maxPluginZIndex = 110;


                      //清除所有轨
                      this.clear = function () {
                          for (var i = _tracks.length - 1; i >= 0; i--) {
                              _this.removeTrack(_tracks[i]);
                          }
                      };


                      function ensureNewTrackIsTrack(track, trackType) {
                          if (!(track instanceof Track)) {
                              track = new Track(app,_this,  track, trackType);
                          }
                          return track;
                      }

                      // 将Track的事件冒泡到Media
                      function setupNewTrack(track) {
                          track._media = _this;
                          _tracks.push(track);
                          _this.chain(track, [
                            "tracktargetchanged",
                            "tracknamechanged",
                            "trackeventadded",
                            "trackeventeditorclose",
                            "trackeventremoved",
                            "trackeventupdated",
                            "trackeventselected",
                            "trackeventdeselected"
                          ]);
                          track.setPopcornWrapper(_popcornWrapper);
                      }

                      //触发新轨中每一个项的已添加事件
                      function addNewTrackTrackEvents(track) {
                          var trackEvents = track.trackEvents;
                          if (trackEvents.length > 0) {
                              for (var i = 0, l = trackEvents.length; i < l; ++i) {
                                  track.dispatchEvent("trackeventadded", trackEvents[i]);
                              }
                          }
                      }

                      //添加轨
                      this.addTrack = function (track, forceFirst, trackType) {

                          if (forceFirst && _orderedTracks[0]) {
                              return _this.insertTrackBefore(_orderedTracks[0], trackType);
                          }

                          track = ensureNewTrackIsTrack(track, trackType);

                          if (track._media) {
                              throw "轨已属于其他媒体，请先移除";
                          }

                          track.order = _tracks.length;
                          //绑定事件
                          setupNewTrack(track);

                          _orderedTracks.push(track);

                          _this.dispatchEvent("trackadded", track);
                          _this.dispatchEvent("trackorderchanged", _orderedTracks);

                          //track.addEventListener("click", _this.test);
                          $(track).click(_this.test);

                          addNewTrackTrackEvents(track);
                          return track;
                      };

                      //this.test = function () {
                      //    alert("aaa");
                      //}

                      this.insertTrackBefore = function (otherTrack, newTrack, trackType) {
                          newTrack = ensureNewTrackIsTrack(newTrack, trackType);

                          if (newTrack._media) {
                              throw lang[_curLang].trackBelongOthers;
                          }

                          var idx = _orderedTracks.indexOf(otherTrack);

                          if (idx > -1) {
                              // Give new track last order since it's newest
                              newTrack.order = idx;

                              // Insert new track
                              _orderedTracks.splice(idx, 0, newTrack);

                              setupNewTrack(newTrack);

                              _this.dispatchEvent("trackadded", newTrack);

                              // 排序
                              _this.sortTracks(idx + 1);

                              addNewTrackTrackEvents(newTrack);

                              return newTrack;
                          }
                          else {
                              throw lang[_curLang].trackNotExist;
                          }
                      };


                      this.getTrackById = function (id) {
                          for (var i = 0, l = _tracks.length; i < l; ++i) {
                              if (_tracks[i].id === id) {
                                  return _tracks[i];
                              }
                          }
                      };

                      this.getTrackByOrder = function (order) {
                          for (var i = 0; i < _orderedTracks.length; i++) {
                              if (order === _orderedTracks[i].order) {
                                  return _orderedTracks[i];
                              }
                          }
                      };

                      this.clearAllTrackEvents = function () {
                          _popcornWrapper.popcorn.suspend();
                          for (var i = _tracks.length - 1; i >= 0; i--) {
                              _this.clearTrack(_tracks[i]);
                          }
                          _duration = 0;

                          _popcornWrapper.popcorn.resume();
                          _this.currentTime  = 0;
                          app.undo.push(lang[_curLang].empty);
                      };

                      this.clearTrack = function (track) {
                          var idx = _tracks.indexOf(track),
                              trackEvent,
                              orderedIndex;
                          if (idx > -1) {
                              var events = util.cloneArray(track.trackEvents);


                              //移除Track中的每一项
                              for (var i = 0, l = events.length; i < l; ++i) {
                                  trackEvent = events[i];
                                  trackEvent.selected = false;
                                  track.removeTrackEvent(trackEvent, false, true);
                                  track.dispatchEvent("trackeventremoved", trackEvent);
                              }

                          }
                      };

                      this.removeTrack = function (track) {
                          var idx = _tracks.indexOf(track),
                              trackEvent,
                              orderedIndex;
                          if (idx > -1) {
                              _tracks.splice(idx, 1);
                              orderedIndex = _orderedTracks.indexOf(track);
                              var events = track.trackEvents;
                              //移除Track中的每一项
                              for (var i = 0, l = events.length; i < l; ++i) {
                                  trackEvent = events[i];
                                  trackEvent.selected = false;
                                  trackEvent.unbind();
                                  track.dispatchEvent("trackeventremoved", trackEvent);
                              }
                              //取消事件绑定
                              _this.unchain(track, [
                                "tracktargetchanged",
                                "tracknamechanged",
                                "trackeventadded",
                                "trackeventeditorclose",
                                "trackeventremoved",
                                "trackeventupdated",
                                "trackeventselected",
                                "trackeventdeselected"
                              ]);
                              track.setPopcornWrapper(null);
                              track._media = null;
                              _orderedTracks.splice(orderedIndex, 1);
                              _this.dispatchEvent("trackremoved", track);
                              _this.sortTracks(orderedIndex);
                              return track;
                          }
                      };

                      this.isEmpty = function () {
                          for (var i = 0; i < _tracks.length; i++) {
                              var track = _tracks[i];
                              if (track.trackEvents && track.trackEvents.length > 0) {
                                  return false;
                              }
                          }

                          return true;
                      };

                      this.updateDuration = function (val) {
                          //
                          var max = val || 0;
                          util.forEach(_tracks, function (item) {
                              max = Math.max(max, item.getNextTrackEventStart());
                          });

                          _this.duration = max;

                          var curTime = _this.currentTime;
                          _this.url = "#t=," + max;
                          if (curTime <= max) {
                              _this.currentTime = curTime;
                          } else {
                              _this.currentTime = max;
                          }
                      };

                      //根据轨道项ID查找所属轨道
                      this.findTrackWithTrackEventId = function (id) {
                          for (var i = 0, l = _tracks.length; i < l; ++i) {
                              var te = _tracks[i].getTrackEventById(id);
                              if (te) {
                                  return {
                                      track: _tracks[i],
                                      trackEvent: te
                                  };
                              }
                          }
                      };


                      //元素据清单
                      this.getManifest = function (name) {
                          return _registry[name];
                      };



                      function setupContent() {
                          if (_url && _url.indexOf("#t") == 0 && _url.indexOf(",") > -1) {
                              _url = _url.split(",");
                          }
                          if (_url && _target) {
                              //初始化popcorn
                              if (!_popcornWrapper.popcorn) {
                                  _popcornWrapper.prepare(+_url[1], _target, _popcornOptions, _this.popcornCallbacks, _this.popcornScripts);
                              } else {
                                  _this.duration = +_url[1];
                                  //var curTime = _popcornWrapper.popcorn.media.currentTime;
                                  //_popcornWrapper.popcorn.media.src = _url;

                                  //curTime = Math.min(curTime, _popcornWrapper.popcorn.media.duration);
                                  //if (curTime > 0) {
                                  //    _popcornWrapper.popcorn.media.currentTime = curTime;
                                  //}

                                 // mediaReady();
                              }
                          }
                      }

                      this.setupContent = setupContent;

                      //监听ready事件
                      this.onReady = function (callback) {
                          function onReady(e) {
                              callback(e);
                              _this.removeEventListener("mediaready", onReady);
                          }
                          if (_ready) {
                              callback();
                          } else {
                              _this.addEventListener("mediaready", onReady);
                          }
                      };

                      this.pause = function () {
                          _popcornWrapper.paused = true;
                          if (_popcornWrapper.paused) {
                              $(document.querySelector("#play")).addClass('glyphicon-play');
                              $(document.querySelector("#play")).removeClass('glyphicon-pause');
                          }
                      };

                      this.play = function () {
                          _popcornWrapper.paused = false;
                          if (!_popcornWrapper.paused) {
                              $(document.querySelector("#play")).addClass('glyphicon-pause');
                              $(document.querySelector("#play")).removeClass('glyphicon-play');
                          }
                      };



                      //this.generatePopcornString = function (callbacks, scripts) {
                      //    var popcornOptions = _popcornOptions || {};
                      //    popcornOptions.frameRate = util.frameRate;

                      //    callbacks = callbacks || _this.popcornCallbacks;
                      //    scripts = scripts || _this.popcornScripts;

                      //    var collectedEvents = [];
                      //    for (var i = 0, l = _tracks.length; i < l; ++i) {
                      //        collectedEvents = collectedEvents.concat(_tracks[i].trackEvents);
                      //    }

                      //    return _popcornWrapper.generatePopcornString(popcornOptions, _url, _target, null, callbacks, scripts, collectedEvents);
                      //};

                      function compareTrackOrder(a, b) {
                          return a.order - b.order;
                      }

                      this.sortTracks = function (startIndex, endIndex) {
                          var i = startIndex || 0,
                              l = endIndex || _orderedTracks.length;

                          for (; i <= l; ++i) {
                              if (_orderedTracks[i]) {
                                  _orderedTracks[i].order = i;
                                  _orderedTracks[i].updateTrackEvents();
                              }
                          }

                          _orderedTracks.sort(compareTrackOrder);
                          _this.dispatchEvent("trackorderchanged", _orderedTracks);
                      };

                      this.getNextTrack = function (currentTrack) {
                          var trackIndex = _orderedTracks.indexOf(currentTrack);
                          if (trackIndex > -1 && trackIndex < _orderedTracks.length - 1) {
                              return _orderedTracks[trackIndex + 1];
                          }
                          return null;
                      };

                      this.getPreviousTrack = function (currentTrack) {
                          var trackIndex = _orderedTracks.indexOf(currentTrack);
                          if (trackIndex > -1 && trackIndex <= _orderedTracks.length - 1) {
                              return _orderedTracks[trackIndex - 1];
                          }
                          return null;
                      };

                      this.getLastTrack = function (currentTrack) {
                          var trackIndex = _orderedTracks.indexOf(currentTrack);
                          if (trackIndex > 0) {
                              return _orderedTracks[trackIndex - 1];
                          }
                          return null;
                      };

                      this.findNextAvailableTrackFromTimes = function (start, end) {
                          for (var i = 0, l = _orderedTracks.length; i < l; ++i) {
                              if (!_orderedTracks[i].findOverlappingTrackEvent(start, end)) {
                                  return _orderedTracks[i];
                              }
                          }
                          return null;
                      };


                      this.forceEmptyTrackSpaceAtTime = function (track, start, end, ignoreTrackEvent) {
                          var nextTrack;

                          if (track.findOverlappingTrackEvent(start, end, ignoreTrackEvent)) {
                              nextTrack = _this.getNextTrack(track);
                              if (nextTrack) {
                                  if (nextTrack.findOverlappingTrackEvent(start, end, ignoreTrackEvent)) {
                                      return _this.insertTrackBefore(nextTrack);
                                  }
                                  else {
                                      return nextTrack;
                                  }
                              }
                              else {
                                  return this.addTrack();
                              }
                          }

                          return track;
                      };


                      this.fixTrackEventBounds = function () {
                          var i, j,
                              tracks, tracksLength,
                              trackEvents, trackEventsLength,
                              trackEvent, trackEventOptions,
                              start, end;

                          tracks = _orderedTracks.slice();

                          // loop through all tracks
                          for (i = 0, tracksLength = tracks.length; i < tracksLength; i++) {
                              trackEvents = tracks[i].trackEvents.slice();

                              // loop through all track events
                              for (j = 0, trackEventsLength = trackEvents.length; j < trackEventsLength; j++) {
                                  trackEvent = trackEvents[j];
                                  trackEventOptions = trackEvent.popcornOptions;
                                  start = trackEventOptions.start;
                                  end = trackEventOptions.end;

                                  // check if track event is out of bounds
                                  if (end > _duration) {
                                      if (start > _duration) {
                                          // remove offending track event
                                          trackEvent.track.removeTrackEvent(trackEvent);
                                      } else {
                                          trackEvent.update({
                                              end: _duration
                                          });
                                      }
                                  }
                              }
                          }
                      };

                      this.hasTrackEvents = function () {
                          for (var i = 0, l = _tracks.length; i < l; ++i) {
                              if (_tracks[i].trackEvents.length) {
                                  return true;
                              }
                          }
                      };

                      function sanitizeUrl() {
                          var sanitized;

                          function sanitize(url) {
                              return URI.stripUnique(url).toString();
                          }

                          if (Array.isArray(_url)) {
                              sanitized = [];
                              _url.forEach(function (url) {
                                  sanitized.push(sanitize(url));
                              });
                              return sanitized;
                          }
                          else {
                              return sanitize(_url);
                          }
                      }

                      this.selectTrackEvent = function (trackEvent) {
                          var old = util.first(_selectedTrackEvents, function (item) {
                              if (item === trackEvent) {
                                  return true;
                              }
                              return false;
                          });
                          if (!old) {
                              _selectedTrackEvents.push(trackEvent);

                              this.dispatchEvent("trackeventselectchanged", _selectedTrackEvents);
                          }
                      };

                      this.deselectTrackEvent = function (trackEvent) {
                          var idx = _selectedTrackEvents.indexOf(trackEvent);
                          if (idx >= 0) {
                              _selectedTrackEvents.splice(idx, 1);
                              this.dispatchEvent("trackeventselectchanged", _selectedTrackEvents);
                          }
                          app.editor.openTrackEventProperty(app.media);
                      };

                      this.deselectAllTrackEvents = function () {
                          util.forEach( util.cloneArray(_selectedTrackEvents) , function (item) {
                              item.selected = false;
                          });
                          this.dispatchEvent("trackeventselectchanged", _selectedTrackEvents);
                          app.editor.openTrackEventProperty(app.media);
                      };

                      this.nextFrame = function () {
                          if (_this.paused) {
                              var f = util.secondsToFrame(_this.currentTime);
                              f++;
                              var time = f / util.frameRate;
                              _this.currentTime = time;
                          }
                      };

                      this.prevFrame = function () {
                          if (_this.paused) {
                              var f = util.secondsToFrame(_this.currentTime);
                              f--;
                              var time = f / util.frameRate;
                              _this.currentTime = time;
                          }
                      };

                      this.startFrame = function () {
                          _this.pause();
                          _this.currentTime = 0;
                      };

                      this.endFrame = function () {
                          _this.pause();
                          _this.currentTime = _duration - 0.04;
                      };

                      this.findTrack = function (trackType) {
                          var track;
                          track = util.first(_tracks, function (track) {
                              if (track.trackType == trackType && track.selectedTrack) {
                                return true;
                              }
                          });
                          if (track) {
                              return track;
                          }
                          return util.first(_tracks, function (track) {
                              if (track.trackType == trackType) {
                                return true;
                              }
                              return false;
                           });
                      };
                      //剪开
                      this.splitTrackEvent = function (time) {

                          time = util.roundTime(time);
                          var trackEvents = [];
                          var nTrackEvents = [];
                          util.forEach(_tracks, function (track) {
                              if (track.isLock) {
                                  //不操作锁定轨
                              } else {
                                  var trackEvent = track.findTrackEventByTime(time);
                                  if (trackEvent && trackEvent.selected) {
                                      trackEvents.push(trackEvent);
                                  }
                                  else if(trackEvent){
                                     nTrackEvents.push(trackEvent);
                                  }
                              }
                          });
                          if (trackEvents && trackEvents.length > 0) {
                              util.forEach(trackEvents, function (item) {
                                  if (item.plugin) {
                                      item.plugin.splitTrackEvent(app, item, time);
                                  }
                              });
                          }
                          else{
                              util.forEach(nTrackEvents, function (item) {
                                  if (item.plugin) {
                                      item.plugin.splitTrackEvent(app, item, time);
                                  }
                              });
                          }
                      };

                      //删除指定区域
                      this.deleteRange = function (start, end) {
                          start = util.roundTime(start);
                          end = util.roundTime(end);

                          util.forEach(_tracks, function (track) {

                              if (track.isLock) {
                              } else {

                                  var ts = track.findRangeTrackEvent(start, end);

                                  if (ts && ts.length) {
                                      var offset = 0;
                                      var lastTrackEvent = null;
                                      util.forEach(ts, function (item) {
                                          var len = 0;
                                          if (start <= item.popcornOptions.start) {
                                              if (end >= item.popcornOptions.end) {
                                                  len = item.popcornOptions.end - item.popcornOptions.start;
                                                  track.removeTrackEvent(item,undefined, true);
                                              } else {
                                                  //小于
                                                  lastTrackEvent = item;
                                                  len = end - item.popcornOptions.start;
                                                  item.plugin.adjustTrackEvent(app, item, end, item.popcornOptions.end);
                                              }
                                          } else {
                                              if (end >= item.popcornOptions.end) {
                                                  len = item.popcornOptions.end - start;
                                                  item.plugin.adjustTrackEvent(app, item, item.popcornOptions.start, start);
                                              } else {
                                                  len = end - start;
                                                  //需要拆分
                                                  lastTrackEvent = item.plugin.deleteRange(app, item, start, end);
                                              }
                                          }
                                          offset += len;

                                          if (!lastTrackEvent) {
                                              lastTrackEvent = track.findNextTrackEvent(ts[ts.length - 1]);
                                          }

                                          //if (lastTrackEvent) {
                                            //  track.offsetTrackEvent(lastTrackEvent, -offset, true);
                                          //}






                                      });


                                      _this.updateDuration();
                                  }
                              }
                          });

                      };

                      this.update = this.updateProjectInfo = function (options) {
                          _popcornOptions.update(options);
                          _id = _popcornOptions.id;
                          _this.dispatchEvent("mediapopcornsettingschanged", _this);
                      };

                      this.autoAlign = function (dragTrackEvent, startTime, endTime, ALIGN_WIDTH, maxTime, minTime, ignoreTrackEvent) {
                          if (ALIGN_WIDTH < 10) {
                              ALIGN_WIDTH = 10;
                          }
                          var returnTime = { startTime: startTime, endTime: endTime },
                              lenTime = endTime - startTime;
                              rangeMin = ALIGN_WIDTH,
                              isAlign = false;
                          for (var i = 0 ; i < _tracks.length; i++) {
                              var track = _tracks[i];
                              //if (track != dragOverTrack) {
                              for (var j = 0; j < track.trackEvents.length; j++) {
                                  if (track.trackEvents[j] != dragTrackEvent && track.trackEvents[j] != ignoreTrackEvent) {
                                      var trackEventAttr = track.trackEvents[j].popcornOptions;

                                      var _curStartBeforeRange = app.timeToPixel(Math.abs(startTime - trackEventAttr.start) * 1000);
                                      var _curStartAffterRange = app.timeToPixel(Math.abs(startTime - trackEventAttr.end) * 1000);
                                      var _curEndBeforeRange = app.timeToPixel(Math.abs(endTime - trackEventAttr.start) * 1000);
                                      var _curEndAffterRange = app.timeToPixel(Math.abs(endTime - trackEventAttr.end) * 1000);
                                      var _curTrackEventMinRange;
                                      if (maxTime) {
                                          if (trackEventAttr.start > maxTime) {
                                              continue;
                                          } else if (trackEventAttr.start <= maxTime && trackEventAttr.end > maxTime) {
                                              _curTrackEventMinRange = Math.min(_curStartBeforeRange, _curStartAffterRange);
                                          } else if (trackEventAttr.end <= maxTime) {
                                              _curTrackEventMinRange = Math.min(_curStartBeforeRange, _curStartAffterRange, _curEndBeforeRange, _curEndAffterRange);
                                          }
                                      } else if (minTime) {
                                          if (trackEventAttr.end < minTime) {
                                              continue;
                                          } else if (trackEventAttr.start < minTime && minTime <= trackEventAttr.end) {
                                              _curTrackEventMinRange = Math.min(_curEndBeforeRange, _curEndAffterRange);
                                          } else if (trackEventAttr.start >= minTime) {
                                              _curTrackEventMinRange = Math.min(_curStartBeforeRange, _curStartAffterRange, _curEndBeforeRange, _curEndAffterRange);
                                          }
                                      } else {
                                          _curTrackEventMinRange = Math.min(_curStartBeforeRange, _curStartAffterRange, _curEndBeforeRange, _curEndAffterRange);
                                      }
                                      var alignLeft = -200;
                                      if (_curStartBeforeRange == _curTrackEventMinRange && _curStartBeforeRange <= ALIGN_WIDTH && _curStartBeforeRange <= rangeMin) {
                                          rangeMin = _curStartBeforeRange;
                                          returnTime.startTime = trackEventAttr.start;
                                          returnTime.endTime = trackEventAttr.start + lenTime;
                                          isAlign = true;
                                          alignLeft = app.timeToPixel(returnTime.startTime * 1000) + "px";
                                      } else if (_curStartAffterRange == _curTrackEventMinRange && _curStartAffterRange <= ALIGN_WIDTH && _curStartAffterRange <= rangeMin) {
                                          rangeMin = _curStartAffterRange;
                                          returnTime.startTime = trackEventAttr.end;
                                          returnTime.endTime = trackEventAttr.end + lenTime;
                                          if (ignoreTrackEvent) {
                                              returnTime.endTime = endTime;
                                          }
                                          isAlign = true;
                                          alignLeft = app.timeToPixel(returnTime.startTime * 1000) + "px";
                                      } else if (_curEndBeforeRange == _curTrackEventMinRange && _curEndBeforeRange <= ALIGN_WIDTH && _curEndBeforeRange <= rangeMin) {
                                          rangeMin = _curEndBeforeRange;
                                          if (trackEventAttr.start - lenTime >= 0) {
                                              returnTime.startTime = trackEventAttr.start - lenTime;
                                              returnTime.endTime = trackEventAttr.start;
                                          } else {
                                              returnTime.startTime = 0;
                                              returnTime.endTime = lenTime;
                                          }
                                          isAlign = true;
                                          alignLeft = app.timeToPixel(returnTime.endTime * 1000) + "px";
                                      } else if (_curEndAffterRange == _curTrackEventMinRange && _curEndAffterRange <= ALIGN_WIDTH && _curEndAffterRange <= rangeMin) {
                                          rangeMin = _curEndAffterRange;
                                          if (trackEventAttr.end - lenTime >= 0) {
                                              returnTime.startTime = trackEventAttr.end - lenTime;
                                              returnTime.endTime = trackEventAttr.end;
                                          } else {
                                              returnTime.startTime = 0;
                                              returnTime.endTime = lenTime;
                                          }
                                          isAlign = true;
                                          alignLeft = app.timeToPixel(returnTime.endTime * 1000) + "px";
                                      }
                                      if (isAlign) {
                                          var alignLine = document.createElement("div");
                                          alignLine.classList.add("align-line");
                                          alignLine.style.left = alignLeft;
                                          if ($(app.trackContainer.element).find("div.align-line").length == 0) track.view.element.parentNode.appendChild(alignLine);
                                      }
                                  }
                              }
                          }
                          if (!isAlign) {
                              $(app.trackContainer.element).find("div.align-line").remove();
                          }
                          return returnTime;
                      }

                      Object.defineProperties(this, {
                          ended: {
                              enumerable: true,
                              get: function () {
                                  if (_popcornWrapper.popcorn) {
                                      return _popcornWrapper.popcorn.ended;
                                  }
                                  return false;
                              }
                          },
                          url: {
                              enumerable: true,
                              get: function () {
                                  return _url;
                              },
                              set: function (val) {
                                  if (_url !== val) {
                                      _url = val;
                                      _ready = false;
                                      setupContent();
                                  }
                              }
                          },
                          target: {
                              get: function () {
                                  return _target;
                              },
                              set: function (val) {
                                  if (_target !== val) {
                                      _target = val;
                                      setupContent();
                                      _this.dispatchEvent("mediatargetchanged", _this);
                                  }
                              },
                              enumerable: true
                          },
                          muted: {
                              enumerable: true,
                              get: function () {
                                  return _popcornWrapper.muted;
                              },
                              set: function (val) {
                                  _popcornWrapper.muted = val;
                              }
                          },
                          ready: {
                              enumerable: true,
                              get: function () {
                                  return _ready;
                              }
                          },
                          clipData: {
                              get: function () {
                                  return _clipData;
                              },
                              enumerable: true
                          },
                          name: {
                              get: function () {
                                  return _name;
                              },
                              enumerable: true
                          },
                          id: {
                              get: function () {
                                  return _id;
                              },
                              enumerable: true
                          },
                          tracks: {
                              get: function () {
                                  return _tracks;
                              },
                              enumerable: true
                          },
                          orderedTracks: {
                              get: function () {
                                  return _orderedTracks;
                              },
                              enumerable: true
                          },
                          currentTime: {
                              get: function () {
                                  return _currentTime;
                              },
                              set: function (time) {
                                  if (time !== undefined) {
                                      _currentTime = time;
                                      if (_currentTime < 0) {
                                          _currentTime = 0;
                                      }
                                      if (_currentTime > _duration) {
                                          _currentTime = _duration;
                                      } //if
                                      _popcornWrapper.currentTime = _currentTime;
                                     // _this.dispatchEvent("mediatimeupdate", _this);
                                  } //if
                              },
                              enumerable: true
                          },
                          duration: {
                              get: function () {
                                  return _duration;
                              },
                              set: function (time) {
                                  if (typeof time === "number") {
                                      _duration = +time;
                                      if (_popcornWrapper) {
                                          _popcornWrapper.duration = _duration;
                                      }
                                      _this.dispatchEvent('durationChanged', _this);
                                      _this.fixTrackEventBounds();
                                  }
                              },
                              enumerable: true
                          },
                          json: {
                              get: function () {
                                  var resources = [

                                  ];
                                  for (var i = 0 ; i < _tracks.length; i++) {
                                      var track = _tracks[i];
                                      for (var j = 0; j < track.trackEvents.length; j++) {
                                          var trackEvent = track.trackEvents[j];
                                          if (trackEvent.clipdata && trackEvent.clipdata.detail) {
                                              var old = util.first(resources, function (item) {
                                                  if (item.__id == trackEvent.clipdata.detail.__id) {
                                                      return true;
                                                  }
                                                  return false;
                                              });
                                              if (!old) {


                                                  resources.push(util.deepClone(trackEvent.clipdata.detail, true));
                                              }
                                          }
                                      }
                                  }

                                  var exportJSONTracks = [];
                                  for (var i = 0, l = _orderedTracks.length; i < l; ++i) {
                                      exportJSONTracks.push(_orderedTracks[i].json);
                                  }

                                  var timeline = {
                                      id: _id,
                                      url: sanitizeUrl(),
                                      duration: _duration,
                                      tracks: exportJSONTracks,
                                  };

                                  util.merge(timeline, _popcornOptions);

                                  if (app.editorPlugin) {
                                      var pl = app.editorPlugin.getPluginList();
                                      for (var p in pl) {
                                          if (pl[p].getData) {
                                              pl[p].getData(timeline);
                                          }
                                      }
                                  }






                                  timeline.resources = resources;

                                  return timeline;
                              },
                              set: function (importData) {
                                  //导入数据
                                  var newTrack,
                                      url,
                                      i, l,
                                      fallbacks = [],
                                      sources = [];

                                  _popcornWrapper.popcorn.clear();
                                  _popcornWrapper.popcorn.suspend();

                                  function doImportTracks() {
                                      if (importData.tracks) {
                                          var importTracks = importData.tracks;
                                          if (Array.isArray(importTracks)) {
                                              for (i = 0, l = importTracks.length; i < l; ++i) {
                                                  newTrack = new Track(app, _this, {
                                                      id: importTracks[i].id
                                                  }, importTracks[i].trackType);
                                                  _this.addTrack(newTrack);
                                                  newTrack.json = importTracks[i];


                                              }

                                          } else if (console) {
                                          }
                                      }

                                      if (importData.resources && importData.resources.length > 0) {
                                          for (var i = 0 ; i < _tracks.length; i++) {
                                              var track = _tracks[i];
                                              for (var j = 0; j < track.trackEvents.length; j++) {
                                                  var trackEvent = track.trackEvents[j];
                                                  if (trackEvent.clipdata ) {
                                                      var r = util.first(importData.resources, function (item) {
                                                          if (item.__id == trackEvent.clipdata.clipid) {
                                                              return true;
                                                          }
                                                          return false;
                                                      });
                                                      if (r) {
                                                          trackEvent.clipdata.detail = r;
                                                      }
                                                  }
                                              }
                                          }
                                      }

                                  }

                                  if (importData.name) {
                                      _name = importData.name;
                                  }
                                  if (importData.target) {
                                      _this.target = importData.target;
                                  }

                                  url = importData.url;
                                  if (!Array.isArray(url)) {
                                      url = [url];
                                  }

                                 // if (importData.duration >= 0) {
                                      _duration = importData.duration;
                                      _this.url = "#t=," + _duration;
                                      doImportTracks();
                               //   }

                                  if (importData.clipData) {
                                      var tempClipData = importData.clipData,
                                          source;


                                      for (var key in tempClipData) {
                                          if (tempClipData.hasOwnProperty(key)) {
                                              source = tempClipData[key];
                                              if (!_clipData[key]) {
                                                  _clipData[key] = source;
                                              }
                                          }
                                      }
                                  }

                                  if (app.editorPlugin) {
                                      var pl = app.editorPlugin.getPluginList();
                                      for (var p in pl) {
                                          if (pl[p].loadData) {
                                              pl[p].loadData(importData);
                                          }
                                      }
                                  }

                                  _this.update(importData);

                                  _popcornWrapper.popcorn.resume();

                                 app.undo.push('load edl');
                              },
                              enumerable: true
                          },
                          registry: {
                              get: function () {
                                  return _registry;
                              },
                              set: function (val) {
                                  _registry = val;
                              },
                              enumerable: true
                          },
                          popcorn: {
                              enumerable: true,
                              get: function () {
                                  return _popcornWrapper;
                              }
                          },
                          paused: {
                              enumerable: true,
                              get: function () {
                                  return _popcornWrapper.paused;
                              },
                              set: function (val) {
                                  _popcornWrapper.paused = val;
                              }
                          },
                          SelectedTrackEvents: {
                              enumerable: true,
                              get: function () {
                                  return util.cloneArray( _selectedTrackEvents);
                              }
                          },
                          volume: {
                              enumerable: true,
                              get: function () {
                                  return _popcornWrapper.volume;
                              },
                              set: function (val) {
                                  _popcornWrapper.volume = val;
                              }
                          },
                          manifest: {
                              enumerable: true,
                              get: function () {
                                  return ProjectInfo.manifest;
                              }
                          },
                          saved:{
                              enumerable: true,
                              get: function () {
                                  return _saved;
                              },
                              set: function (val) {
                                  _saved = val;
                              }
                          },
                          type: {
                              enumerable: true,
                              get: function () {
                                  return _type;
                              }
                          },
                          popcornOptions: {
                              enumerable: true,
                              get: function () {
                                  return _popcornOptions;
                              },
                              set: function (val) {
                                  _popcornOptions = val;
                                  _this.dispatchEvent("mediapopcornsettingschanged", _this);
                                  setupContent();
                              }
                          }
                      });

                  },

              });


              return Media;

          });
h5.define('timeline/H5ShadowTack', [], function () {
    function H5ShadowTack(lastTrack, nextTrack) {
        var _this = this,
            _element = document.createElement("div"),
            _view;

        _element.classList.add("track");
        _element.classList.add("track-shadow");

        _this.resultantTrack = null;

        _view = {
            addTrackEventShadow: function (trackEventShadow) {
                trackEventShadow.track = _this;
                _element.appendChild(trackEventShadow.element);
            },
            removeTrackEventShadow: function (trackEventShadow) {
                trackEventShadow.track = null;
                _element.removeChild(trackEventShadow.element);
            }
        };

        Object.defineProperties(_view, {
            element: {
                enumerable: true,
                get: function () {
                    return _element;
                }
            },
            track: {
                enumerable: true,
                get: function () {
                    return _this;
                }
            }
        });

        Object.defineProperties(_this, {
            lastTrack: {
                enumerable: true,
                get: function () {
                    return lastTrack;
                }
            },
            nextTrack: {
                enumerable: true,
                get: function () {
                    return nextTrack;
                }
            },
            view: {
                enumerable: true,
                get: function () {
                    return _view;
                }
            },
            isShadow: {
                enumerable: true,
                get: function () {
                    return true;
                }
            },
            numShadowTrackEvents: {
                enumerable: true,
                get: function () {
                    return _element.childNodes.length;
                }
            }
        });
    }

    return H5ShadowTack;
});

h5.define('timeline/H5ShadowManager', ["timeline/H5ShadowTack"], function (H5ShadowTack) {

    function H5ShadowManager(media, tracksContainerElement) {

        var _media = media,
            _tracksContainerElement = tracksContainerElement;

        //创建一个Track的影子
        function createH5ShadowTackForNextTrack(track, nextTrack) {
            var shadowTrak;
            if (!track.shadow) {
                shadowTrak = track.shadow = new H5ShadowTack(track, nextTrack);
                if (!nextTrack) {
                    _tracksContainerElement.appendChild(shadowTrak.view.element);
                }
                else {
                    _tracksContainerElement.insertBefore(shadowTrak.view.element, nextTrack.view.element);
                }
            }
            return track.shadow;
        }

        function cleanUpH5ShadowTacks() {
            var tracks = _media.tracks;
            for (var i = 0, l = tracks.length; i < l; ++i) {
                cleanUpH5ShadowTack(tracks[i]);
            }
        }

        function cleanUpH5ShadowTack(track) {
            var shadowTrak = track.shadow;
            if (shadowTrak && shadowTrak.numH5ShadowTackEvents === 0) {
                _tracksContainerElement.removeChild(shadowTrak.view.element);
                track.shadow = null;
            }
        }

        function cleanUpH5ShadowTackEvent(trackEventView) {
            var shadowTrak = trackEventView.shadow.track;
            trackEventView.cleanupGhost();
            if (shadowTrak.lastTrack) {
                cleanUpH5ShadowTack(shadowTrak.lastTrack);
            }
        }

        this.trackEventDragged = function (trackEventView, trackView) {
            var track, nextTrack,
                ghostLeft, ghostWidth,
                ghostLeftAbsolute,
                overlappingTrackEvent,
                overlappingDirection;
            if (trackView) {
                track = trackView.track;

                overlappingTrackEvent = trackView.findOverlappingTrackEvent(trackEventView);
                if (overlappingTrackEvent) {

                    overlappingDirection = trackView.findOverlappingDirection(trackEventView, overlappingTrackEvent.view);
                    if (overlappingDirection === "top" || overlappingDirection === "bottom") {
                        nextTrack = _media.getNextTrack(track);
                        if (!nextTrack || nextTrack.view.findOverlappingTrackEvent(trackEventView)) {
                            nextTrack = createH5ShadowTackForNextTrack(track, nextTrack);
                        }
                        if (trackEventView.shadow && trackEventView.shadow.track !== nextTrack) {
                            cleanUpH5ShadowTackEvent(trackEventView);
                        }
                        if (!trackEventView.shadow) {
                            nextTrack.view.addTrackEventGhost(trackEventView.createGhost());
                        }
                        trackEventView.updateGhost();
                    } else {
                        if (trackEventView.shadow && trackEventView.shadow.track !== track) {
                            cleanUpH5ShadowTackEvent(trackEventView);
                        }
                        if (!trackEventView.shadow) {
                            if (overlappingDirection === "left") {
                                ghostLeft = overlappingTrackEvent.view.element.offsetLeft - trackEventView.element.offsetWidth;
                                ghostLeftAbsolute = overlappingTrackEvent.view.element.getBoundingClientRect().left - trackEventView.element.offsetWidth;
                            } else if (overlappingDirection === "right") {
                                ghostLeft = overlappingTrackEvent.view.element.offsetLeft + overlappingTrackEvent.view.element.offsetWidth;
                                ghostLeftAbsolute = overlappingTrackEvent.view.element.getBoundingClientRect().left + overlappingTrackEvent.view.element.offsetWidth;
                            }
                            ghostWidth = trackEventView.element.offsetWidth;
                            if (ghostLeft < 0 ||
                                 (ghostLeft + ghostWidth) > _tracksContainerElement.offsetWidth ||
                                 track.view.findOverlappingTrackEvent(trackEventView, ghostLeftAbsolute, ghostWidth)) {
                                nextTrack = _media.getNextTrack(track);
                                if (!nextTrack || nextTrack.view.findOverlappingTrackEvent(trackEventView)) {
                                    nextTrack = createH5ShadowTackForNextTrack(track, nextTrack);
                                }
                                if (trackEventView.shadow && trackEventView.shadow.track !== nextTrack) {
                                    cleanUpH5ShadowTackEvent(trackEventView);
                                }
                                if (!trackEventView.shadow) {
                                    nextTrack.view.addTrackEventGhost(trackEventView.createGhost());
                                }
                                trackEventView.updateGhost();
                            } else {
                                track.view.addTrackEventGhost(trackEventView.createGhost(ghostLeft));
                            }
                        }
                    }
                }
                else if (trackEventView.shadow) {
                    track = trackEventView.shadow.track;
                    trackEventView.cleanupGhost();
                    cleanUpH5ShadowTacks();
                }
            }
            else if (trackEventView.shadow) {
                track = trackEventView.shadow.track;
                trackEventView.cleanupGhost();
                cleanUpH5ShadowTacks();
            }
        };

        this.removeShadowAfterDrop = function (trackEvent) {
            var currentTrack = trackEvent.track,
                ghost = trackEvent.view.shadow;

            if (ghost && ghost.track) {
                trackEvent.view.cleanupGhost(currentTrack);
                cleanUpH5ShadowTacks();
            }
        };

    }

    return H5ShadowManager;

});

h5.define('timeline/H5TrackContainer', ["jquery",
    "util/H5DragDrop",
    "core/TrackEvent",
    "timeline/H5ShadowManager",
    "core/TrackEventPluginManager",
    "util/util"
    ],
  function ($, H5DragDrop, TrackEvent,  H5ShadowManager, TrackEventPluginManager, util) {

      var TWEEN_PERCENTAGE = 0.35,      // diminishing factor for tweening (see followCurrentTime)
          TWEEN_THRESHOLD = 10,         // threshold beyond which tweening occurs (see followCurrentTime)
          TRACK_HEIGHT = 30,
          TRACKEVENT_BORDER_OFFSET = 2; // clientLeft prevents track events from being positioned side by
      // side, so factor it into our calculations.

      return function (app, media, tracksElement, zoomControlElement) {

          var _media = media,
              _this = this;


          var _element = tracksElement.querySelector(".wrapper"),
              _container = tracksElement.querySelector(".tracks-container"),
              _boundingBoxElement = _element.querySelector(".selection-box"),
              _offsetLeft = parseInt($(".timeline-trackcontainer", tracksElement).css("paddingLeft"));

          var _vScrollbar, _hScrollbar;

          var _droppable;

          var _trackEventList;

          var _leftViewportBoundary = 0,
              _viewportWidthRatio = 0.1,
              _nextEventMin, _nextEventMax;


              app.trackContainer = _this;

          var _newTrackForDroppables;

          _this.shadowManager = new H5ShadowManager(media, _container);


          app.addEventListener("trackorderchanged", function (e) {
              var orderedTracks = e.data;
              for (var i = 0, l = orderedTracks.length; i < l; ++i) {
                  var trackElement = orderedTracks[i].view.element;
                  if (trackElement !== _container.childNodes[i]) {
                      _container.insertBefore(trackElement, _container.childNodes[i] || null);
                  }
              }
          });

          H5DragDrop.addEventListener("dropfinished", function () {
              _vScrollbar.update();
          });


          _container.addEventListener("click", function (e) {
              //if (e && e.srcElement === _container) {
              _media.deselectAllTrackEvents();
            //  }
          });

          //鼠标滚动控制时间线变长缩短
          var scrollFunc = function (e) {
              e = e || window.event;

              if (e.ctrlKey) {
                  if (e.wheelDelta) {  //判断浏览器IE，谷歌滑轮事件
                      if (e.wheelDelta > 0) { //当滑轮向上滚动时
                          //console.log("放大");
                          $(zoomControlElement).children('.next').click();
                      }
                      if (e.wheelDelta < 0) { //当滑轮向下滚动时
                          //console.log("缩小");
                          $(zoomControlElement).children('.pre').click();
                      }
                  } else if (e.detail) {  //Firefox滑轮事件
                      if (e.detail > 0) { //当滑轮向上滚动时
                          //console.log("放大");
                          $(zoomControlElement).children('.next').click();
                      }
                      if (e.detail < 0) { //当滑轮向下滚动时
                          //console.log("缩小");
                          $(zoomControlElement).children('.pre').click();
                      }
                  }
              }
          }
          _container.addEventListener("mousewheel", scrollFunc);
          _container.addEventListener("DOMMouseScroll", scrollFunc);
          //屏蔽浏览器页面缩放功能
          window.addEventListener("mousewheel", function (e) {
              if (e.ctrlKey) {
                  e.preventDefault();
              }
          }, false);
          //For Firefox
          window.addEventListener("DOMMouseScroll", function (e) {
              if (e.ctrlKey) {
                  e.preventDefault();
              }
          });


          this.setScrollbars = function (vertical, horizontal) {
              _vScrollbar = vertical;
              _hScrollbar = horizontal;
              _hScrollbar.update();
              _vScrollbar.update();
          };

          function resetContainer() {
              _offsetLeft = parseInt($(".timeline-trackcontainer", tracksElement).css("paddingLeft"));

              var w = $(_container).width();
              var ww = $(_element).width();
              var realWidth = app.timeToPixel(_media.duration * 1000) + ww * 0.3;
              realWidth = Math.ceil(realWidth);
              if (realWidth < ww) {
                  realWidth = ww;
              }
              if (realWidth != w) {
                  $(_container).width(realWidth);
                  _containerRect = _container.getBoundingClientRect();
                  _hScrollbar.update();
              }


              //if (!_element.clientWidth)
              //    return;

              //_element.scrollLeft = _container.scrollWidth * _leftViewportBoundary;


              //_container.style.width = _element.clientWidth / _viewportWidthRatio + "px";

              var tracks = _media.tracks,
                  trackEvents;

              // We want to update the resize arrows used as the size of trackevents increase
              for (var i = 0; i < tracks.length; i++) {
                  trackEvents = tracks[i].trackEvents;

                  for (var k = 0; k < trackEvents.length; k++) {
                      trackEvents[k].view.setResizeArrows();
                      trackEvents[k].view.update(trackEvents[k].popcornOptions);
                  }
              }

              _vScrollbar.update();
              _hScrollbar.update();
          }

          _media.addEventListener("mediaready", function () {
              resetContainer();
              var tracks = _media.orderedTracks;
              for (var i = 0, il = tracks.length; i < il; ++i) {
                  var trackView = tracks[i].view;
                  _container.appendChild(trackView.element);
                  trackView.duration = _media.duration;
                  trackView.parent = _this;
              }
          });

          function onTrackEventSelected(e) {
              _media.selectTrackEvent(e.data);
          }

          function onTrackEventDeselected(e) {
              _media.deselectTrackEvent(e.data);
          }

          function onTrackAdded(e) {
              var track = e.data,
                  trackView = track.view;

              track.view.addEventListener("plugindropped", onPluginDropped);
              track.view.addEventListener("trackeventmousedown", onTrackEventMouseDown);

              track.addEventListener("trackeventselected", onTrackEventSelected);
              track.addEventListener("trackeventdeselected", onTrackEventDeselected);

            //  _media.addEventListener("trackeventadded", onTrackEventAdded);

              trackView.addEventListener("trackeventdropped", onTrackEventDropped);

              _container.appendChild(trackView.element);
              trackView.duration = _media.duration;
              trackView.parent = _this;
              if (_vScrollbar) {
                  _vScrollbar.update();
              }
          }

          function onTrackEventDragStarted(e) {
              var trackEventView = e.target,
                  element = trackEventView.element,
                  trackView = trackEventView.trackEvent.track.view,
                  trackEvent= trackEventView.trackEvent,
                  topOffset = element.getBoundingClientRect().top - _container.getBoundingClientRect().top ;

              trackView.element.removeChild(element);

              element.style.top = topOffset + "px";

              _container.appendChild(element);
              $(element).addClass("track-event-dragging");

              var dragData = {
                  trackEventView: trackEventView,
                  trackEvent: trackEvent,
                  track: trackEvent.track,
                  nextTrackEvent: trackEvent.track.findNextTrackEvent(trackEvent),
                  prevTrackEvent: trackEvent.track.findPrevTrackEvent(trackEvent)
              };

              //
              trackEvent.plugin.startDrag(app, _media, dragData, e.data);

              _vScrollbar.update();
          }

          function onTrackEventDragged(draggable, droppable, e) {
              var trackEventView = draggable.data,
                  trackEvent = trackEventView.trackEvent;

              var eleRect = trackEventView.element.getBoundingClientRect();
              var trackRect = trackEvent.track.view.element.getBoundingClientRect();

              var dragData = {
                  trackEventView: trackEventView,
                  trackEvent: trackEvent,
                  track: trackEvent.track,
                  left: eleRect.left - trackRect.left,
                  nextTrackEvent: trackEvent.track.findNextTrackEvent(trackEvent),
                  prevTrackEvent: trackEvent.track.findPrevTrackEvent(trackEvent)
              };

            //  console.log("left: " + $(trackEventView.element).offset().left);
              $(_element).find("div.align-line").remove();
              trackEvent.plugin.dragging(app, _media, dragData, e);


             // _this.shadowManager.trackEventDragged(draggable.data, droppable.data);
              _vScrollbar.update();
          }

          var existingTracks = _media.tracks;
          for (var i = 0; i < existingTracks.length; ++i) {
              onTrackAdded({
                  data: existingTracks[i]
              });
          }


          function onTrackEventDropped(e) {
              var trackEvent = e.data.data;
              if (trackEvent && trackEvent.plugin) {

                  var element = trackEvent.view.element;

                  try{
                      _container.removeChild(element);
                  }
                  catch (e) {

                  }
                  element.style.top = 0 + "px";
                  trackEvent.track.view.element.appendChild(element);
                  $(element).removeClass("track-event-dragging");



                  trackEvent.plugin.dragged(e.data, app, _media, e.data.oEvent);
                  if (trackEvent) {
                      _media.updateDuration();
                      if (_media.paused) {
                          _media.currentTime = trackEvent.popcornOptions.start;
                      }
                  }
              }

          }



          function onPluginDropped(e) {
              $(_element).find("div.align-line").remove();
              if (e.data.plugin) {


                  function __dropped(trackEvent) {
                      if (trackEvent) {
                          _media.deselectAllTrackEvents();
                          trackEvent.selected = true;
                          if (_media.paused) {
                              _media.currentTime = trackEvent.popcornOptions.end;
                          }
                          if (trackEvent.track.trackType == "VA" || trackEvent.track.trackType == "A")
                          {
                              _media.currentTime = trackEvent.popcornOptions.start;
                              _media.currentTime = trackEvent.popcornOptions.end-0.04;
                          }
                          app.media.pause();
                      }
                  }
                  e.data.plugin.dropped(e.data, app, _media, e.data.oEvent, __dropped);

                  //var trackEvent = e.data.plugin.dropped(e.data, app, _media, e.data.oEvent);
                  //if (trackEvent) {
                  //    _media.deselectAllTrackEvents();
                  //    trackEvent.selected = true;
                  //    if (_media.paused) {
                  //        _media.currentTime = trackEvent.popcornOptions.start;
                  //    }
                  //}
              }

          }


          function onTrackEventMouseDown(e) {
              var trackEvent = e.data.trackEvent,
                  tracks, i, length,
                  wasSelected = trackEvent.selected,
                  originalEvent = e.data.originalEvent;

              //暂时只允许选择一个
              _media.deselectAllTrackEvents();
             // if (!originalEvent.shiftKey && !trackEvent.selected) {
             //     tracks = _media.tracks;
             //     for (i = 0, length = tracks.length; i < length; i++) {
             //         tracks[i].deselectEvents(trackEvent);
            //      }
            //  }

              trackEvent.selected = true;


              function onTrackEventMouseUp() {
                  window.removeEventListener("mouseup", onTrackEventMouseUp, false);
                  window.removeEventListener("mousemove", onTrackEventDragStarted, false);

                  if (!originalEvent.shiftKey) {
                      tracks = _media.tracks;
                      for (i = 0, length = tracks.length; i < length; i++) {
                          tracks[i].deselectEvents(trackEvent);
                      }
                  } else if (trackEvent.selected && wasSelected) {
                      trackEvent.selected = false;
                  }
              }

              function onTrackEventDragStarted() {
                  window.removeEventListener("mousemove", onTrackEventDragStarted, false);
                  window.removeEventListener("mouseup", onTrackEventMouseUp, false);
              }

              window.addEventListener("mouseup", onTrackEventMouseUp);
              window.addEventListener("mousemove", onTrackEventDragStarted);
          }

           function onTrackEventClicked() {
            //app.editor.editTrackEvent(trackEvent);
           }



          function onTrackEventResizeStarted(e) {
              var trackEventView = e.target,
                   trackEvent = trackEventView.trackEvent;

               if (trackEvent && trackEvent.plugin) {
                   trackEvent.plugin.resize(e.data, app, _media, trackEvent);
              }


          }
          function onTrackEventResizeStopped() {
              $(_element).find("div.align-line").remove();
          }

          _media.addEventListener("trackeventadded", function (e) {
              var trackEventView = e.data.view;
              trackEventView.setDragHandler(onTrackEventDragged);
              trackEventView.addEventListener("trackeventdragstarted", onTrackEventDragStarted);
              trackEventView.addEventListener("trackeventresizestarted", onTrackEventResizeStarted);
              trackEventView.addEventListener("trackeventresizestopped", onTrackEventResizeStopped);

              trackEventView.addEventListener("trackeventmousedown", onTrackEventMouseDown);
              trackEventView.element.addEventListener("mousedown", onTrackEventClicked);
            //  e.data.addEventListener("trackeventdeselected", onTrackEventDeselected);

              _vScrollbar.update();
          });

          _media.addEventListener("trackeventremoved", function (e) {
              var trackEventView = e.data.view,
                  trackEvent = e.data;

              _media.deselectTrackEvent(trackEvent);

              trackEventView.setDragHandler(null);
              trackEventView.removeEventListener("trackeventdragstarted", onTrackEventDragStarted);
              trackEventView.removeEventListener("trackeventresizestarted", onTrackEventResizeStarted);
              trackEventView.removeEventListener("trackeventresizestopped", onTrackEventResizeStopped);


              trackEventView.removeEventListener("trackeventmousedown", onTrackEventMouseDown);
              trackEventView.element.removeEventListener("mousedown", onTrackEventClicked, false);
           //   e.data.removeEventListener("trackeventdeselected", onTrackEventDeselected);


              _vScrollbar.update();
          });

          _media.addEventListener('durationChanged', function (e) {
              resetContainer();

          });

          _media.addEventListener("trackadded", onTrackAdded);

          _media.addEventListener("trackremoved", function (e) {
              var trackView = e.data.view,
                  track = e.data;

              trackView.removeEventListener("plugindropped", onPluginDropped);
              trackView.removeEventListener("trackeventdropped", onTrackEventDropped);
              trackView.removeEventListener("trackeventmousedown", onTrackEventMouseDown);

              track.removeEventListener("trackeventselected", onTrackEventSelected);
              track.removeEventListener("trackeventdeselected", onTrackEventDeselected);
             // trackView.removeEventListener("trackeventdropped", onTrackEventDropped);

              _container.removeChild(trackView.element);
              if (_vScrollbar) {
                  _vScrollbar.update();
              }
          });


          _this.followCurrentTime = function () {
              var pos = app.timeToPixel(_media.currentTime * 1000),
                  width = _element.clientWidth || $(_element).width(),
                  minSpace = width * 0.3,
                  xOffset = pos - _element.scrollLeft,
                  target = pos - (width -  minSpace);

              if (xOffset >= minSpace && !_media.paused) {
                  _element.scrollLeft = Math.round(target);

              }


          };

          _this.update = function () {
              resetContainer();
          };


          /**
           * Member: setContainerBounds
           *
           * Adjusts the viewport boundaries. A left and width value can be specified
           * representing the left and width percentage of the viewport with respect to its
           * container. If either is -1, it is ignored, and the old value is preserved.
           *
           * @param {Number} left: Left side of the viewport as percent from 0 - 1
           * @param {Number} width: Ratio of viewport to tracks (0 - 1)
           */
          _this.setViewportBounds = function (left, width) {
              _leftViewportBoundary = left >= 0 ? (left > 1 ? 1 : left) : _leftViewportBoundary;
              _viewportWidthRatio = width >= 0 ? (width > 1 ? 1 : width) : _viewportWidthRatio;
              resetContainer();
          };

          _this.snapTo = function (time) {
              var p = time / _media.duration,
                  newScroll = _container.clientWidth * p,
                  maxLeft = _container.clientWidth - _element.clientWidth;
              if (newScroll < _element.scrollLeft || newScroll > _element.scrollLeft + _element.clientWidth) {
                  if (newScroll > maxLeft) {
                      _element.scrollLeft = maxLeft;
                      return;
                  }
                  _element.scrollLeft = newScroll;
              }
          };

          this.getTrackWidth = function () {
              return _container.offsetWidth;
          };

          // The properties `element` and `container` do not have getter functions, but are immediately assigned
          // values to prevent a Safari crash; a function which solely returns `_container` fails to accomplish its task
          // (likely a hidden webkit/safari bug).
          Object.defineProperties(this, {
              element: {
                  enumerable: true,
                  value: _element
              },
              container: {
                  enumerable: true,
                  value: _container
              },
              offsetLeft: {
                  enumerable: true,
                  get: function () {
                      return _offsetLeft;
                  }
              }
          });

      };

  });
/*
 * 可拖动的时间点
\*/
h5.define('timeline/H5TimePosition', ["util/util"],
  function (util) {

      var SCROLL_INTERVAL = 16,
          SCROLL_DISTANCE = 20,
          MOUSE_SCRUBBER_PIXEL_WINDOW = 3,
          TIMELINE_POS_OFFSET_X = 0;

      return function (app, parentElement, media, tracksContainer) {
          var _container = parentElement.querySelector(".pos-container"),
              _node = _container.querySelector(".pos-node"),
              _timeTooltip = _container.querySelector(".time-tooltip"),
              _line = _container.querySelector(".pos-line"),
              _fill = _container.querySelector(".fill-bar"),
              _total = _container.querySelector(".total-bar"),
              _timecanvas = parentElement.querySelector(".canvas-container"),
              _tracksContainer = tracksContainer,
              _tracksContainerWidth,
              _media = media,
              _mouseDownPos,
              _currentMousePos,
              _timelineMousePos,
              _scrollInterval = -1,
              _rect,
              _width = 0,
              _isPlaying = false,
              _isScrubbing = false,
              _lastTime = -1,
              _lastScrollLeft = _tracksContainer.element.scrollLeft,
              _lastScrollWidth = _tracksContainer.element.scrollWidth,
              _lineWidth = 0,
              _isSeeking = false,
              _seekMouseUp = false,
              _lastZoom = app.zoom();

          function setNodePosition() {
              var duration = _media.duration,
                  currentTime = _media.currentTime,
                  tracksElement = _tracksContainer.element,
                  scrollLeft = tracksElement.scrollLeft,
                  scrollWidth = tracksElement.scrollWidth,
                  zoom = app.zoom();

              if (_lastTime !== currentTime || _lastScrollLeft !== scrollLeft || _lastScrollWidth !== scrollWidth ||
                  _lastZoom !== zoom ) {
                  setTimeTooltip();

                  var pos = app.timeToPixel(currentTime * 1000) - scrollLeft;


                  if (pos > scrollWidth || pos < 0) {
                      _node.style.display = "none";
                      _line.style.display = "none";
                      _fill.style.display = "none";
                  } else {
                      _node.style.left = (pos  + TIMELINE_POS_OFFSET_X)+ "px";
                      _node.style.display = "block";
                      _line.style.left = (pos + TIMELINE_POS_OFFSET_X) + "px";
                      _line.style.display = "block";

                      _fill.style.width = pos + "px";
                      _fill.style.display = "block";
                  }
              }

              _lastTime = currentTime;
              _lastScrollLeft = scrollLeft;
              _lastScrollWidth = scrollWidth;
              _lastZoom = zoom;
          }

          function onMouseUp() {
              _seekMouseUp = true;

              _timeTooltip.classList.remove("tooltip-no-transition-on");

              if (_isPlaying && !_isSeeking) {
                  _media.play();
              }

              if (_isScrubbing) {
                  _isScrubbing = false;
              }

              clearInterval(_scrollInterval);
              _scrollInterval = -1;

              parentElement.addEventListener("mouseover", onMouseOver);
              window.removeEventListener("mouseup", onMouseUp, false);
              window.removeEventListener("mousemove", onMouseMove, false);
          } //onMouseUp

          function scrollTracksContainer(direction) {
              if (direction === "right") {
                  _scrollInterval = setInterval(function () {
                      if (_currentMousePos < _rect.right - MOUSE_SCRUBBER_PIXEL_WINDOW) {
                          clearInterval(_scrollInterval);
                          _scrollInterval = -1;
                      }
                      else {
                          var old = _currentMousePos;
                          _currentMousePos += SCROLL_DISTANCE;
                          _tracksContainer.element.scrollLeft += SCROLL_DISTANCE;
                          evalMousePosition();
                          setNodePosition();
                          _mouseDownPos = old;
                      }
                  }, SCROLL_INTERVAL);
              }
              else {
                  _scrollInterval = setInterval(function () {
                      if (_currentMousePos > _rect.left + MOUSE_SCRUBBER_PIXEL_WINDOW) {
                          clearInterval(_scrollInterval);
                          _scrollInterval = -1;
                      }
                      else {
                          var old = _currentMousePos;
                          _currentMousePos -= SCROLL_DISTANCE;
                          _tracksContainer.element.scrollLeft -= SCROLL_DISTANCE;
                          evalMousePosition();
                          setNodePosition();
                          _mouseDownPos = old;
                      }
                  }, SCROLL_INTERVAL);
              }
          } //scrollTracksContainer
          function evalMousePosition() {
              var diff = _currentMousePos - _mouseDownPos;
            //  diff = Math.max(0, diff);

              // if (diff > 0) {
              //setCurrentTime(_media.currentTime + app.pixelToTime(diff) / 1000);
              var time = _media.currentTime + app.pixelToTime(diff) / 1000;
                  _media.updateDuration(time);
                  _media.currentTime = time;
                  _mouseDownPos = _currentMousePos;
             // }

              //_media.currentTime = (diff + _tracksContainer.element.scrollLeft) / _tracksContainerWidth * _media.duration;
          } //evalMousePosition

          function onMouseMove(e) {
              _currentMousePos = e.pageX;
             // console.log(_currentMousePos);
              if (_scrollInterval === -1) {
                  if (_currentMousePos > _rect.right - MOUSE_SCRUBBER_PIXEL_WINDOW) {
                      scrollTracksContainer("right");
                  }
                  else if (_currentMousePos < _rect.left + MOUSE_SCRUBBER_PIXEL_WINDOW && _tracksContainer.element.scrollLeft > 0) {
                      scrollTracksContainer("left");
                  } //if
              } //if

              onTimelineMouseMove(e);
              evalMousePosition();
              setNodePosition();



          } //onMouseMove

          function onSeeked() {
              _isSeeking = false;

              _media.removeEventListener("mediaseeked", onSeeked);

              if (_isPlaying && _seekMouseUp) {
                  _media.play();
              }
          }

          function onTimelineMouseMove(e) {
            //  console.log(e.clientX);

              _timelineMousePos = e.clientX - (parentElement.offsetLeft);
              if (_timelineMousePos < 0) {
                  _timelineMousePos = 0;
              }
              if (_timelineMousePos > _container.offsetWidth) {
                  _timelineMousePos = _container.offsetWidth;
              }
              _timeTooltip.style.left = _timelineMousePos + "px";
              setTimeTooltip();

              //var butterTrayOffSet = document.querySelector(".butter-tray").offsetLeft;

              //if (document.querySelector("html").dir === "rtl") {
              //    _timelineMousePos = e.clientX - (parentElement.offsetLeft + butterTrayOffSet);
              //} else {
              //    _timelineMousePos = e.clientX - parentElement.offsetLeft;
              //}

              //if (_timelineMousePos < 0) {
              //    _timelineMousePos = 0;
              //} else if (_timelineMousePos > _container.offsetWidth) {
              //    _timelineMousePos = _container.offsetWidth;
              //}

              //_timeTooltip.style.left = _timelineMousePos + "px";
              //setTimeTooltip();
          }

          //单击播放进度条，直接跳转到指定位置
          function onTimelineMouseDown(e) {
              e.preventDefault();
              var pos = e.pageX - _container.getBoundingClientRect().left + _tracksContainer.element.scrollLeft;
              var time = app.pixelToTime(pos) / 1000;

              _media.updateDuration(time);
              _media.currentTime = time;

              setNodePosition();
          }

          function setTimeTooltip() {
              var time = 0;
              if (_isScrubbing) {
                  time = _media.currentTime * 1000;
              }
              else {
                  time = app.pixelToTime(_timelineMousePos + _tracksContainer.element.scrollLeft);
              }
              _timeTooltip.innerHTML = util.toSmpteString(time);
          }

          function onMouseOver(e) {
              onTimelineMouseMove(e);
              _timeTooltip.classList.add("tooltip-no-transition-on");

              parentElement.addEventListener("mousemove", onTimelineMouseMove);
              parentElement.removeEventListener("mouseover", onMouseOver, false);
              parentElement.addEventListener("mouseout", onMouseOut);
          }

          function onMouseOut() {
              _timeTooltip.classList.remove("tooltip-no-transition-on");

              parentElement.removeEventListener("mousemove", onTimelineMouseMove, false);
              parentElement.removeEventListener("mouseout", onMouseOut, false);
              parentElement.addEventListener("mouseover", onMouseOver);
          }

          var onMouseDown = this.onMouseDown = function (e) {
              //var pos = e.pageX - _container.getBoundingClientRect().left;
              // Stop text selection in chrome.
              e.preventDefault();

              _isScrubbing = true;
              _isSeeking = true;
              _seekMouseUp = false;
              _media.addEventListener("mediaseeked", onSeeked);

              if (_isPlaying) {
                  _media.pause();
              }

             // _media.currentTime = app.pixelToTime((pos + _tracksContainer.element.scrollLeft)) / 1000;
             // setNodePosition();
              _mouseDownPos = e.pageX ;

              //if (_media.currentTime >= 0) {
              //    _timeTooltip.innerHTML = util.toTimecode(_media.currentTime, 0);
              //}
              //_timeTooltip.classList.add("tooltip-no-transition-on");

              parentElement.removeEventListener("mouseout", onMouseOut, false);
              parentElement.removeEventListener("mousemove", onTimelineMouseMove, false);
              window.addEventListener("mousemove", onMouseMove);
              window.addEventListener("mouseup", onMouseUp);
          }; //onMouseDown

          parentElement.addEventListener("mouseover", onMouseOver);

          this.update = function (containerWidth) {
              _width = containerWidth || _width;
              _tracksContainerWidth = _tracksContainer.container.getBoundingClientRect().width;
              _rect = _container.getBoundingClientRect();
              _lineWidth = _line.clientWidth;
              setNodePosition();
          };

          this.ready = function () {
             // _container.addEventListener("mousedown", onMouseDown);
              _node.addEventListener("mousedown", onMouseDown);
              _line.addEventListener("mousedown", onMouseDown);

              _total.addEventListener('mousedown', onTimelineMouseDown);
              _fill.addEventListener('mousedown', onTimelineMouseDown);
              _timecanvas.addEventListener('mousedown', onTimelineMouseDown);
          };


          _media.addEventListener("mediaplay", function () {
              _isPlaying = true;
          });



          _media.addEventListener("mediapause", function () {
              // scrubbing is for the mouseup and mousedown state.
              // seeking is the media's state.
              // these are not always the same.
              if (!_isScrubbing && !_isSeeking) {
                  _isPlaying = false;
              }
          });

          _media.addEventListener("mediatimeupdate", setNodePosition);
      };
  });

/*
 * 时间线
 */
h5.define('timeline/H5Timeline', ["jquery","util/Object", "timeline/H5TimePosition", "util/util"],
    function ($, Obj, H5TimePosition, util) {

    var CANVAS_CONTAINER_PADDING = 5,
        TICK_COLOR = "#676767";

    var Timeline = Obj.extend({
        init: function (app, media, statusArea, tracksContainer, hScrollbar) {
            this._super();
            var _element = statusArea.querySelector(".time-bar"),
           _canvas = _element.querySelector("canvas"),
           _canvasContainer = _element.querySelector(".canvas-container"),
           _media = media,
           _zoom,
           _this = this,
           offsetTick,
           _tracksContainer = tracksContainer,
           _tickStyle = {
               space: 15, //刻度间隔
               long: 20, //长刻度长度
               short: 10, //短刻度长度
               interval: 5, //长刻度间隔
               tickUnit: 1000 //每个刻度代表的长度 毫秒
           };
            this._zoomList = [
             { space: 40, tickUnit: 60000, interval: 5 },
             { space: 20, tickUnit: 15000, interval: 4 },
             { space: 20, tickUnit: 5000, interval: 6 },
             { space: 20, tickUnit: 2000, interval: 5 },
             { space: 15, tickUnit: 1000, interval: 5 },
             { space: 15, tickUnit: 500, interval: 10 },
             { space: 15, tickUnit: 1000 / 25, interval: 25 } //帧
           ];
            offsetTick = 0;
            _zoom = 4;
            function startTime() {
                return offsetTick * _tickStyle.tickUnit;
            }
            this.zoom = function (val) {
                if (typeof val !== "undefined") {
                    drawTicks(val);
                } else {
                    return _zoom;
                }
            }
            function pixelToTime(len) {
                return (_tickStyle.tickUnit / _tickStyle.space) * len;
            }

            function timeToPixel(time) {
                return (time / _tickStyle.tickUnit) * _tickStyle.space;
            }

            app.pixelToTime = pixelToTime;
            app.timeToPixel = timeToPixel;
            app.zoom = this.zoom;

            var _scrubber = new H5TimePosition(app, _element, _media, _tracksContainer, hScrollbar);


            function drawTicks(zoom) {
                if (typeof zoom === "number" && zoom != _zoom) {
                    _zoom = zoom;

                    var sl = tracksContainer.element.scrollLeft;
                    var stime = pixelToTime(sl);

                    util.merge(_tickStyle, _this._zoomList[_zoom], true);

                    var newSl = timeToPixel(stime);

                    tracksContainer.element.scrollLeft = newSl;

                    _this.dispatchEvent("zoomchanged");
                    app.dispatchEvent("zoomchanged");
                    return;
                }

                if (_canvas.width != $(_element).width()) {
                    _canvas.width = $(_element).width();
                    _canvas.height = $(_canvasContainer).height();
                }



                var rect = _canvas.getBoundingClientRect();
                var offsetLeft = tracksContainer.element.scrollLeft ;
                var h = $(_canvasContainer).height();

               // console.log('scroll left:' + offsetLeft);

                var tick = pixelToTime(offsetLeft) / _tickStyle.tickUnit;

                var startTick = Math.ceil(tick);
                var startPixel = timeToPixel((startTick - tick) * _tickStyle.tickUnit);
                var curTick = startTick;

                var context = _canvas.getContext("2d");
                context.save();
                context.clearRect(0, 0, _canvas.width, _canvas.height);
                context.textBaseline = "top";
                context.font = "normal 14px profont";
                context.fillStyle = "#bbbbbb";
                context.beginPath();

                var x = startPixel;
                var y = h;
                var text = '';

                while (x <= (rect.width + rect.left)) {
                    var l = _tickStyle.short;
                    var t = _canvas.height - _tickStyle.long - 2;
                    var text = "";
                    if (curTick % _tickStyle.interval === 0) {
                        l = _tickStyle.long;

                        var pos = curTick * _tickStyle.tickUnit;

                        text = util.toSmpteString(pos, 24);
                    }


                    var x1 = x - 1 / 2;
                    if (Math.floor(x1) !== x1) {
                        x1 = x + x1 - Math.floor(x1);
                    } else {
                        x1 = x;
                    }

                    if (text) {
                        context.fillText(text, x1+2, t);
                    }


                    context.moveTo(x1, y);
                    context.lineTo(x1, y - l);

                    x += _tickStyle.space;
                    curTick++;
                }

                context.moveTo(rect.x, y - 0.5);
                context.lineTo(rect.x + rect.width, y - 0.5);

                context.strokeStyle = TICK_COLOR;
                context.stroke();

                context.restore()



                if (_media.paused) {
                    _scrubber.update();
                }
            }

            this.update = function () {
                drawTicks();
            };

            this.ready = function () {
                _canvas.addEventListener("mousedown", _scrubber.onMouseDown);
                _scrubber.ready();
            };

            this.changeFrameRate = function (rate) {
                var last = _this._zoomList.length - 1;
                var f = _this._zoomList[_this._zoomList.length-1];
                f.tickUnit = 1000 / rate;
                f.interval = rate;
                if (last == _zoom) {
                    _this.update();

                    _this.dispatchEvent("zoomchanged");
                    app.dispatchEvent("zoomchanged");
                }
            }

            _tracksContainer.element.addEventListener("scroll", drawTicks);

            drawTicks();

            Object.defineProperties(this, {
                element: {
                    enumerable: true,
                    get: function () {
                        return _element;
                    }
                }
            });
        }

    });

    return Timeline;


});

/*
 * 工具栏
 */
h5.define('templates/H5ToolbarLayout', [], function () {
    return '<div class="status-container" dir="ltr">\
    <div style="border-top:1px #000 solid; width:100%; position: absolute; top:-2px; height:1px;"></div>\
    <div class="status-inner-container" dir="ltr">\
      <div class="time-wrapper" dir="ltr">\
        <div class="time-container" dir="ltr">\
          <span class="current-time" dir="ltr">0:00</span>\
        </div>\
      </div>\
      <div class="toolbar-wrapper" >\
        <div class="toobar-container">\
            \
        </div>\
      </div>\
      <div class="va-wrapper">\
        <div class="relative">\
            <div class="wrapper">\
                <canvas class="audio-visual" ></canvas>\
            <div>\
        </div>\
      </div>\
  </div>';

    //<div class="mute-button-container" dir="ltr">\
    //    <div class="status-button" title="Toggle volume on/off" dir="ltr">\
    //      <span class="icon icon-white icon-only icon-volume-down" dir="ltr"></span>\
    //    </div>\
    //  </div>\
    //  <div class="play-button-container" dir="ltr">\
    //    <div class="btn btn-green status-button" title="播放媒体" dir="ltr">\
    //      <span class="fa fa-play-circle" dir="ltr"></span>\
    //    </div>\
    //  </div>\
    //  <div class="button-container stop-button-container" dir="ltr">\
    //    <div class="btn btn-green status-button" title="停止媒体" dir="ltr">\
    //      <span class="fa fa-stop" dir="ltr"></span>\
    //    </div>\
    //  </div>\
    //  <div class="button-container backward-button-container" dir="ltr">\
    //    <div class="btn btn-green status-button" title="媒体快退" dir="ltr">\
    //      <span class="fa fa-backward" dir="ltr"></span>\
    //    </div>\
    //  </div>\
    //  <div class="button-container forward-button-container" dir="ltr">\
    //    <div class="btn btn-green status-button" title="媒体快进" dir="ltr">\
    //      <span class="fa fa-forward" dir="ltr"></span>\
    //    </div>\
    //  </div>\
    //  <div class="button-container arrows-alt-button-container" dir="ltr">\
    //    <div class="btn btn-green status-button" title="媒体全屏播放" dir="ltr">\
    //      <span class="fa fa-arrows-alt" dir="ltr"></span>\
    //    </div>\
    //  </div>\
    //</div>\

    //<button class="btn btn-light add-track" title="添加图层" dir="ltr">添加轨</button>\
    //<div class="status-side left" dir="ltr"></div>\
    //<div class="status-side right" dir="ltr"></div>\
});
h5.define('util/Keys', [], function () {

    return {

        DELETE: 8,
        TAB: 9,
        ENTER: 13,

        ESCAPE: 27,

        SPACE: 32,

        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,

        0: 48,
        1: 49,
        2: 50,
        3: 51,
        4: 52,
        5: 53,
        6: 54,
        7: 55,
        8: 56,
        9: 57,

        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,

        EQUALS: 187,
        COMMA: 188,
        MINUS: 189

    };

});
h5.define('timeline/H5AudioVisualize', ["jquery", "util/Object", "util/util"],
  function ($, Obj, util) {


      var H5AudioVisualize = Obj.extend({
          init: function (element, options) {

              var audioContext = window.AudioContext || window.webkitAudioContext;

              var _cache = {};

              this.clear = function () {
                  _cache = {};
              };

              this.connect = function (ele, trackId) {
                  if (!audioContext) {
                      return;
                  }



                  if (lastSource) {
                      lastSource.disconnect();
                  }

                  var s = null;
                  var src = ele.src;
                  if (_cache[src]) {
                      s = _cache[src];
                  } else {
                      s = audioCtx.createMediaElementSource(ele);
                      _cache[src] = s;

                  }

                  s.connect(analyser);
                  lastSource = s;

              };



              if (!audioContext) {
                  return;
              }



              var audioCtx = new audioContext(),
                  canvas = element,
                  lastSource = null;




              var analyser = audioCtx.createAnalyser();
              analyser.minDecibels = -90;
              analyser.maxDecibels = -10;
              analyser.smoothingTimeConstant = 0.85;
              analyser.connect(audioCtx.destination);




              //var distortion = audioCtx.createWaveShaper();
              //var gainNode = audioCtx.createGain();
              //var biquadFilter = audioCtx.createBiquadFilter();
              //var convolver = audioCtx.createConvolver();

              var canvasCtx = canvas.getContext("2d");


              var drawVisual;



              function visualize() {
                  if (!analyser) {
                      return;
                  }

                  WIDTH = canvas.width;
                  HEIGHT = canvas.height;

                  analyser.fftSize = 256;
                  var bufferLength = analyser.frequencyBinCount;
               //   console.log(bufferLength);
                  var dataArray = new Uint8Array(bufferLength);

                  canvasCtx.clearRect(0, 0, WIDTH, HEIGHT);

                  function draw() {
                      drawVisual = requestAnimationFrame(draw);

                      analyser.getByteFrequencyData(dataArray);

                      canvasCtx.fillStyle = '#fff';
                      canvasCtx.fillRect(0, 0, WIDTH, HEIGHT);

                      var barWidth = (WIDTH / bufferLength) * 2.5;
                      var barHeight;
                      var x = 0;

                      var v = 0;
                      for (var i = 0; i < bufferLength; i++) {


                          barHeight = dataArray[i];
                          var c = (255 - barHeight - 100);
                          canvasCtx.fillStyle = '#4391e6';
                          canvasCtx.fillRect(x, HEIGHT - barHeight / 1.5, barWidth, barHeight / 1.5);

                          x += barWidth + 1;
                      }
                      barHeight = v / bufferLength;

                      canvasCtx.fillStyle = '#4391e6';
                      canvasCtx.fillRect(x, HEIGHT - barHeight / 2, barWidth, barHeight / 2);


                  };

                  draw();


              }

              visualize();

          }
      });

      return H5AudioVisualize;
  });
/*
 * 管理播放按钮状态及当前时间、时长等
 */
h5.define('timeline/H5Toolbar', ["templates/H5ToolbarLayout", "util/util",
    "util/Time", "util/Keys", "timeline/H5AudioVisualize"], function (H5_TOOLBAR_LAYOUT, util, Time, Keys, H5AudioVisualize) {

    function Button(parentNode, className, onClick) {
        var _container = parentNode.querySelector(className),
            _button = _container.querySelector(".status-button"),
            _state = true;

        function update() {
            if (_state) {
                _button.removeAttribute("data-state");
            }
            else {
                _button.setAttribute("data-state", true);
            }
        }
        _button.addEventListener("mousedown", function (e) {
            // Disable text selection in chrome while clicking.
            e.preventDefault();
        });
        _button.addEventListener("click", onClick);

        Object.defineProperties(this, {
            state: {
                enumerable: true,
                get: function () {
                    return _state;
                },
                set: function (val) {
                    _state = val;
                    update();
                }
            }
        });
    }

    function Time(parentNode, media) {
        var _container = parentNode.querySelector(".time-container"),
            _timeBox = _container.querySelector(".current-time"),
           // _durationInput = _container.querySelector(".duration-input"),
            _media = media,
            _oldValue = 0;

        function setTime(time, setCurrentTime) {
            if (typeof (time) === "string" || !isNaN(time)) {
                //if (setCurrentTime) {
                //    try {
                //        time = util.toSeconds(time);
                //        _media.currentTime = time;
                //    }
                //    catch (e) {
                //        time = _media.currentTime;
                //    }
                //}

                _timeBox.innerHTML = util.toSmpteString(time * 1000);
            }
            else {
                _timeBox.innerHTML = _oldValue;
            }
        }

        _media.addEventListener("mediatimeupdate", function () {
            setTime(_media.currentTime, false);
        });

       // _media.addEventListener("durationChanged", function () {
           // _durationInput.value = util.toTimecode(_media.duration, 0);
       // });

        //function updateDuration(val) {
        //    var seconds = util.toSeconds(val);

        //    if (seconds <= 0) {
        //        seconds = _media.duration;
        //    }

        //    _durationInput.classList.remove("input-active");
        //    _media.url = "#empty=," + seconds;
        //    _durationInput.value = util.toTimecode(seconds, 0);
        //    _durationInput.addEventListener("click", onDurationClick);
        //    _durationInput.removeEventListener("blur", onBlur, false);
        //    _durationInput.removeEventListener("keydown", onKeyDown, false);
        //    _durationInput.blur();
        //}

        //function onBlur(e) {
        //    e.preventDefault();

        //    updateDuration(_durationInput.value);
        //}

        //function onKeyDown(e) {
        //    if (e.keyCode === Keys.ENTER) {
        //        updateDuration(_durationInput.value);
        //    }
        //}

        //function onDurationClick() {
        //    _durationInput.removeEventListener("click", onDurationClick, false);
        //    _durationInput.classList.add("input-active");

        //    _durationInput.addEventListener("blur", onBlur);

        //    _durationInput.addEventListener("keydown", onKeyDown);
        //}

      //  _durationInput.addEventListener("click", onDurationClick);

        setTime(0, false);

    }

    return function H5Toolbar(app,media, statusArea) {
        var _toolbarElement = $(H5_TOOLBAR_LAYOUT)[0]; //工具栏
        statusArea.querySelector(".timebar-container").appendChild(_toolbarElement);



        var _media = media,
            //_muteButton,
           // _buttonContainer = _toolbarElement.querySelector(".status-inner-container"),
            _toolbarContainer = _toolbarElement.querySelector(".toobar-container"),
            _playButton,
            _time,
            _audioVisualElement = _toolbarElement.querySelector(".audio-visual");

        var _audioVisual = new H5AudioVisualize(_audioVisualElement);
        app.audioVisual = _audioVisual;

        _toolbarElement.className = "status-container";

        _time = new Time(statusArea, _media);

        this.createToolbarButton = function (id,  afterSelector) {
            var _buttonElement = $("<div/>").addClass("btn-wrapper")[0];
            if (id) _buttonElement.setAttribute("id", id);
            // _buttonContainer.appendChild(_buttonElement[0]);
            var b = false;
            if (afterSelector) {
                var afterElement = _toolbarContainer.querySelector(afterSelector);
                if (afterElement) {
                    _toolbarContainer.insertBefore(_buttonElement, afterElement);
                    b = true;
                }
            }
            if (!b) {
                _toolbarContainer.appendChild(_buttonElement);
            }
            return _buttonElement;
        }
        app.editorPlugin._service.createToolbarButton = this.createToolbarButton;


        ////播放按钮
        //_playButton = new Button(statusArea, ".play-button-container", function () {
        //    if (_media.paused) {
        //        _media.paused = false;
        //    } else {
        //        _media.paused = true;
        //    }
        //});
        //_playButton.state = true;
        //_media.addEventListener("mediaended", function () {
        //    _playButton.state = true;
        //});

        //_media.addEventListener("mediaplay", function () {
        //    _playButton.state = false;
        //});

        //_media.addEventListener("mediapause", function () {
        //    _playButton.state = true;
        //});


        //_muteButton = new Button(statusArea, ".mute-button-container", function () {
        //    _media.muted = !_media.muted;
        //});
        //_media.addEventListener("mediamuted", function () {
        //    _muteButton.state = false;
        //});

        //_media.addEventListener("mediaunmuted", function () {
        //    _muteButton.state = true;
        //});

        //_media.addEventListener("mediavolumechange", function () {
        //    _muteButton.state = !_media.muted;
        //});
    };

});
/*
 * 编辑器左侧标题栏布局
 */
h5.define('templates/H5TrackHandlesLayout', [], function () {
    return '<div class="track-handle">\
    <span class="content-container">\
        <span class="title"></span>\
    </span>\
    <span class="lock off" title="' + lang[_curLang].clickOrDblclick + '"></span>\
</div>';

//    '<div class="track-handle">\
//    <span class="content-container">\
//        <span class="title"></span>\
//        <i class="icon icon-pencil"></i>\
//        <span class="track-handle-icon"></span>\
//        <div class="menu">\
//            <div class="delete"></div>\
//        </div>\
//    </span>\
//    <input type="text" class="title-input hidden"></input>\
//</div>';
});
/*
 * 左侧轨道标题
 */
h5.define('timeline/H5TrackHandles', ["util/H5DragDrop", "util/Keys", "templates/H5TrackHandlesLayout"],
  function (H5DragDrop, KeysUtils, H5_TRACKHANDLES_LAYOUT) {

      return function (app, media, mediaInstanceRootElement, tracksContainer) {

          var _media = media,
              _container = mediaInstanceRootElement.querySelector(".track-title-container"),
              _listElement = _container.querySelector(".handle-list"),
              _tracks = {},
              _menus = [],
              _this = this,
              _draggingHandleIndex,
              _draggingHandleId;

          function sortHandles() {
              if (app.currentMedia) {
                  var tracks = app.currentMedia.orderedTracks,
                      trackHandle;
                  for (var i = 0, l = tracks.length; i < l; ++i) {
                      trackHandle = _tracks[tracks[i].id];
                      if (trackHandle) {
                          _listElement.appendChild(trackHandle.element);
                      }
                  }
              }
          }

          //H5DragDrop.addEventListener("sortstarted", function onSortStarted(e) {
          //    var originalEvent = e.data,
          //        orderedTracks = app.currentMedia.orderedTracks,
          //        id = originalEvent.target.getAttribute("data-track-id");

          //    for (var i = 0; i < orderedTracks.length; i++) {
          //        if (orderedTracks[i].id === id) {
          //            _draggingHandleIndex = i;
          //            _draggingHandleId = id;
          //        }
          //    }

          //});

          //var _sortable = H5DragDrop.sortable(_listElement, {
          //    change: function (elements) {
          //        var newIndex, id,
          //            orderedTracks = app.media.orderedTracks,
          //            track,
          //            indexCache;

          //        for (var i = 0, l = elements.length; i < l; ++i) {
          //            id = elements[i].getAttribute("data-track-id");
          //            if (id === _draggingHandleId) {
          //                newIndex = i;
          //                break;
          //            }
          //        }

          //        track = orderedTracks[_draggingHandleIndex];
          //        orderedTracks.splice(_draggingHandleIndex, 1);
          //        orderedTracks.splice(newIndex, 0, track);

          //        indexCache = newIndex;
          //        if (newIndex < _draggingHandleIndex) {
          //            var temp = _draggingHandleIndex;

          //            _draggingHandleIndex = newIndex;
          //            newIndex = temp;
          //        }

          //        app.media.sortTracks(_draggingHandleIndex, newIndex);

          //        _draggingHandleIndex = indexCache;
          //    }
          //});

          _media.addEventListener("trackorderchanged", function (e) {
              var tracks = e.data;
              for (var i = 0, l = tracks.length; i < l; i++) {
                  var track = tracks[i],
                      element = _tracks[track.id].element;
                 // element.querySelector("span.title").textContent = track.name;
                  element.querySelector("span.title").title = track.name;
              }
          });

          function onTrackAdded(e) {
              var track = e.data,
                  trackId = track.id,
                  trackDiv = $(H5_TRACKHANDLES_LAYOUT)[0],
                  //menuDiv = trackDiv.querySelector(".menu"),
                  titleElement = trackDiv.querySelector(".title"),
                  lockDiv = trackDiv.querySelector(".lock"),
                  contentContainerElement = trackDiv.querySelector(".content-container");
                  //titleInputElement = trackDiv.querySelector(".title-input"),
                  //editIconElement = trackDiv.querySelector(".icon-pencil"),
                  //deleteButton = menuDiv.querySelector(".delete");

              trackDiv.classList.add(track.trackType.toLowerCase());

              lockDiv.addEventListener("click", function () {
                  track.isLock = !track.isLock;
              });

              lockDiv.addEventListener("dblclick", function () {
                  for (var i = 0; i < _media.tracks.length; i++) {
                      var t = _media.tracks[i];
                      if (t == track) {
                          t.isLock = false;
                      } else {
                          t.isLock = true;
                      }
                  }
              });


              //function startTitleEdit() {
              //    titleInputElement.value = track.name;
              //    contentContainerElement.classList.add("hidden");
              //    titleInputElement.classList.remove("hidden");
              //    titleInputElement.focus();

              //    titleElement.removeEventListener("click", startTitleEdit, false);
              //    editIconElement.removeEventListener("click", startTitleEdit, false);

              //    titleInputElement.addEventListener("change", finishTitleEdit);
              //    titleInputElement.addEventListener("blur", finishTitleEdit);
              //    titleInputElement.select();
              //}

              //function onKeypress(e) {
              //    if (e.keyCode === KeysUtils.ENTER) {
              //        titleInputElement.blur();
              //    }
              //}

              //titleInputElement.addEventListener("keypress", onKeypress);
              //trackDiv.addEventListener("click", function () {
              //    if (track.selectedTrack) {
              //        track.updateSelectedTrack(false);
              //    } else {
              //        track.updateSelectedTrack(true);
              //    }
              //});

              track.addEventListener("tracknamechanged", function () {
                  //titleElement.textContent = track.name;
                  titleElement.title = track.name;
              });

              track.addEventListener("lockchanged", function () {
                  lockDiv.classList.remove("on");
                  lockDiv.classList.remove("off");
                  if (track.isLock) {
                      lockDiv.classList.add("on");
                  } else {
                      lockDiv.classList.add("off");
                  }
              });

              //function finishTitleEdit() {
              //    track.name = titleInputElement.value;
              //    contentContainerElement.classList.remove("butter-hidden");
              //    titleInputElement.classList.add("butter-hidden");

              //    titleElement.addEventListener("click", startTitleEdit);
              //    editIconElement.addEventListener("click", startTitleEdit);
              //    titleInputElement.removeEventListener("change", finishTitleEdit, false);
              //    titleInputElement.removeEventListener("blur", finishTitleEdit, false);
              //    titleInputElement.value = "";
              //}

              //titleInputElement.value = "";
              //titleElement.addEventListener("click", startTitleEdit);
              //editIconElement.addEventListener("click", startTitleEdit);

              //deleteButton.addEventListener("click", function () {
              //    media.removeTrack(track);
              //    //var dialog = Dialog.spawn("delete-track", {
              //    //    data: track.name,
              //    //    events: {
              //    //        submit: function (e) {
              //    //            if (e.data) {
              //    //                media.removeTrack(track);
              //    //            } //if
              //    //            dialog.close();
              //    //        },
              //    //        cancel: function () {
              //    //            dialog.close();
              //    //        }
              //    //    }
              //    //});
              //    //dialog.open();
              //});

              //_menus.push(menuDiv);

              trackDiv.setAttribute("data-track-id", trackId);
              //menuDiv.setAttribute("data-track-id", trackId);
              //menuDiv.querySelector(".delete").setAttribute("data-track-id", trackId);
              //trackDiv.querySelector("span.track-handle-icon").setAttribute("data-track-id", trackId);
              trackDiv.querySelector("span.title").setAttribute("data-track-id", trackId);
              //trackDiv.querySelector("span.title").appendChild(document.createTextNode(track.name));

              //_sortable.addItem(trackId, {
              //    item: trackDiv,
              //    handle: trackDiv.querySelector("span.track-handle-icon")
              //});

              _listElement.appendChild(trackDiv);

              _tracks[trackId] = {
                  id: trackId,
                  track: track,
                  element: trackDiv,
                  //menu: menuDiv
              };

              sortHandles();
          }

          var existingTracks = _media.tracks;
          for (var i = 0; i < existingTracks.length; ++i) {
              onTrackAdded({
                  data: existingTracks[i]
              });
          }

          _media.addEventListener("trackadded", onTrackAdded);

          _media.addEventListener("trackremoved", function (e) {
              var trackId = e.data.id;
              _listElement.removeChild(_tracks[trackId].element);
            //  _sortable.removeItem(trackId);
             // _menus.splice(_menus.indexOf(_tracks[trackId].menu), 1);
              delete _tracks[trackId];
          });

          tracksContainer.element.addEventListener("scroll", function () {
              _container.scrollTop = tracksContainer.element.scrollTop;
          });

          _container.addEventListener("mousewheel", function (e) {
              if (e.wheelDeltaY) {
                  tracksContainer.element.scrollTop -= e.wheelDeltaY;
                  e.preventDefault();
              }
          });

          // For Firefox
          _container.addEventListener("DOMMouseScroll", function (e) {
              if (e.axis === e.VERTICAL_AXIS && !e.shiftKey) {
                  tracksContainer.element.scrollTop += e.detail * 2;
                  e.preventDefault();
              }
          });

          this.update = function () {
              _container.scrollTop = tracksContainer.element.scrollTop;
          };

          _this.update();

          Object.defineProperties(this, {
              element: {
                  enumerable: true,
                  get: function () {
                      return _container;
                  }
              }
          });

      };

  });

h5.define('templates/H5ZoombarLayout', [], function () {
    return '<div class="timeline-zoom" dir="ltr">\n  ' +
            '<div class="slider-container" dir="ltr">\n'+
                '<span class="tick"></span>\n'+
                '<span class="tick"></span>\n ' +
                '<span class="tick"></span>\n'+
                '<span class="tick"></span>\n' +
                '<span class="tick"></span>\n' +
                '<span class="tick"></span>\n' +
                '<div class="zoom-slider" dir="ltr">\n' +
                    '<div class="zoom-handle" dir="ltr"></div>\n'+
                '</div>\n' +
            '</div>\n'+
            '<div class="inner-container" dir="ltr">\n'+
                '<div class="scrollbar-visuals" dir="ltr"></div>\n' +
                    '<span class="scrollbar-viewport" dir="ltr">\n' +
                        '<span class="scrollbar-border"></span>\n'+
                        '<span class="scrollbar-handle left">\n' +
                            '<span class="scrollbar-arrow"></span>\n' +
                        '</span>\n' +
                        '<span class="scrollbar-handle right">\n' +
                            '<span class="scrollbar-arrow"></span>\n' +
                        '</span>\n' +
                    '</span>\n' +
                    '<span class="scrollbar-scrubber" dir="ltr"></span>\n'+
                '</div>\n' +
            '</div>\n';
});
h5.define('util/H5Zoombar', ["jquery", "templates/H5ZoombarLayout"],
  function ($, H5ZoombarLayout) {

      var TRACK_PADDING = 1,          // This padding is pixels between track event visuals.
          MIN_WIDTH = 5,              // The smallest the viewport can get.
          ARROW_MIN_WIDTH = 50,       // The arrows have to change position at this point.
          ARROW_MIN_WIDTH_CLASS = "super-scrollbar-small";

      return function (outerElement, innerElement, boundsChangedCallback, media) {
          var _outer = $(H5ZoombarLayout),
              _inner = $(".inner-container", _outer)[0],
              _duration,
              _media = media,
              // viewport is the draggable, resizable, representation of the viewable track container.
              _viewPort = $(".scrollbar-viewport", _inner)[0],
              _leftHandle = $(".scrollbar-handle.left", _viewPort)[0],
              _rightHandle = $(".scrollbar-handle.right", _viewPort)[0],
              // visuals is the container for the visual representations for track events.
              _visuals = $(".scrollbar-visuals", _inner)[0],
              _scrubber = $(".scrollbar-scrubber", _inner)[0],
              _zoomSlider = $(".zoom-slider", _outer)[0],
              _zoomSliderContainer = $(".slider-container", _outer)[0],
              _zoomSliderHandle = $(".zoom-handle", _outer)[0],
              _butterEditorOffsetLeft,
              _html = document.querySelector("html"),
              _leftOffset = 0,
              _rightOffset = 0,
              _viewLeft = 0,
              _viewRight = 0,
              _trackEventVisuals = {},
              _boundsChangedCallback = function (right, width) {
                  if (width !== -1) {
                      _zoomSliderHandle.style.right = width * 100 + "%";
                  }
                  boundsChangedCallback(right, width);
              },
              _this = this;

          var checkMinSize, onViewMouseUp, onViewMouseDown, onViewMouseMove,
              onLeftMouseUp, onLeftMouseDown, onLeftMouseMove,
              onRightMouseUp, onRightMouseDown, onRightMouseMove,
              onElementMouseUp, onElementMouseDown, onElementMouseMove,
              updateView;

          checkMinSize = function () {
              if (_viewPort.getBoundingClientRect().width < ARROW_MIN_WIDTH) {
                  _inner.classList.add(ARROW_MIN_WIDTH_CLASS);
              } else {
                  _inner.classList.remove(ARROW_MIN_WIDTH_CLASS);
              }
          };

          _this.update = function () {
              checkMinSize();
          };

          onElementMouseUp = function (e) {
              e.stopPropagation();
              window.removeEventListener("mouseup", onElementMouseUp, false);
              window.removeEventListener("mousemove", onElementMouseMove, false);
          };

          onViewMouseUp = function (e) {
              e.stopPropagation();
              outerElement.addEventListener("scroll", updateView);
              window.removeEventListener("mouseup", onViewMouseUp, false);
              window.removeEventListener("mousemove", onViewMouseMove, false);
          };

          onLeftMouseUp = function (e) {
              e.stopPropagation();
              outerElement.addEventListener("scroll", updateView);
              window.removeEventListener("mouseup", onLeftMouseUp, false);
              window.removeEventListener("mousemove", onLeftMouseMove, false);
          };

          onRightMouseUp = function (e) {
              e.stopPropagation();
              outerElement.addEventListener("scroll", updateView);
              window.removeEventListener("mouseup", onRightMouseUp, false);
              window.removeEventListener("mousemove", onRightMouseMove, false);
          };

          onElementMouseDown = function (e) {
              // Stop text selection in chrome.
              e.preventDefault();
              e.stopPropagation();
              media.currentTime = ((e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft) / _inner.clientWidth * _duration;
              window.addEventListener("mouseup", onElementMouseUp);
              window.addEventListener("mousemove", onElementMouseMove);
          };

          onViewMouseDown = function (e) {
              e.stopPropagation();
              // Stop text selection in chrome.
              e.preventDefault();
              outerElement.off("scroll", updateView, false);
              _leftOffset = (e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft - _viewPort.offsetLeft;
              _rightOffset = _viewPort.offsetWidth - _leftOffset;
              _media.pause();  // pause the media here to diffuse confusion with scrolling & playing
              window.addEventListener("mouseup", onViewMouseUp);
              window.addEventListener("mousemove", onViewMouseMove);
          };

          onLeftMouseDown = function (e) {
              // Stop text selection in chrome.
              e.preventDefault();
              e.stopPropagation();
              _media.pause();  // pause the media here to diffuse confusion with scrolling & playing
              outerElement.off("scroll", updateView, false);
              window.addEventListener("mouseup", onLeftMouseUp);
              window.addEventListener("mousemove", onLeftMouseMove);
          };

          onRightMouseDown = function (e) {
              // Stop text selection in chrome.
              e.preventDefault();
              e.stopPropagation();
              _media.pause();  // pause the media here to diffuse confusion with scrolling & playing
              outerElement.off("scroll", updateView, false);
              window.addEventListener("mouseup", onRightMouseUp);
              window.addEventListener("mousemove", onRightMouseMove);
          };

          onElementMouseMove = function (e) {
              e.preventDefault();
              e.stopPropagation();
              media.currentTime = ((e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft) / _inner.clientWidth * _duration;
          };

          onViewMouseMove = function (e) {
              e.preventDefault();
              e.stopPropagation();
              var thisLeft = ((e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft - _leftOffset) / _inner.clientWidth,
                  thisRight = (_inner.clientWidth - ((e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft + _rightOffset)) / _inner.clientWidth;

              if (thisLeft < 0) {
                  thisLeft = 0;
                  thisRight = (_inner.clientWidth - _viewPort.offsetWidth) / _inner.clientWidth;
              } else if (thisRight < 0) {
                  thisRight = 0;
                  thisLeft = _viewPort.offsetLeft / _inner.clientWidth;
              }

              _viewLeft = thisLeft;
              _viewRight = thisRight;

              _viewPort.style.left = _viewLeft * 100 + "%";
              _viewPort.style.right = _viewRight * 100 + "%";
              _boundsChangedCallback(_viewLeft, -1);
          };

          onLeftMouseMove = function (e) {
              e.preventDefault();
              e.stopPropagation();

              // position is from the left of the container, to the left of the viewport.
              var position = (e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft,
                  rightBound = (_viewLeft * _inner.clientWidth) + _viewPort.clientWidth;

              // make sure we never go out of bounds.
              if (position < 0) {
                  position = 0;
              }
              // make sure left never goes over right.
              if (position + MIN_WIDTH > rightBound) {
                  position = rightBound - MIN_WIDTH;
              }
              _viewLeft = position / _inner.clientWidth;
              _viewPort.style.left = _viewLeft * 100 + "%";
              _boundsChangedCallback(_viewLeft, _viewPort.offsetWidth / _inner.clientWidth);
          };

          onRightMouseMove = function (e) {
              e.preventDefault();
              e.stopPropagation();

              // position is from the right of the container, to the right of the viewport.
              var position = _inner.clientWidth - ((e.clientX + _butterEditorOffsetLeft) - _inner.offsetLeft),
                  leftBound = (_viewRight * _inner.clientWidth) + _viewPort.clientWidth;

              // make sure we never go out of bounds.
              if (position < 0) {
                  position = 0;
              }
              // make sure right never goes over left.
              if (position + MIN_WIDTH > leftBound) {
                  position = leftBound - MIN_WIDTH;
              }
              _viewRight = position / _inner.clientWidth;
              _viewPort.style.right = _viewRight * 100 + "%";
              _boundsChangedCallback(_viewLeft, _viewPort.offsetWidth / _inner.clientWidth);
          };

          updateView = function () {
              _viewLeft = outerElement.scrollLeft / innerElement.offsetWidth;
              _viewPort.style.left = _viewLeft * 100 + "%";
              _viewRight = 1 - (outerElement.scrollLeft + outerElement.clientWidth) / innerElement.offsetWidth;
              _viewPort.style.right = _viewRight * 100 + "%";
          };

          _inner.addEventListener("mousedown", onElementMouseDown);
          outerElement.addEventListener("scroll", updateView);
          _viewPort.addEventListener("mousedown", onViewMouseDown);
          _leftHandle.addEventListener("mousedown", onLeftMouseDown);
          _rightHandle.addEventListener("mousedown", onRightMouseDown);

          /**
           * scaleViewPort
           *
           * Scales the viewport by a percentage value (0 - 1). The viewport grows or shrinks
           * to cover less or more area, and calls _boundsChangedCallback with the new (left, width) combination
           * as percentage values (0 - 1). This action has the consequence of zooming the
           * track container viewport in or out.
           *
           * A left and right position are calculated by moving them a set amount from their current
           * positions around the mid-point of the viewport. A new width value is also calculated
           * to provide _boundsChangedCallback with the necessary values: left & width.
           *
           * If the growth or shrink rate results in less than a pixel on both ends, nothing happens.
           *
           * @param {Number} scale: Percentage (0 - 1) to grow or shrink the viewport
           */
          function scaleViewPort(scale) {

              var viewWidth = _viewPort.offsetWidth,
                  viewLeft = _viewPort.offsetLeft,
                  rectWidth = _inner.clientWidth,
                  scrubberLeft = _scrubber.offsetLeft,
                  oldScale = viewWidth / rectWidth,
                  scaleDiff = oldScale - scale,
                  halfScale = scaleDiff * 0.5,
                  pixelGrowth = Math.abs(scaleDiff * rectWidth),
                  leftScale = halfScale,
                  rightScale = halfScale,
                  leftSide = scrubberLeft - viewLeft,
                  rightSide = viewWidth - leftSide;

              // make sure our growth is at least a pixel on either side.
              if (pixelGrowth < 1) {
                  return;
              }

              // The scrubber is in the viewport
              if (scrubberLeft >= viewLeft && scrubberLeft <= viewLeft + viewWidth) {

                  // If we're zooming in, we're already modifying the large side.
                  // However, if we're zooming out, instead modify the small side
                  if (scaleDiff < 0) {
                      rightSide = scrubberLeft - viewLeft;
                      leftSide = viewWidth - rightSide;
                  }

                  // The scrubber is close to the middle, modify both sides smoothly.
                  if (Math.abs(leftSide - rightSide) <= pixelGrowth) {
                      leftScale = scaleDiff * (leftSide / viewWidth);
                      rightScale = scaleDiff * (rightSide / viewWidth);
                  } else {

                      if (leftSide > rightSide) {
                          leftScale += rightScale;
                          rightScale = 0;
                      } else if (rightSide > leftSide) {
                          rightScale += leftScale;
                          leftScale = 0;
                      }
                  }
              }

              _viewRight += rightScale;
              _viewLeft += leftScale;

              if (_viewRight < 0) {
                  _viewLeft += _viewRight;
                  _viewRight = 0;
              }
              if (_viewLeft < 0) {
                  _viewRight += _viewLeft;
                  _viewLeft = 0;
              }

              _viewPort.style.right = _viewRight * 100 + "%";
              _viewPort.style.left = _viewLeft * 100 + "%";
              _boundsChangedCallback(_viewLeft, scale);
          }

          function zoomSliderMouseUp() {
              outerElement.addEventListener("scroll", updateView);
              window.removeEventListener("mouseup", zoomSliderMouseUp, false);
              window.removeEventListener("mousemove", zoomSliderMouseMove, false);
              _zoomSliderContainer.addEventListener("mousedown", zoomSliderContainerMouseDown);
              _zoomSliderHandle.addEventListener("mousedown", zoomSliderHanldeMouseDown);
          }

          function zoomSliderMouseMove(e) {
              e.preventDefault();
              updateZoomSlider(e);
          }

          function updateZoomSlider(e) {
              var position = _zoomSlider.offsetWidth - ((e.clientX + _butterEditorOffsetLeft) - (_zoomSliderContainer.offsetLeft + (_zoomSliderHandle.offsetWidth / 2))),
                  scale;

              if (position < 0) {
                  position = 0;
              } else if (position > _zoomSlider.offsetWidth) {
                  position = _zoomSlider.offsetWidth;
              }
              scale = position / _zoomSlider.offsetWidth;
              if (scale * _inner.clientWidth < MIN_WIDTH) {
                  scale = MIN_WIDTH / _inner.clientWidth;
              }
              scaleViewPort(scale);
              _zoomSliderHandle.style.right = position / _zoomSlider.offsetWidth * 100 + "%";
          }

          function zoomSliderContainerMouseDown(e) {
              // Stop text selection in chrome.
              e.preventDefault();
              outerElement.off("scroll", updateView, false);
              updateZoomSlider(e);
              _zoomSliderHandle.off("mousedown", zoomSliderHanldeMouseDown, false);
              _zoomSliderContainer.off("mousedown", zoomSliderContainerMouseDown, false);
              window.addEventListener("mousemove", zoomSliderMouseMove);
              window.addEventListener("mouseup", zoomSliderMouseUp);
          }

          function zoomSliderHanldeMouseDown(e) {
              // Stop text selection in chrome.
              e.preventDefault();
              outerElement.off("scroll", updateView, false);
              _zoomSliderHandle.off("mousedown", zoomSliderHanldeMouseDown, false);
              _zoomSliderContainer.off("mousedown", zoomSliderContainerMouseDown, false);
              window.addEventListener("mousemove", zoomSliderMouseMove);
              window.addEventListener("mouseup", zoomSliderMouseUp);
          }

          _zoomSliderContainer.addEventListener("mousedown", zoomSliderContainerMouseDown);
          _zoomSliderHandle.addEventListener("mousedown", zoomSliderHanldeMouseDown);

          function updateTrackEventVisual(trackEvent, order) {
              var trackEventVisual = document.createElement("div"),
                  style = trackEvent.view.element.style;
              trackEventVisual.classList.add("butter-super-scrollbar-trackevent");
              _trackEventVisuals[trackEvent.id] = trackEventVisual;
              _visuals.appendChild(trackEventVisual);
              trackEventVisual.style.width = style.width;
              trackEventVisual.style.left = style.left;
              trackEventVisual.style.top = (trackEventVisual.offsetHeight + TRACK_PADDING) * order + "px";
          }

          _media.addEventListener("trackeventremoved", function (e) {
              var trackEvent = _trackEventVisuals[e.data.id];
              if (trackEvent) {
                  delete _trackEventVisuals[e.data.id];
                  trackEvent.parentNode.removeChild(trackEvent);
              }
          });

          _media.addEventListener("trackeventupdated", function (e) {
              var trackEvent = _trackEventVisuals[e.data.id],
                  style = e.data.view.element.style;
              if (trackEvent) {
                  trackEvent.style.width = style.width;
                  trackEvent.style.left = style.left;
              }
          });

          _media.addEventListener("trackorderchanged", function (e) {
              var data = e.data, i = 0,
                  j, jl, trackEvent, track,
                  il = data.length;
              for (; i < il; i++) {
                  track = data[i];
                  for (j = 0, jl = track.trackEvents.length; j < jl; j++) {
                      trackEvent = _trackEventVisuals[track.trackEvents[j].id];
                      if (trackEvent) {
                          trackEvent.style.top = (trackEvent.offsetHeight + TRACK_PADDING) * track.order + "px";
                      }
                  }
              }
          });

          _media.addEventListener("mediatimeupdate", function (e) {
              _scrubber.style.left = e.data.currentTime / _duration * 100 + "%";
          });

          _this.initialize = function () {
              _butterEditorOffsetLeft = document.querySelector(".butter-editor-area").offsetLeft;
              _butterEditorOffsetLeft = _html.dir === "rtl" ? _butterEditorOffsetLeft : 0;
              var i, j, tl, tel,
                  trackEvents,
                  order,
                  track,
                  tracks = _media.tracks;
              for (i = 0, tl = tracks.length; i < tl; i++) {
                  track = tracks[i];
                  trackEvents = track.trackEvents;
                  order = track.order;
                  for (j = 0, tel = trackEvents.length; j < tel; j++) {
                      updateTrackEventVisual(trackEvents[j], order);
                  }
              }
              _media.listen("trackeventadded", function (e) {
                  updateTrackEventVisual(e.data, e.target.order);
              });
          };

          _media.addEventListener("mediaready", function (e) {
              _duration = e.target.duration;
              updateView();
              checkMinSize();
          });

          _this.resize = function () {
              _butterEditorOffsetLeft = document.querySelector(".butter-editor-area").offsetLeft;
              _butterEditorOffsetLeft = _html.dir === "rtl" ? _butterEditorOffsetLeft : 0;
              _this.update();
              _boundsChangedCallback(_viewPort.offsetLeft / _inner.clientWidth, _viewPort.offsetWidth / _inner.clientWidth);
          };

          Object.defineProperties(this, {
              element: {
                  enumerable: true,
                  get: function () {
                      return _outer;
                  }
              }
          });
      };
  });


/*
 * 编辑器轨道布局
 */
h5.define('templates/H5TracksLayout', [], function () {
    return '<div class="timeline fadable">\n' +
                '<div class="timeline-trackcontainer">\n' +
                    '<div class="track-title-container">\n' +
                        '<div class="handle-list"></div>\n' +
                     '</div>\n' +
                    '<div class="trackbar-container">\n' +
                        '<div class="wrapper">\n' +
                            '<div class="tracks-container">\n' +
                            '</div>\n' +
                        '</div>\n' +
                    '</div>\n' +
                '</div>\n' +
            '</div>';
});
/*
 * 编辑器时间线及状态栏布局
 */
h5.define('templates/H5TimebarLayout', [], function () {
    return '<div class="timebar-container" dir="ltr">\
  <div class="h5-logo">\
    <span class="h5-logo-title">MBH</span>\
  </div>\
  <div class="time-bar" dir="ltr">\
    <div class="canvas-container" dir="ltr">\
      <canvas dir="ltr"></canvas>\
    </div>\
    <div class="pos-container" dir="ltr">\
        <div class="pos-wrapper">\
          <div class="total-bar" dir="ltr"></div>\
          <div class="fill-bar" dir="ltr"></div>\
          <div class="h5tooltip time-tooltip" dir="ltr">00:00:00</div>\
            <div class="selection-box hidden">\
                <div class="box-back"></div>\
            </div>\
          <div class="pos-node" data-tooltip dir="ltr"></div>\
          <div class="pos-line" title="' + lang[_curLang].dragToChange + '" dir="ltr"></div>\
        </div>\
    </div>\
  </div>\
</div>';
    //<button class="btn btn-light add-track" title="添加图层" dir="ltr">添加轨</button>\
    //<div class="status-side left" dir="ltr"></div>\
    //<div class="status-side right" dir="ltr"></div>\
});
h5.define("timeline/ZoomControl", ["jquery", "util/util", "util/Object"],
     function ($, util, Obj) {
        var ZoomControl = Obj.extend({
        init: function (element, options) {
            this._super();

            this.options = options;
            this._slider = {};
            this.element = null;
            if (typeof element === "string") {
                this.element = document.getElementById(element);
            } else {
                this.element = element;
            }
            this.bk = null;

            this.createControl();

        },
        createControl: function () {
            var that = this,
               element = $(this.element),

               o = this.options;
            this._slider.vertical = o.vertical;
            if (typeof o.position === "undefined") {
                o.position = o.min;
            }

            this._createSlider();
            this._initPoints();
            this._placeMarker(o.position);

            // addTouchEvents(element[0]);
            element.children(".pre").on("click", function (e) {
                var v = that.value();
                that.value(v-1);
            });
            element.children('.next').on("click", function (e) {
                var v = that.value();
                that.value(v + 1);
            });

            this.bk.children('.marker').on('mousedown', function (e) {
                e.preventDefault();
                that._startMoveMarker(e);
            });

            this.bk.on('mousedown', function (e) {
                e.preventDefault();
                that._startMoveMarker(e);
            });
        },

        _startMoveMarker: function (e) {
            var element = $(this.element), o = this.options, that = this, hint = this.bk.children('.hint');

            $(document).mousemove(function (event) {
                that._movingMarker(event);
                if (!element.hasClass('permanent-hint')) {
                    hint.css('display', 'block');
                }
            });
            $(document).mouseup(function () {
                $(document).off('mousemove');
                $(document).off('mouseup');
                element.data('value', that.options.position);
                element.trigger('changed', that.options.position);
                //o.changed(that.options.position, element);
                if (!element.hasClass('permanent-hint')) {
                    hint.css('display', 'none');
                }
            });

            this._initPoints();

            this._movingMarker(e)
        },

        _movingMarker: function (event) {
            var cursorPos,
                percents,
                valuePix,

                vertical = this._slider.vertical,
                sliderOffset = this._slider.offset,
                sliderStart = this._slider.start,
                sliderEnd = this._slider.stop,
                sliderLength = this._slider.length,
                markerSize = this._slider.marker;

            if (vertical) {
                cursorPos = event.pageY - sliderOffset;
            } else {
                cursorPos = event.pageX - sliderOffset;
            }

            if (cursorPos < sliderStart) {
                cursorPos = sliderStart;
            } else if (cursorPos > sliderEnd) {
                cursorPos = sliderEnd;
            }

            if (vertical) {
                valuePix = sliderLength - cursorPos - markerSize / 2;
            } else {
                valuePix = cursorPos - markerSize / 2;
            }

            percents = this._pixToPerc(valuePix) + this.options.min;

            this.value(Math.round(percents));

            //this._placeMarker(percents);

            //this.options.position = percents;

            //this.dispatchEvent(

            //this.options.change(Math.round(percents), this.element);
        },

        _placeMarker: function (value) {
            var size, size2,
                o = this.options,
                colorParts = 0,
                colorIndex = 0,
                colorDelta = 0,
                marker = this.bk.children('.marker'),
                complete = this.bk.children('.complete'),
                hint = this.bk.children('.hint'),
				oldPos = this._percToPix(this.options.position);

            if (o.colors) {
                colorParts = o.colors.length;

                colorDelta = o._slider.length / colorParts;
            }

            if (this._slider.vertical) {
                var oldSize = this._percToPix(this.options.position) + this._slider.marker,
					oldSize2 = this._slider.length - oldSize;
                size = this._percToPix(value) + this._slider.marker;
                size2 = this._slider.length - size;
                this._animate(marker.css('top', oldSize2), { top: size2 });
                this._animate(complete.css('height', oldSize), { height: size });
                if (colorParts) {
                    colorIndex = Math.round(size / colorDelta) - 1;
                    complete.css('background-color', o.colors[colorIndex < 0 ? 0 : colorIndex]);
                }
                if (o.showHint) {
                    hint.html(Math.round(value)).css('top', size2 - hint.height() / 2);
                }
            } else {
                size = this._percToPix(value);
                this._animate(marker.css('left', oldPos), { left: size });
                this._animate(complete.css('width', oldPos), { width: size });
                if (colorParts) {
                    colorIndex = Math.round(size / colorDelta) - 1;
                    complete.css('background-color', o.colors[colorIndex < 0 ? 0 : colorIndex]);
                }
                if (o.showHint) {
                    this._animate(hint.html(Math.round(value)).css('left', oldPos - hint.width() / 2), { left: size - hint.width() / 2 });
                }
            }

        },

        _animate: function (obj, val) {
            if (this.options.animate) {
                obj.stop(true).animate(val);
            } else {
                obj.css(val);
            }
        },

        _pixToPerc: function (valuePix) {
            var valuePerc;
            valuePerc = valuePix * this._slider.ppp;
            return this._correctValue(valuePerc);
        },

        _percToPix: function (value) {
            if (this._slider.ppp === 0) {
                return 0;
            }
            return (value - this.options.min) / this._slider.ppp;
        },

        _correctValue: function (value) {
            var accuracy = this.options.accuracy || 0;
            var max = this.options.max;
            var min = this.options.min;
            if (accuracy === 0) {
                return value;
            }
            if (value === max) {
                return max;
            }
            if (value === min) {
                return min;
            }
            value = Math.floor(value / accuracy) * accuracy + Math.round(value % accuracy / accuracy) * accuracy;
            if (value > max) {
                return max;
            }
            if (value < min) {
                return min;
            }
            return value;
        },

        _initPoints: function () {
            var s = this._slider,
                element = this.bk;

            if (s.vertical) {
                s.offset = element.offset().top;
                s.length = element.height();
                s.marker = element.children('.marker').height();
            } else {
                s.offset = element.offset().left;
                s.length = element.width();
                s.marker = element.children('.marker').width();
            }

            s.ppp = (this.options.max - this.options.min) / (s.length - s.marker);
            s.start = s.marker / 2;
            s.stop = s.length - s.marker / 2;
        },

        _createSlider: function () {
            var element = $(this.element),
                options = this.options,
               complete, marker, hint,
                    preBtn, nextBtn;

            element.html('');

            preBtn = $("<span/>").addClass("btn pre fa").appendTo(element);
            this.bk = $("<div/>").addClass("bk").appendTo(element);
            complete = $("<div/>").addClass("complete").appendTo(this.bk);
            marker = $("<a/>").addClass("marker").appendTo(this.bk);
            nextBtn = $("<span/>").addClass("btn next fa").appendTo(element);

            if (options.showHint) {
                hint = $("<span/>").addClass("hint").appendTo(this.bk);
            }

            if (options.color && options.color != 'default') {
                element.css('background-color', options.color);
            }
            if (options.color && options.completeColor != 'default') {
                complete.css('background-color', options.completeColor);
            }
            if (options.color && options.markerColor != 'default') {
                marker.css('background-color', options.markerColor);
            }
        },

        value: function (value) {
            value = value > this.options.max ? this.options.max : value;
            value = value < this.options.min ? this.options.min : value;
            if (typeof value !== 'undefined') {
                var v = Math.round(parseInt(value));
                if (v != this.options.position) {
                    var old = this.options.position;
                    this._placeMarker(v);
                    this.options.position = v;
                    this.dispatchEvent("valuechanged", {value: Math.round(v), oldValue: old });
                }
               // this.options.change(Math.round(parseInt(value)), this.element);
                return this;
            } else {
                return Math.round(this.options.position);
            }
        },

        range: function (min, max) {
            this.options.max = max;
            this.options.min = min;

            this._initPoints();
            this.value(this.options.position);

        },

        _destroy: function () { },

        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });


    return ZoomControl;
});
h5.define('templates/InputDialogLayout', [], function () {
return '<div id="inputdialog" class="padding20 dialog" data-close-button="true">\
            <h4>' + lang[_curLang].markPointRemark + '</h4>\
            <div class="input-control textarea">\
                <textarea style="width: 324px;"></textarea>\
            </div>\
            <div style="text-align:right;">\
                <button class="button ok"><span class="mif-checkmark fg-lighterBlue"></span> ' + lang[_curLang].confirm + '</button>\
                <button class="button cancel"><span class="mif-cross fg-red"></span> ' + lang[_curLang].cancel + '</button>\
            </div>\
            <span class="dialog-close-button"></span>\
        </div>';
});
h5.define('templates/DialogLayout', [], function () {
    return '<div id="h5-dialog" class="h5 aui_state_focus" style="display:none;position: fixed;">\
        <div class="aui_outer">\
            <table class="aui_border">\
              <tbody>\
                <tr>\
                    <td class="aui_w"></td>\
                    <td class="aui_c">\
                        <div class="aui_inner">\
                            <table class="aui_dialog">\
                              <tbody>\
                                <tr>\
                                    <td colspan="2" class="aui_header">\
                                        <div class="aui_titleBar">\
                                            <div class="aui_title" style="cursor: move; display: block;">' + lang[_curLang].welcome + '</div>\
                                            <a class="aui_close" href="javascript:/*artDialog*/;" style="display: block;">×</a>\
                                        </div>\
                                    </td>\
                                </tr>\
                                <tr>\
                                    <td class="aui_icon">\
                                        <div class="aui_iconBg fa fa-check-circle"></div>\
                                    </td>\
                                    <td class="aui_main" style="width: auto; height: auto; visibility: visible;">\
                                        <div class="aui_content" style="padding: 20px 25px;">' + lang[_curLang].welcomeToUse + '</div>\
                                    </td>\
                                </tr>\
                                <tr>\
                                    <td colspan="2" class="aui_footer">\
                                        <div class="aui_buttons">\
                                            <button class=" aui_state_highlight">' + lang[_curLang].confirm + '</button>\
                                        </div>\
                                    </td>\
                                </tr\
                              </tbody>\
                            </table>\
                        </div>\
                    </td>\
                    <td class="aui_e"></td>\
                </tr>\
              </tbody>\
            </table>\
        </div>\
    </div>'
                //<tr>\
                //    <td class="aui_nw"></td>\
                //    <td class="aui_n"></td>\
                //    <td class="aui_ne"></td>\
                //</tr>\
                //<tr>\
                //    <td class="aui_sw"></td>\
                //    <td class="aui_s"></td>\
                //    <td class="aui_se" style="cursor: se-resize;"></td>\
                //</tr>\
});
/*
 * 提示对话框
    new Dialog({
        title: '对话框标题',
        content: '提示信息',
        style: 'succeed', //样式(警告<warn>、询问<question>、错误<error>、成功<succeed>)
        button:'Confirm',//按钮(是/否<Confirm>;确定<Ok>;确定/取消<OkCancel>)
        ok: function () {
            this.title('警告').content('请注意artDialog两秒后将关闭！').lock().time(2);
            return false;
        }
    });
 */
h5.define('plug/Dialog', ["jquery", "util/Object", "templates/DialogLayout", "util/util"],
    function ($, Obj, DIALOG_LAYOUT, util) {
        var Dialog = Obj.extend({
            init: function (options) {
                this._super();
                var _this = this,
                    _options = options,
                    _dialogElement;

                if (document.querySelector('#h5-dialog')) {
                    _dialogElement = document.querySelector('#h5-dialog');
                } else {
                    _dialogElement = $(DIALOG_LAYOUT)[0];
                    $("body").append(_dialogElement);
                }

                //点击右上角关闭按钮事件
                var _closeElement = _dialogElement.querySelector(".aui_close");
                _closeElement.addEventListener("click", function () {
                    _this.close();
                })

                //拖动对话框事件
                var _titleElement = _dialogElement.querySelector(".aui_title");
                _titleElement.addEventListener("mousedown", boundingMouseDown);
                var diffLeftPixel, diffTopPixel;
                function boundingMouseDown(e) {
                    diffLeftPixel = e.clientX - _dialogElement.offsetLeft,
                    diffTopPixel = e.clientY - _dialogElement.offsetTop;
                    _titleElement.removeEventListener("mousedown", boundingMouseDown, false);
                    window.addEventListener("mousemove", boundingMouseMove);
                    window.addEventListener("mouseup", boundingMouseUp);
                }
                function boundingMouseMove(e) {
                    _dialogElement.style.left = (e.clientX - diffLeftPixel) + "px";
                    _dialogElement.style.top = (e.clientY - diffTopPixel) + "px";
                }
                function boundingMouseUp() {
                    window.removeEventListener("mousemove", boundingMouseMove, false);
                    window.removeEventListener("mouseup", boundingMouseUp, false);
                    _titleElement.addEventListener("mousedown", boundingMouseDown);
                }

                //显示对话框
                _this.open = function () {
                    $(_dialogElement).css("display", "block").css("z-index", "10060").css("left", ($(window).width() - _dialogElement.offsetWidth) / 2 + "px").css("top", ($(window).height() - _dialogElement.offsetHeight) / 2 + "px");
                    //重置对话框
                    resetDialog();
                    //添加遮罩层
                    $("<div/>").addClass("maskdiv").appendTo($("body"));
                }
                //关闭对话框
                _this.close = function () {
                    //移除遮罩层
                    $(document.querySelector('.maskdiv')).remove();
                    $(_dialogElement).attr("style", "");
                    $(_dialogElement).css("display", "none").css("position", "fixed");
                }
                //重置对话框
                function resetDialog() {
                    $(_dialogElement.querySelector(".aui_title")).text(_options.title?_options.title:"");
                    $(_dialogElement.querySelector(".aui_content")).text(_options.content ? _options.content : "");
                    $(_dialogElement.querySelector(".aui_iconBg")).attr('class', "").addClass("aui_iconBg fa " + switchDialogStyle(_options.style));

                    if (_options.button) {
                        var _buttonsElement;
                        if (_dialogElement.querySelector(".aui_buttons")) {
                            _buttonsElement = _dialogElement.querySelector(".aui_buttons");
                        } else {
                            _buttonsElement = $("<div/>").addClass("aui_buttons");
                            _buttonsElement.appendTo($(_dialogElement.querySelector(".aui_footer")));
                        }
                        $(_buttonsElement).empty();
                        createButton(_buttonsElement);
                    } else $(_dialogElement.querySelector(".aui_buttons")).remove();
                }
                //创建对应按钮并绑定事件
                function createButton(parentElement) {
                    //按钮(是/否<Confirm>;确定<Ok>;确定/取消<OkCancel>)
                    btnStr = _options.button;
                    if (_options.button) btnStr = _options.button.toLowerCase();
                    var _okbtnHtml, _cancelbtnHtml;
                    switch(btnStr){
                        case 'confirm':
                            _okbtnHtml = '<button class="aui_state_highlight">' + lang[_curLang].yes + '</button>';
                            _cancelbtnHtml = '<button class="aui_state_highlight">' + lang[_curLang].no+ '</button>';
                            break;
                        case 'okcancel':
                            _okbtnHtml = '<button class="aui_state_highlight">' + lang[_curLang].confirm + '</button>';
                            _cancelbtnHtml = '<button class="aui_state_highlight">' + lang[_curLang].cancel + '</button>';
                            break;
                        default:
                            _okbtnHtml = '<button class="aui_state_highlight">' + lang[_curLang].confirm + '</button>';
                            _cancelbtnHtml = '';
                            break;
                    }
                    var _okbtnElement = $(_okbtnHtml)[0];
                    $(parentElement).append(_okbtnElement);
                    _okbtnElement.addEventListener("click", function () {
                        if (typeof _options.ok === 'function') {
                            //存在且是function
                            _options.ok();
                        }
                        _this.close();
                    })

                    if (_cancelbtnHtml) {
                        var _cancelbtnElement = $(_cancelbtnHtml)[0];
                        $(parentElement).append(_cancelbtnElement);
                        _cancelbtnElement.addEventListener("click", function () {
                            if (typeof _options.cancel === 'function') {
                                //存在且是function
                                _options.cancel();
                            }
                            _this.close();
                        })
                    }
                }
                //获取对话框样式
                function switchDialogStyle(styleName){
                    //样式(警告<warn>、询问<question>、错误<error>、成功<succeed>)
                    if (styleName) styleName = styleName.toLowerCase();
                    switch(styleName){
                        case 'warn':
                            return "fa-exclamation-circle-img";
                            break;
                        case 'question':
                            return "fa-question-circle-img";
                            break;
                        case 'error':
                            return "fa-times-circle-img";
                            break;
                        case 'succeed':
                            return "fa-check-circle-img";
                            break;
                        default:
                            return "fa-check-circle-img";
                            break;

                    }
                }
            }
        });
        return Dialog;
    }
);

/// <reference path="H5SelectBox.js" />
/*
 * 选择框
 */
h5.define('plug/H5SelectBox', ["jquery", "util/Object", "core/TrackEvent", "util/util"],
    function ($, Obj, TrackEvent, util) {
        var TRACK_HEIGHT = 30,
            BOX_MIN_WIDTH = 5,
            SCROLL_AREA_WIDTH = 10,
            SCROLL_INTERVAL = 10;
    var SelectBox = Obj.extend({
        init: function (app, media, timebarElement,tracksElement, mediaui) {
            var _media = media;
            this._super();

            var _element = tracksElement.querySelector(".wrapper"),
              _container = timebarElement.querySelector(".pos-container"),
              _boundingBoxElement = _container.querySelector(".selection-box"),
              _dragElement = _container.querySelector(".box-back"),
              _timebarElement = timebarElement,
              _offsetLeft = parseInt($(".timeline-trackcontainer", tracksElement).css("paddingLeft")),
              _show = false,
              _type = "H5SelectBox",
              _this = this,
              _manifest = {
                  displayName: lang[_curLang].inOrOutPoint,
                  options: {
                      inpoint: {
                          elem: "input",
                          type: "text",
                          label: lang[_curLang].in,
                          units: lang[_curLang].second
                      },
                      outpoint: {
                          elem: "input",
                          type: "text",
                          label: lang[_curLang].out,
                          units: lang[_curLang].second
                      }
                  }
              };  //属性窗口元数据

            _this.popcornOptions = {
                inpoint: startTime,
                outpoint:endTime
            };

            _element.addEventListener("mousedown", boundingBoxMouseDown);
            _dragElement.addEventListener("mousedown", dragMouseDown);
            //_timebarElement.addEventListener("mousedown", boundingBoxMouseDown);

            var _startingPosition = [],
              _containerRect = {},
              _elementRect = {},
              _leftGripElement,
              _rightGripElement,
              startTime = 0,
              endTime = 0;


            function clearGridElement() {
                if (_leftGripElement) {
                    _boundingBoxElement.removeChild(_leftGripElement);
                    _leftGripElement = null;
                }
                if (_rightGripElement) {
                    _boundingBoxElement.removeChild(_rightGripElement);
                    _rightGripElement = null;
                }
            }

            function setupGridElement() {
                var leftGrip = $("<div/>").addClass("handle left-handle");
                var rightGrip = $("<div/>").addClass("handle handle right-handle");

                clearGridElement();

                leftGrip.appendTo($(_boundingBoxElement));
                rightGrip.appendTo($(_boundingBoxElement));
                _leftGripElement = leftGrip[0];
                _rightGripElement = rightGrip[0];

                _leftGripElement.addEventListener("mousedown", boxLeftMouseDown);
                _rightGripElement.addEventListener("mousedown", boxRightMouseDown);
            }

            function boundingBoxMouseDown(e) {
                //不处理右键
                if (e.button === 2)
                    return;

                // Stops selecting while moving.
                e.preventDefault();
                //$(_boundingBoxElement).empty();
                clearGridElement();
                _containerRect = _container.getBoundingClientRect();
                _elementRect = _element.getBoundingClientRect();
                //_startingPosition = [e.clientX + tracksContainer.element.scrollLeft - _elementRect.left, e.clientY];
                _startingPosition = [e.pageX - _elementRect.left, e.pageY - _containerRect.top];
                _element.removeEventListener("mousedown", boundingBoxMouseDown, false);
                window.addEventListener("mousemove", boundingBoxMouseMove);
                window.addEventListener("mouseup", boundingBoxMouseUp);
            }



            function boundingBoxMouseMove(e) {
                var //thisPosition = [e.clientX + tracksContainer.element.scrollLeft - _elementRect.left, e.clientY],
                    thisPosition = [e.pageX - _elementRect.left, e.pageY - _containerRect.top],
                    minLeft = Math.min(thisPosition[0], _startingPosition[0]),
                    maxLeft = Math.max(thisPosition[0], _startingPosition[0]),
                    minTop = Math.min(thisPosition[1], _startingPosition[1]),
                    maxTop = Math.max(thisPosition[1], _startingPosition[1]);

                minLeft = Math.max(0, minLeft);
                minTop = Math.max(0, minTop);
                maxLeft = Math.min(_element.clientWidth, maxLeft);
                maxTop = Math.min(_element.clientHeight + (_elementRect.top - _containerRect.top), maxTop);

                _boundingBoxElement.classList.remove("hidden");

                //var boxleft = app.timeToPixel(Math.floor(app.pixelToTime(minLeft) / 1000) * 1000);
                //var boxwidth = app.timeToPixel(Math.ceil(app.pixelToTime(maxLeft - minLeft) / 1000) * 1000);

                _boundingBoxElement.style.top = minTop + "px";
                _boundingBoxElement.style.height = maxTop - minTop + "px";
                _boundingBoxElement.style.left = minLeft + "px";
                _boundingBoxElement.style.width = (maxLeft - minLeft) + "px";
                // $(_boundingBoxElement).css("z-index", 999);

            }

            function boundingBoxMouseUp(e) {
                _startingPosition = [];
                window.removeEventListener("mousemove", boundingBoxMouseMove, false);
                window.removeEventListener("mouseup", boundingBoxMouseUp, false);
                _element.addEventListener("mousedown", boundingBoxMouseDown);

                if ((_boundingBoxElement.offsetWidth-2) > BOX_MIN_WIDTH) {
                    _boundingBoxElement.style.top = null;
                    _boundingBoxElement.style.height = "auto";


                    setupGridElement();

                    _show = true;
                    app.editor.openTrackEventProperty(_this);

                    resetBoxSize();

                    $(_boundingBoxElement).attr("tabindex", 0);
                    $(_boundingBoxElement).focus();
                } else {
                    hide();
                }

                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
            }


            function dragMouseDown(e) {
                if (e.button === 2)
                    return;
                _containerRect = _container.getBoundingClientRect();
                _elementRect = _element.getBoundingClientRect();
                _startTime = startTime;
                _endTime = endTime;
                //_startingPosition = [e.clientX + tracksContainer.element.scrollLeft - _elementRect.left, e.clientY];
                _startingPosition = [e.pageX - _elementRect.left, e.pageY - _containerRect.top];
                _dragElement.removeEventListener("mousedown", dragMouseDown, false);
                window.addEventListener("mousemove", dragMouseMove);
                window.addEventListener("mouseup", dragMouseUp);

                app.editor.openTrackEventProperty(_this);
            }

            function dragMouseMove(e) {
                var thisPosition = [e.pageX - _elementRect.left, e.pageY - _containerRect.top];
                var diff = thisPosition[0] - _startingPosition[0];

                var diffTime = app.pixelToTime(diff) / 1000;

                if ((_startTime + diffTime) < 0) {
                    diffTime = -_startTime;
                }
                if (diffTime !== 0) {
                    update(_startTime + diffTime, _endTime + diffTime);


                    _this.dispatchEvent("selectionchanged");
                    app.dispatchEvent("selectionchanged");
                }

            }

            function dragMouseUp(e) {

                _dragElement.addEventListener("mousedown", dragMouseDown, false);
                window.removeEventListener("mousemove", dragMouseMove);
                window.removeEventListener("mouseup", dragMouseUp);
            }



            function update(s, e) {
                var _startTime = typeof  s === "number" ? s : startTime,
                    _endTime = typeof e === "number" ? e : endTime,
                    _scrollLeft = _element.scrollLeft,
                    _left = app.timeToPixel(_startTime * 1000) - _scrollLeft,
                    _right = app.timeToPixel(_endTime * 1000) - _scrollLeft;

                _startTime = util.roundTime(_startTime);
                _endTime = util.roundTime(_endTime);

                if (_right < 0 || _left > _element.clientWidth) {
                    //hiden
                    _boundingBoxElement.classList.add("hidden");
                } else {
                    _boundingBoxElement.classList.remove("hidden");

                    if (_left < 0) {
                        _leftGripElement.classList.add("hidden");
                        _boundingBoxElement.style.left = "0px";
                        _left = 0;
                    } else {
                        _leftGripElement.classList.remove("hidden");
                        _boundingBoxElement.style.left = _left + "px";
                    }

                    if (_right > (_element.clientWidth )) {
                        _rightGripElement.classList.add("hidden");
                        _boundingBoxElement.style.width = (_element.clientWidth - _left) + "px";
                    } else {
                        _rightGripElement.classList.remove("hidden");
                        _boundingBoxElement.style.width = (_right - _left) + "px";
                    }
                }

                startTime = _startTime;
                endTime = _endTime;

                _this.popcornOptions.inpoint = startTime;
                _this.popcornOptions.outpoint = endTime;

            }

            var oldwidth = 0,
                diffPixel = 0,
                _startingHandlePosition = 0,
                _lastPosition =0,
                _startTime = 0,
                _scroll =false,
                _endTime = 0;
            function boxLeftMouseDown(e) {
                //_element.removeEventListener("mousedown", boundingBoxMouseDown, false);
                window.removeEventListener("mousemove", boundingBoxMouseMove, false);
                window.removeEventListener("mouseup", boundingBoxMouseUp, false);

                _containerRect = _container.getBoundingClientRect();
                _elementRect = _element.getBoundingClientRect();

                _startingHandlePosition = e.pageX - _elementRect.left + _element.scrollLeft;
                _startTime = startTime;
                _scroll = false;


                _leftGripElement.removeEventListener("mousedown", boxLeftMouseDown, false);
                window.addEventListener("mousemove", boxLeftMouseMove);
                window.addEventListener("mouseup", boxLeftMouseUp);


               // diffPixel = (_startingHandlePosition - _elementRect.left) - _boundingBoxElement.offsetLeft;
               // oldwidth = _boundingBoxElement.offsetWidth - 2;
               // _leftGripElement.removeEventListener("mousedown", boxLeftMouseDown, false);
               // _timebarElement.addEventListener("mousemove", boxLeftMouseMove);
              //  _element.addEventListener("mousemove", boxLeftMouseMove);
              //  _leftGripElement.addEventListener("mouseup", boxLeftMouseUp);
            }
            function boxLeftMouseMove(e) {

                var pos = e.pageX - _elementRect.left;
                if (pos <= -SCROLL_AREA_WIDTH) {
                    if (!_scroll) {
                        _scroll = true;
                        setTimeout(function () {
                            if (_scroll) {
                                var old = _element.scrollLeft;
                                _element.scrollLeft -= SCROLL_INTERVAL;

                                var s = startTime + app.pixelToTime(_element.scrollLeft - old) / 1000;
                                s = Math.min( endTime, Math.max(0,s));

                                update(s, endTime);
                                _this.dispatchEvent("selectionchanged");
                                app.dispatchEvent("selectionchanged");
                                setTimeout(arguments.callee, 200);
                            }
                        }, 200);
                    }
                    return;
                }

                _scroll = false;
                _lastPosition = e.pageX - _elementRect.left + _element.scrollLeft;

                var diff = _lastPosition - _startingHandlePosition,
                    diffTime = app.pixelToTime(diff) / 1000,
                    newStartTime = Math.min(Math.max(_startTime + diffTime, 0), endTime);
                update(newStartTime, endTime);

                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");




                //var thisPosition = e.clientX + tracksContainer.element.scrollLeft;
                //var thisWidth = oldwidth + (_startingHandlePosition - thisPosition);
                //var thisLeft = thisPosition - _elementRect.left - diffPixel;
                //if (thisWidth > BOX_MIN_WIDTH && thisLeft>0) {
                //    _boundingBoxElement.style.left = thisLeft + "px";
                //    _boundingBoxElement.style.width = thisWidth + "px";
                //}
            }
            function boxLeftMouseUp(e) {
                //resetBoxSize();
                _scroll = false;
                _leftGripElement.addEventListener("mousedown", boxLeftMouseDown, false);
                window.removeEventListener("mousemove", boxLeftMouseMove);
                window.removeEventListener("mouseup", boxLeftMouseUp);

                update();

                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
                //_timebarElement.removeEventListener("mousemove", boxLeftMouseMove, false);
                //_element.removeEventListener("mousemove", boxLeftMouseMove, false);
                //_leftGripElement.removeEventListener("mouseup", boxLeftMouseUp, false);
                //_leftGripElement.addEventListener("mousedown", boxLeftMouseDown);
            }



            function boxRightMouseDown(e) {
              //  _element.removeEventListener("mousedown", boundingBoxMouseDown, false);
                window.removeEventListener("mousemove", boundingBoxMouseMove, false);
                window.removeEventListener("mouseup", boundingBoxMouseUp, false);

                _containerRect = _container.getBoundingClientRect();
                _elementRect = _element.getBoundingClientRect();

                _startingHandlePosition = e.pageX - _elementRect.left + _element.scrollLeft;
                _endTime = endTime;
                _scroll = false;


                _rightGripElement.removeEventListener("mousedown", boxRightMouseDown, false);
                window.addEventListener("mousemove", boxRightMouseMove);
                window.addEventListener("mouseup", boxRightMouseUp);

                //_element.removeEventListener("mousedown", boundingBoxMouseDown, false);
                //window.removeEventListener("mousemove", boundingBoxMouseMove, false);
                //window.removeEventListener("mouseup", boundingBoxMouseUp, false);

                //_startingHandlePosition = e.clientX + tracksContainer.element.scrollLeft;
                //oldwidth = _boundingBoxElement.offsetWidth - 2;
                //_rightGripElement.removeEventListener("mousedown", boxRightMouseDown, false);
                //_timebarElement.addEventListener("mousemove", boxRightMouseMove);
                //_element.addEventListener("mousemove", boxRightMouseMove);
                //_rightGripElement.addEventListener("mouseup", boxRightMouseUp);
            }
            function boxRightMouseMove(e) {

                var pos = e.pageX - _elementRect.left;
                if (pos >= _element.clientWidth  + SCROLL_AREA_WIDTH) {
                    if (!_scroll) {
                        _scroll = true;
                        setTimeout(function () {
                            if (_scroll) {
                                var old = _element.scrollLeft;
                                _element.scrollLeft += SCROLL_INTERVAL;

                                var e = endTime + app.pixelToTime(_element.scrollLeft - old) / 1000;
                                e = Math.max(startTime, e);

                                update(startTime, e);
                                _this.dispatchEvent("selectionchanged");
                                app.dispatchEvent("selectionchanged");
                                setTimeout(arguments.callee, 200);
                            }
                        }, 200);
                    }
                    return;
                }

                _scroll = false;
                _lastPosition = e.pageX - _elementRect.left + _element.scrollLeft;

                var diff = _lastPosition - _startingHandlePosition,
                    diffTime = app.pixelToTime(diff) / 1000,
                    newEndTime = Math.max(startTime, Math.max(_endTime + diffTime, 0));
                update(startTime, newEndTime);
                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");

                //var thisPosition = e.clientX + tracksContainer.element.scrollLeft;
                //var thisWidth = oldwidth + (thisPosition - _startingHandlePosition);
                //if (thisWidth > BOX_MIN_WIDTH && (_elementRect.width - _boundingBoxElement.offsetLeft) >= thisWidth) {
                //    _boundingBoxElement.style.width = thisWidth + "px";
                //}
            }
            function boxRightMouseUp(e) {
                _scroll = false;
                _rightGripElement.addEventListener("mousedown", boxRightMouseDown, false);
                window.removeEventListener("mousemove", boxRightMouseMove);
                window.removeEventListener("mouseup", boxRightMouseUp);

                update();

                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
                //resetBoxSize();

                //_timebarElement.removeEventListener("mousemove", boxRightMouseMove, false);
                //_element.removeEventListener("mousemove", boxRightMouseMove, false);
                //_rightGripElement.removeEventListener("mouseup", boxRightMouseUp, false);
                //_rightGripElement.addEventListener("mousedown", boxRightMouseDown);
            }
            function resetBoxSize() {

                var left = parseFloat(_boundingBoxElement.style.left),
                    width = $(_boundingBoxElement).width(),
                    scrollLeft = _element.scrollLeft,
                    _startTime = util.roundTime(app.pixelToTime(left + scrollLeft) / 1000),
                    _endTime = util.roundTime(_startTime + app.pixelToTime(width) / 1000);
                 //   aLeft = app.timeToPixel(startTime * 1000) - scrollLeft,
                 //   aWidth = app.timeToPixel((endTime - startTime) * 1000);

                update(_startTime, _endTime);

               // boxleft = app.timeToPixel(Math.floor(app.pixelToTime(_boundingBoxElement.offsetLeft + tracksContainer.element.scrollLeft) / 1000) * 1000) - tracksContainer.element.scrollLeft;
             //   boxwidth = app.timeToPixel(Math.ceil(app.pixelToTime(_boundingBoxElement.offsetWidth - 2) / 1000) * 1000);
             //   _boundingBoxElement.style.left = aLeft + "px";
             //   _boundingBoxElement.style.width = aWidth + "px";
            }

            _element.addEventListener("scroll", function () {
                if (_show && !_scroll) {
                    update();
                }
            });
           app.addEventListener("zoomchanged", function () {
                if (_show && !_scroll) {
                    update();
                }
           });



            function delBox(e) {
                if (e.keyCode == 27) {
                    hidBox();
                } else if (e.keyCode == 8 || e.keyCode == 46) {
                    //_trackEvent.track.removeTrackEvent(_trackEvent, true);
                    boxStartTime = app.pixelToTime(_boundingBoxElement.offsetLeft + tracksContainer.element.scrollLeft) / 1000;
                    boxEndTime = boxStartTime + (app.pixelToTime(_boundingBoxElement.offsetWidth - 2) / 1000);

                    util.forEach(_media.tracks, function (track) {
                        var delTime = boxEndTime - boxStartTime;
                        for (var i = 0; i < track.trackEvents.length; i++) {
                            trackEventData = track.trackEvents[i].popcornOptions;
                            if (trackEventData.start < boxStartTime && boxStartTime < trackEventData.end) {
                                if (trackEventData.start < boxEndTime && boxEndTime < trackEventData.end) {
                                    var newPopcornOptions = util.clone(track.trackEvents[i].popcornOptions);
                                    newPopcornOptions.start = boxEndTime + (trackEventData.end - boxEndTime);
                                    newPopcornOptions.end = newPopcornOptions.start + (trackEventData.end - boxEndTime);
                                    newPopcornOptions.from = track.trackEvents[i].popcornOptions.from + (boxEndTime - track.trackEvents[i].popcornOptions.start);
                                    var newTrackEvent = new TrackEvent(app, {
                                        clipdata: track.trackEvents[i].clipdata,
                                        plugin: track.trackEvents[i].plugin,
                                        type: track.trackEvents[i].type,
                                        popcornOptions: newPopcornOptions
                                    });

                                    if (i + 1 < track.trackEvents.length) {
                                        track.insertTrackEvent(newTrackEvent, track.trackEvents[i + 1]);
                                    } else {
                                        track.addTrackEvent(newTrackEvent);
                                    }
                                    delTime = delTime + (trackEventData.end - boxEndTime);
                                }
                                track.trackEvents[i].popcornOptions.end = boxStartTime;
                                track.trackEvents[i].popcornOptions.duration = track.trackEvents[i].popcornOptions.duration - (track.trackEvents[i].popcornOptions.end - boxStartTime);
                            }
                            if (boxStartTime <= trackEventData.start && trackEventData.end <= boxEndTime) {
                                track.trackEvents.splice(i, 1);
                                i--;
                            }
                            if (trackEventData.start < boxEndTime && boxEndTime < trackEventData.end) {
                                track.trackEvents[i].popcornOptions.start = boxEndTime;
                                track.trackEvents[i].popcornOptions.from = track.trackEvents[i].popcornOptions.from + (boxEndTime - track.trackEvents[i].popcornOptions.start);
                            }
                            if ((boxEndTime >= trackEventData.start && boxEndTime < trackEventData.end) || boxEndTime < trackEventData.start) {
                                track.trackEvents[i].popcornOptions.start = track.trackEvents[i].popcornOptions.start - delTime;
                                track.trackEvents[i].popcornOptions.end = track.trackEvents[i].popcornOptions.end - delTime;
                            }
                        }


                            //if (trackEventData.start <= boxStartTime && boxStartTime < trackEventData.end) {
                            //    if (trackEventData.start == boxStartTime) {
                            //        trackEventData.start
                            //    } else {

                            //    }
                            //}
                            //if (trackEventData.start < boxEndTime && boxEndTime <= trackEventData.end) {

                            //}
                        track.updateTrackEvents();
                        track.view.updateTrackEvents();
                    })
                    hidBox();
                }
            }
            function hide() {
                _boundingBoxElement.style.height = 'auto';
                _boundingBoxElement.style.width = 0;
                _boundingBoxElement.style.left = 0;
                _boundingBoxElement.style.top = 0;
                $(_boundingBoxElement).addClass("hidden");

                window.removeEventListener("mousemove", boundingBoxMouseMove, false);
                window.removeEventListener("mouseup", boundingBoxMouseUp, false);
                _timebarElement.removeEventListener("mousemove", boxLeftMouseMove, false);
                _element.removeEventListener("mousemove", boxLeftMouseMove, false);
                if (_leftGripElement) {
                    _leftGripElement.removeEventListener("mouseup", boxLeftMouseUp, false);
                }
                _timebarElement.removeEventListener("mousemove", boxRightMouseMove, false);
                _element.removeEventListener("mousemove", boxRightMouseMove, false);
                if (_rightGripElement) {
                    _rightGripElement.removeEventListener("mouseup", boxRightMouseUp, false);
                }

                _element.addEventListener("mousedown", boundingBoxMouseDown);

                _show = false;
                startTime = endTime = 0;
                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
            }


            app.getSelectionRange = _this.getSelectionRange = function () {
                if (!_show) {
                    return [0, 0];
                }
                return [startTime, endTime];
            }


            app.setSelection = _this.setSelection = function (s, e) {
                var _startTime = typeof s === "number" ? s : startTime,
                    _endTime = typeof e === "number" ? e : endTime;

                if (_startTime > _endTime) {
                    throw new Error(lang[_curLang].markInGreater);
                }
                if (_endTime < _startTime) {
                    throw new Error(lang[_curLang].markoutLess);
                }

                update(_startTime, _endTime);

                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
            }

            app.setInpoint = _this.setInpoint = function (time) {
                if (time < 0 || time > app.media.duration) {
                    return false;
                }

                var et = endTime;
                if (et < time)
                    et = time;

                setupGridElement();
                _boundingBoxElement.classList.remove("hidden");
                _show = true;
                update(time, et);
                app.editor.openTrackEventProperty(_this);
                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
                return true;
            }

            app.setOutpoint = _this.setOutpoint = function (time) {
                if (time < startTime) {
                    return false;
                }

                if (time > app.media.duration) {
                    time = app.media.duration;
                }

                update(startTime, time);

                _this.dispatchEvent("selectionchanged");
                app.dispatchEvent("selectionchanged");
                return true;
            }

            app.clearInOutpoint = _this.clearInOutPoint = function () {
                hide();
            }



            //_this.addEventListener("selectionchanged", function () {
            //    app.editor.openTrackEventProperty(_this);
            //});

            Object.defineProperties(_this, {
                type: {
                    enumerable: true,
                    get: function () {
                        return _type;
                    }
                },
                id: {
                    enumerable: true,
                    get: function () {
                        return _type + "_1";
                    }
                },
                manifest: {
                    enumerable: true,
                    get: function () {
                        return _manifest;
                    }
                }
            });
        }

    });

    return SelectBox;


});

/*
 * 通过在层上拖动鼠标右键来修改时间线缩放级别的辅助类
 */
h5.define("timeline/H5ZoomHelper", ["jquery", "util/util"], function ($, util) {
    var H5ZoomHelper = function (app, media, mediaUi, timeline, tracksElement) {
        var _tracksElement = tracksElement,
            _element = tracksElement.querySelector(".wrapper"),
            _app = app,
            _media = media,
            _mediaUi = mediaUi,
            _timeline = timeline,
            _this = this,
            _downPostion = [],
            _isDown = false,
            _rect = null,
            _curZoom = 0,
            _posTime = 0,
            _pos = 0,
            _scroll = 0,
            _unit = 0;

        function onMouseDown(e) {
            if (e.button === 2) {
                //右键
                _downPostion = [e.pageX, e.pageY];
                _isDown = true;
                _rect = _element.getBoundingClientRect();
                _curZoom = _timeline.zoom();
                _scroll = _mediaUi.scrollTrack();
                _pos = e.pageX - _rect.left + _scroll;
                _posTime = _app.pixelToTime(_pos);
                if (_posTime < 0) {
                    _posTime = 0;
                }
                _unit = _rect.height / _timeline._zoomList.length;
                window.addEventListener("mousemove", onMouseMove);
                window.addEventListener("mouseup", onMouseUp);
            }
        }

        function onMouseMove(e) {
            if (_isDown) {

                var curPos = [e.pageX, e.pageY];
                var diff = _downPostion[1] - curPos[1];
                //console.log(diff + ' ' + _height);


                var count =Math.round(diff / _unit);
                //向下 放大
                if (count !== 0) {
                    var z = _curZoom + count;
                    if (z < 0) {
                        z = 0;
                    }
                    if (z > _timeline._zoomList.length - 1) {
                        z = _timeline._zoomList.length - 1;
                    }
                    console.log(z);
                    if (z != _timeline.zoom()) {
                        _timeline.zoom(z);
                        _mediaUi.updateLayout();
                        var p = _app.timeToPixel(_posTime);
                        var scroll = p - (_pos - _scroll);
                       // if (scroll > 0) {
                            _mediaUi.scrollTrack(scroll);
                            console.log(scroll);
                      //  }



                    }
                }
            }
        }

        function onMouseUp(e) {
            window.removeEventListener("mousemove", onMouseMove);
            window.removeEventListener("mouseup", onMouseUp);

        }

        _element.addEventListener("mousedown", onMouseDown);



    };

    return H5ZoomHelper;
});
/// <reference path="../require.js" />
/// <reference path="TrackEventPluginManager.js" />
/*
 * 管理编辑器的所有组件交互
 */
h5.define('timeline/H5Media', ["jquery", "util/Object", "core/TrackEvent", "core/Track",
          "timeline/H5TrackContainer", "util/H5Scrollbar", "timeline/H5Timeline",
          "timeline/H5Toolbar", "timeline/H5TrackHandles", "util/H5Zoombar",
          "core/TrackEventPluginManager",
          "templates/H5TracksLayout",
          'templates/H5TimebarLayout',
          'timeline/ZoomControl',
          'templates/InputDialogLayout',
          "plug/Dialog",
          "plug/H5SelectBox",
          "timeline/H5ZoomHelper",
          "util/util"
           ],
  function ($, Obj, TrackEvent, Track,
            H5TrackContainer, H5Scrollbar, H5Timeline,
            H5Toolbar, H5TrackHandles, H5Zoombar,
            TrackEventPluginManager,
            H5_TRACKS_LAYOUT,
            H5_TIMEBAR_LAYOUT,
            ZoomControl,
            InputDialog_Layout,
            Dialog,
            H5SelectBox,
            H5ZoomHelper,
            util
            ) {

      var DEFAULT_BOUNDS = [0, 1];

      var H5Media = Obj.extend({

          init:function(app, media, options) {

              this._super();

              options = options || {};


              var _bounds = DEFAULT_BOUNDS;

              function setContainerBounds(left, right) {
                  if (_bounds[0] !== left || _bounds[1] !== right) {
                      _bounds = [left, right];
                      _tracksContainer.setViewportBounds(left, right);
                      updateUI();
                  }
              }

              var _this = this,
                  _media = media,
                  _rootElement = app.rootElement,
                  _tracksElement = $(H5_TRACKS_LAYOUT)[0],
                  _timebarElement = $(H5_TIMEBAR_LAYOUT)[0], //时间线及状态显示
                  _zoomControlElement = $("<div/>").addClass("zoomcontrol slider")[0],
                  _logoElement = _timebarElement.querySelector(".h5-logo-title");

              if (options.title) {
                  _logoElement.innerText = options.title;
              }

              app.tracksAreaElement.appendChild(_tracksElement);
              app.timebarAreaElement.appendChild(_timebarElement);
              app.timebarAreaElement.appendChild(_zoomControlElement);

              var _tracksContainer = new H5TrackContainer(app, media, _tracksElement, _zoomControlElement),
              _container = _tracksElement.querySelector(".trackbar-container"),
             // _superScrollbar = new H5Zoombar(_tracksContainer.element, _tracksContainer.container, setContainerBounds, _media),
              _vScrollBar = new H5Scrollbar.Vertical(_tracksContainer.element, _tracksContainer.container),
              _hScrollBar = new H5Scrollbar.Horizontal(_tracksContainer.element, _tracksContainer.container),
              _timeline = new H5Timeline(app, _media, app.timebarAreaElement, _tracksContainer),
              _trackHandles = new H5TrackHandles(app, _media, _tracksElement, _tracksContainer),
              _toolbar = new H5Toolbar(app,_media, app.timebarAreaElement),

              _zoomcontrol = new ZoomControl(_zoomControlElement, {
                  max: _timeline._zoomList.length - 1,
                  min: 0,
                  minStep: 1,
                  accuracy: 0,
                  showHint: true,
                  vertical: false
              }),
              _zoomHelper = new H5ZoomHelper(app, media, this, _timeline, _tracksElement),
              _selectBox = new H5SelectBox(app, _media, _timebarElement, _tracksElement, _this);



              _timeline.zoom(5);
              _zoomcontrol.value(_timeline.zoom());
              _timeline.addEventListener("zoomchanged", function () {
                  _zoomcontrol.value(_timeline.zoom());
              });



              _tracksContainer.setScrollbars(_vScrollBar, _hScrollBar);

              _container.appendChild(_vScrollBar.element);
              _container.appendChild(_hScrollBar.element);


              _zoomcontrol.addEventListener("valuechanged", function (e) {
                  var evt = e.data;
                  //alert(evt.value);
                  _timeline.zoom(evt.value);
                  updateLayout();
              });

              _media.addEventListener("mediapopcornsettingschanged", function () {
                  util.frameRate = app.media.popcornOptions.framerate;
                  _timeline.changeFrameRate(app.media.popcornOptions.framerate);
              });

              function updateLayout() {
                  //更新时间线上的标记点
                  //app.markPointPlugin.updateMarkPointLeft();
                  //更新当前时间线和位置线
                  _timeline.update();
                  //更新编辑器内容（视频和滚动条）
                  _tracksContainer.update();
              }

              function onEditorToggled() {
                  _tracksContainer.update();
                  _timeline.update();
                //  _superScrollbar.resize();
              }

              function onEditorOpened() {
                  _tracksContainer.update();
                  _timeline.update();
              }

              function onVerticalResize() {
                  _vScrollBar.update();
                  _timeline.update();
              }

              function onResize() {
                  _vScrollBar.update();
                  _timeline.update();
                  _vScrollBar.update();
                  _hScrollBar.update();
                 // _superScrollbar.resize();
              }

              window.addEventListener("resize", onResize);

              function onMediaTimeUpdate() {
                  // 自动调整层容器的滚动位移，保证当前位置位于可视窗口内
                  _tracksContainer.followCurrentTime();
              }

              _media.addEventListener("mediaplay", function () {
                  // 调整层容器的滚动位置
                  _tracksContainer.snapTo(_media.currentTime);
                  // 监听帧事件
                  _media.addEventListener("mediatimeupdate", onMediaTimeUpdate);
              });

              _media.addEventListener("mediapause", function () {
                  // 停止监听帧事件
                  _media.removeEventListener("mediatimeupdate", onMediaTimeUpdate);
              });


              function onTrackEventDeselected(e) {
                  //app.editor.closeTrackEventEditor(e.target);
              }

              function onMediaReady() {
                  updateUI();
                  _timeline.ready();

              }

              function onMediaReadyFirst() {
                  _media.removeEventListener("mediaready", onMediaReadyFirst);
                  _media.addEventListener("mediaready", onMediaReady);


                  function onTrackAdded(e) {
                      var track = e.data;

                      var existingEvents = track.trackEvents;
                      for (var i = 0; i < existingEvents.length; ++i) {
                          //onTrackEventAdded({
                          //    data: existingEvents[i]
                         // });
                      }

                  }

                  var existingTracks = _media.tracks;
                  for (var i = 0; i < existingTracks.length; ++i) {
                      onTrackAdded({
                          data: existingTracks[i]
                      });
                  }

                  _media.addEventListener("trackadded", onTrackAdded);
                  _bounds = DEFAULT_BOUNDS;
                  _tracksContainer.setViewportBounds(_bounds[0], _bounds[1]);
                  onMediaReady();

                  _media.currentTime = 0;
              }

              _media.addEventListener("mediaready", onMediaReadyFirst);


              this.hide = function () {
                  _rootElement.style.display = "none";
              };

              this.show = function () {
                  _rootElement.style.display = "block";
              };

              this.hideTrackHolder = function () {
                  util.forEach(_media.tracks, function (t) {
                      t.view.hideTrackHolder();
                  });
              };
              this.scrollTrack = function (val) {

                  return _hScrollBar.scroll(val);
              };

              function updateUI() {
                  if (_media.duration) {
                      _tracksContainer.update();
                      _timeline.update();
                   //   _superScrollbar.update();
                      _trackHandles.update();
                  }
                  _vScrollBar.update();
                  _hScrollBar.update();

              }

              app.addEventListener("ready", function () {
                  updateUI();
              });

              app.addEventListener('resize', function () {
                  onVerticalResize();
              });

              this.trackContainer = _tracksContainer;
              this.element = _rootElement;
              this.media = _media;
              this.verticalResize = onVerticalResize;
              this.update = updateUI;
              this.updateLayout = updateLayout;
          },

      });




      return H5Media;

  });
h5.define("core/EditorPluginBase", ["util/Object"], function (Obj) {
    var EditorPluginBase = Obj.extend({
        init: function (app) {
            var _this = this,
                _app = app;

            _this._super();

            // 方便基类调用
            _this.createPanel = function (id, displayName, desc, disableScroll) {
                return _app.pluginService.createPanel(id, displayName, desc, disableScroll);
            };


            _this.createToolbarButton = function (id, afterSelector) {
                return _app.pluginService.createToolbarButton(id, afterSelector);
            };

            _this.activePanel = function (id) {
                return _app.pluginService.activePanel(id);
            };

            _this.setApp = function (app) {
                _app = app;
            };
            _this.updateScroll = function () {
                _app.playerPanel.pluginPanel.update();
            };
        },
        name: function () {
            throw new Error(lang[_curLang].baseClass);
        },

        remove: function () {
        },
        loadData: function (json) {
            //
        },
        getData: function (json) {
        },
        clearData: function (json) {
        }
    });


    return EditorPluginBase;
});
/*
 * 插件管理
 */
h5.define("core/EditorPluginManager", ["core/EditorPluginBase", "util/util"], function (EditorPluginBase, util) {
    var EditorPluginManager = function (app) {
        this._service = {};
        var _plugin = {},
            _app = app;

        app.pluginService = this._service;

        this.registerPlugin = function (p) {

            var plugin = p;
            if (plugin instanceof EditorPluginBase) {
            } else {
                plugin = new p(_app);
                plugin.setApp(_app);
            }

            if (plugin && plugin.name) {
                if (_plugin[plugin.name()]) {
                    throw new Error(lang[_curLang].plugin + p.name() + lang[_curLang].repeat);
                }

                _plugin[plugin.name()] = plugin;

            }

            return plugin;
        };

        this.removePlugin = function (p) {
            var name = p;
            if (p instanceof EditorPluginBase) {
                name = p.name();
            }
            if (name && _plugin[name]) {
                var plugin = _plugin[name];
                if (plugin) {
                    plugin.remove();
                }
                delete _plugin[name];
            }
        };

        this.getPlugin = function (name) {
            return _plugin[name];
        };

        this.getPluginList = function () {
            return util.clone(_plugin);
        };

    };






    return EditorPluginManager;
});
/*! jQuery UI - v1.11.4 - 2015-08-06
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, draggable.js, droppable.js, resizable.js, selectable.js, sortable.js
* Copyright 2015 jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof h5.define === 'function' && h5.define.amd ) {

		// AMD. Register as an anonymous module.
		h5.define('jquery-ui',[ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
/*!
 * jQuery UI Core 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */


// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.11.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	scrollParent: function( includeHidden ) {
		var position = this.css( "position" ),
			excludeStaticParent = position === "absolute",
			overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
			scrollParent = this.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: (function() {
		var uuid = 0;

		return function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			});
		};
	})(),

	removeUniqueId: function() {
		return this.each(function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" )[ 0 ];
		return !!img && visible( img );
	}
	return ( /^(input|select|textarea|button|object)$/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	disableSelection: (function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.bind( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
		};
	})(),

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};


/*!
 * jQuery UI Widget 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */


var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat(args) );
			}

			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

var widget = $.widget;


/*!
 * jQuery UI Mouse 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */


var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

var mouse = $.widget("ui.mouse", {
	version: "1.11.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown." + this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click." + this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("." + this.widgetName);
		if ( this._mouseMoveDelegate ) {
			this.document
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};

		this.document
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {
			// IE mouseup check - mouseup happened when mouse was out of window
			if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
				return this._mouseUp(event);

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {
				return this._mouseUp( event );
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		this.document
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		mouseHandled = false;
		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});


/*!
 * jQuery UI Draggable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */


$.widget("ui.draggable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {
		var o = this.options;

		this._blurActiveElement( event );

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var document = this.document[ 0 ];

		// Only need to blur if the event occurred on the draggable itself, see #10527
		if ( !this.handleElement.is( event.target ) ) {
			return;
		}

		// support: IE9
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {

			// Support: IE9, IE10
			// If the <body> is blurred, IE will switch windows, see #9520
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {

				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}
	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter(function() {
				return $( this ).css( "position" ) === "fixed";
			}).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		// Reset helper's right/bottom css if they're set and set explicit width/height instead
		// as this prevents resizing of elements with right/bottom set (see #7772)
		this._normalizeRightBottom();

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {
			// The interaction is over; whether or not the click resulted in a drag, focus the element
			this.element.focus();
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this.handleElement.addClass( "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this.handleElement.removeClass( "ui-draggable-handle" );
	},

	_createHelper: function(event) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if (!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		// http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"), 10) || 0),
			top: (parseInt(this.element.css("marginTop"), 10) || 0),
			right: (parseInt(this.element.css("marginRight"), 10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ){
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	_normalizeRightBottom: function() {
		if ( this.options.axis !== "y" && this.helper.css( "right" ) !== "auto" ) {
			this.helper.width( this.helper.width() );
			this.helper.css( "right", "auto" );
		}
		if ( this.options.axis !== "x" && this.helper.css( "bottom" ) !== "auto" ) {
			this.helper.height( this.helper.height() );
			this.helper.css( "bottom", "auto" );
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each(function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// refreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger("activate", event, uiSortable);
			}
		});
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		});

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop(event);

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {
				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		});
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {
					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				});
			}

			if ( innermostIntersecting ) {
				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});

					// hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );
					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {
				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					});
				}
			}
		});
	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] && i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== "x") {
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== "y") {
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left - inst.margins.left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top - inst.margins.top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left;
				}
			}

			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a, b) {
				return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

var draggable = $.ui.draggable;


/*!
 * jQuery UI Droppable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */


$.widget( "ui.droppable", {
	version: "1.11.4",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {
				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {
				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this.element.addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {
		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );

		this.element.removeClass( "ui-droppable ui-droppable-disabled" );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.addClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.removeClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
			var inst = $( this ).droppable( "instance" );
			if (
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
				$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance, event )
			) { childrenIntersection = true; return false; }
		});
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = (function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs || draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs || draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) && isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
})();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				});

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// we just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call( this, event );

			// we just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

var droppable = $.ui.droppable;


/*!
 * jQuery UI Resizable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */


$.widget("ui.resizable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseInt( value, 10 ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseInt( value, 10 ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		// Wrap the element if it cannot hold child nodes
		if (this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)) {

			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			this.element.css({
				marginLeft: this.originalElement.css("marginLeft"),
				marginTop: this.originalElement.css("marginTop"),
				marginRight: this.originalElement.css("marginRight"),
				marginBottom: this.originalElement.css("marginBottom")
			});
			this.originalElement.css({
				marginLeft: 0,
				marginTop: 0,
				marginRight: 0,
				marginBottom: 0
			});
			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			this._proportionallyResizeElements.push( this.originalElement.css({
				position: "static",
				zoom: 1,
				display: "block"
			}) );

			// support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			this._proportionallyResize();
		}

		this.handles = o.handles ||
			( !$(".ui-resizable-handle", this.element).length ?
				"e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				} );

		this._handles = $();
		if ( this.handles.constructor === String ) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for (i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-" + handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				axis.css({ zIndex: o.zIndex });

				// TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				this.handles[handle] = ".ui-resizable-" + handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for (i in this.handles) {

				if (this.handles[i].constructor === String) {
					this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
					this.handles[ i ] = $( this.handles[ i ] );
					this._on( this.handles[ i ], { "mousedown": that._mouseDown });
				}

				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)) {

					axis = $(this.handles[i], this.element);

					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();
				}

				this._handles = this._handles.add( this.handles[ i ] );
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
		this._handles.disableSelection();

		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function() {
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		this._mouseInit();
	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp)
					.removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable")
					.removeData("ui-resizable")
					.unbind(".resizable")
					.find(".ui-resizable-handle")
						.remove();
			};

		// TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num(this.helper.css("left"));
		curtop = this._num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };

		this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.sizeDiff = {
			width: el.outerWidth() - el.width(),
			height: el.outerHeight() - el.height()
		};

		this.originalPosition = { left: curleft, top: curtop };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = (typeof o.aspectRatio === "number") ?
			o.aspectRatio :
			((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		var data, props,
			smp = this.originalMousePosition,
			a = this.axis,
			dx = (event.pageX - smp.left) || 0,
		    dy = (event.pageY - smp.top) || 0,
			trigger = this._change[a];

		this._updatePrevProperties();

		if (!trigger) {
			return false;
		}

		data = trigger.apply(this, [ event, dx, dy ]);

		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		this._propagate("resize", event);

		props = this._applyChanges();

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._updatePrevProperties();
			this._trigger( "resize", event, this.ui() );
			this._applyChanges();
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if (this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = {
				width: (that.helper.width()  - soffsetw),
				height: (that.helper.height() - soffseth)
			};
			left = (parseInt(that.element.css("left"), 10) +
				(that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) +
				(that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updatePrevProperties: function() {
		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};
	},

	_applyChanges: function() {
		var props = {};

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}

		this.helper.css( props );

		return props;
	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if (this._aspectRatio || forceAspectRatio) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if (pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if (pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if (pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if (pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (this._isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (this._isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (this._isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (this._isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (this._isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (this._isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
			ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
			isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_getPaddingPlusBorderDimensions: function( element ) {
		var i = 0,
			widths = [],
			borders = [
				element.css( "borderTopWidth" ),
				element.css( "borderRightWidth" ),
				element.css( "borderBottomWidth" ),
				element.css( "borderLeftWidth" )
			],
			paddings = [
				element.css( "paddingTop" ),
				element.css( "paddingRight" ),
				element.css( "paddingBottom" ),
				element.css( "paddingLeft" )
			];

		for ( ; i < 4; i++ ) {
			widths[ i ] = ( parseInt( borders[ i ], 10 ) || 0 );
			widths[ i ] += ( parseInt( paddings[ i ], 10 ) || 0 );
		}

		return {
			height: widths[ 0 ] + widths[ 2 ],
			width: widths[ 1 ] + widths[ 3 ]
		};
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var prel,
			i = 0,
			element = this.helper || this.element;

		for ( ; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			// TODO: Seems like a bug to cache this.outerDimensions
			// considering that we are in a loop.
			if (!this.outerDimensions) {
				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
			}

			prel.css({
				height: (element.height() - this.outerDimensions.height) || 0,
				width: (element.width() - this.outerDimensions.width) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if (this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments),
				this._change.e.apply(this, [ event, dx, dy ]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments),
				this._change.w.apply(this, [ event, dx, dy ]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments),
				this._change.e.apply(this, [ event, dx, dy ]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments),
				this._change.w.apply(this, [ event, dx, dy ]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [ event, this.ui() ]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) +
				(that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) +
				(that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			});

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width +
				( that._helper ?
					( that.position.left - co.left ) :
					( that.position.left - cop.left ) );

			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height +
				( that._helper ?
					( that.position.top - co.top ) :
					that.position.top );

			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;
		} else {
			that.offset.left = that.element.offset().left;
			that.offset.top = that.element.offset().top;
		}

		woset = Math.abs( that.sizeDiff.width +
			(that._helper ?
				that.offset.left - cop.left :
				(that.offset.left - co.left)) );

		hoset = Math.abs( that.sizeDiff.height +
			(that._helper ?
				that.offset.top - cop.top :
				(that.offset.top - co.top)) );

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ) {
			that.position.left = that.prevPosition.left;
			that.position.top = that.prevPosition.top;
			that.size.width = that.prevSize.width;
			that.size.height = that.prevSize.height;
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}
	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function() {
		var that = $(this).resizable( "instance" ),
			o = that.options;

		$(o.alsoResize).each(function() {
			var el = $(this);
			el.data("ui-resizable-alsoresize", {
				width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
				left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
			});
		});
	},

	resize: function(event, ui) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0,
				width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0,
				left: (that.position.left - op.left) || 0
			};

			$(o.alsoResize).each(function() {
				var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
					css = el.parents(ui.originalElement[0]).length ?
							[ "width", "height" ] :
							[ "width", "height", "top", "left" ];

				$.each(css, function(i, prop) {
					var sum = (start[prop] || 0) + (delta[prop] || 0);
					if (sum && sum >= 0) {
						style[prop] = sum || null;
					}
				});

				el.css(style);
			});
	},

	stop: function() {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({
				opacity: 0.25,
				display: "block",
				position: "relative",
				height: cs.height,
				width: cs.width,
				margin: 0,
				left: 0,
				top: 0
			})
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost) {
			that.ghost.css({
				position: "relative",
				height: that.size.height,
				width: that.size.width
			});
		}
	},

	stop: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var outerDimensions,
			that = $(this).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
			gridX = (grid[0] || 1),
			gridY = (grid[1] || 1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth += gridX;
		}
		if (isMinHeight) {
			newHeight += gridY;
		}
		if (isMaxWidth) {
			newWidth -= gridX;
		}
		if (isMaxHeight) {
			newHeight -= gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0) {
				outerDimensions = that._getPaddingPlusBorderDimensions( this );
			}

			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				newHeight = gridY - outerDimensions.height;
				that.size.height = newHeight;
				that.position.top = op.top + os.height - newHeight;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				newWidth = gridX - outerDimensions.width;
				that.size.width = newWidth;
				that.position.left = op.left + os.width - newWidth;
			}
		}
	}

});

var resizable = $.ui.resizable;


/*!
 * jQuery UI Selectable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectable/
 */


var selectable = $.widget("ui.selectable", $.ui.mouse, {
	version: "1.11.4",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var selectees,
			that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this),
					pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass("ui-selected"),
					selecting: $this.hasClass("ui-selecting"),
					unselecting: $this.hasClass("ui-unselecting")
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];

		if (this.options.disabled) {
			return;
		}

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(".ui-selected").each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass("ui-selected");
				selectee.selected = false;
				selectee.$element.addClass("ui-unselecting");
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().addBack().each(function() {
			var doSelect,
				selectee = $.data(this, "selectable-item");
			if (selectee) {
				doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {

		this.dragged = true;

		if (this.options.disabled) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[0],
			y1 = this.opos[1],
			x2 = event.pageX,
			y2 = event.pageY;

		if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item"),
				hit = false;

			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element === that.element[0]) {
				return;
			}

			if (options.tolerance === "touch") {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance === "fit") {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass("ui-unselecting");
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass("ui-selecting");
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						selectee.$element.addClass("ui-selected");
						selectee.selected = true;
					} else {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;

						selectee.$element.addClass("ui-unselecting");
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		$(".ui-unselecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-unselecting");
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$(".ui-selecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});


/*!
 * jQuery UI Sortable 1.11.4
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/sortable/
 */


var sortable = $.widget("ui.sortable", $.ui.mouse, {
	version: "1.11.4",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
	},

	_create: function() {
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
		$.each( this.items, function() {
			( this.instance.options.handle ?
				this.item.find( this.instance.options.handle ) : this.item )
				.addClass( "ui-sortable-handle" );
		});
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-sortable ui-sortable-disabled" )
			.find( ".ui-sortable-handle" )
				.removeClass( "ui-sortable-handle" );
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[i].item.removeData(this.widgetName + "-item");
		}

		return this;
	},

	_mouseCapture: function(event, overrideHandle) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type === "static") {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$(event.target).parents().each(function() {
			if($.data(this, that.widgetName + "-item") === that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + "-item") === that) {
			currentItem = $(event.target);
		}

		if(!currentItem) {
			return false;
		}
		if(this.options.handle && !overrideHandle) {
			$(this.options.handle, currentItem).find("*").addBack().each(function() {
				if(this === event.target) {
					validHandle = true;
				}
			});
			if(!validHandle) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] !== this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		if( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) {
				this._storedOpacity = this.helper.css("opacity");
			}
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) {
				this._storedZIndex = this.helper.css("zIndex");
			}
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions) {
			this._cacheHelperProportions();
		}


		//Post "activate" events to possible containers
		if( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			if(this.scrollParent[0] !== this.document[0] && this.scrollParent[0].tagName !== "HTML") {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
				}

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				}

			} else {

				if(event.pageY - this.document.scrollTop() < o.scrollSensitivity) {
					scrolled = this.document.scrollTop(this.document.scrollTop() - o.scrollSpeed);
				} else if(this.window.height() - (event.pageY - this.document.scrollTop()) < o.scrollSensitivity) {
					scrolled = this.document.scrollTop(this.document.scrollTop() + o.scrollSpeed);
				}

				if(event.pageX - this.document.scrollLeft() < o.scrollSensitivity) {
					scrolled = this.document.scrollLeft(this.document.scrollLeft() - o.scrollSpeed);
				} else if(this.window.width() - (event.pageX - this.document.scrollLeft()) < o.scrollSensitivity) {
					scrolled = this.document.scrollLeft(this.document.scrollLeft() + o.scrollSpeed);
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}

		//Rearrange
		for (i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[i];
			itemElement = item.item[0];
			intersection = this._intersectsWithPointer(item);
			if (!intersection) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if (item.instance !== this.currentContainer) {
				continue;
			}

			// cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if (itemElement !== this.currentItem[0] &&
				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
				!$.contains(this.placeholder[0], itemElement) &&
				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		//Call callbacks
		this._trigger("sort", event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			$.ui.ddmanager.drop(this, event);
		}

		if(this.options.revert) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollLeft);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === this.document[0].body ? 0 : this.offsetParent[0].scrollTop);
			}
			this.reverting = true;
			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper === "original") {
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) {
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			}
			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
				this.helper.remove();
			}

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			str = [];
		o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
			if (res) {
				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
			}
		});

		if(!str.length && o.key) {
			str.push(o.key + "=");
		}

		return str.join("&");

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			ret = [];

		o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
				x2 - (this.helperProportions.width / 2) < r && // Left Half
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
				y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement) {
			return false;
		}

		return this.floating ?
			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if(connectWith && connected) {
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i], this.document[0]);
				for ( j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
					}
				}
			}
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

		function addItems() {
			items.push( this );
		}
		for (i = queries.length - 1; i >= 0; i--){
			queries[i][0].each( addItems );
		}

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] === item.item[0]) {
					return false;
				}
			}
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i], this.document[0]);
				for (j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				}
			}
		}

		for (i = queries.length - 1; i >= 0; i--) {
			targetData = queries[i][1];
			_queries = queries[i][0];

			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				item = $(_queries[j]);

				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			}
		}

	},

	refreshPositions: function(fast) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
			false;

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for (i = this.items.length - 1; i >= 0; i--){
			item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
				continue;
			}

			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (i = this.containers.length - 1; i >= 0; i--){
				p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var className,
			o = that.options;

		if(!o.placeholder || o.placeholder.constructor === String) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[0] )
							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
							.removeClass("ui-sortable-helper");

					if ( nodeName === "tbody" ) {
						that._createTrPlaceholder(
							that.currentItem.find( "tr" ).eq( 0 ),
							$( "<tr>", that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === "tr" ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each(function() {
			$( "<td>&#160;</td>", that.document[ 0 ] )
				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
				.appendTo( targetTr );
		});
	},

	_contactContainers: function(event) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// get innermost container that intersects with item
		for (i = this.containers.length - 1; i >= 0; i--) {

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
				continue;
			}

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
					continue;
				}

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) {
			return;
		}

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			if (!this.containers[innermostIndex].containerCache.over) {
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating(this.currentItem);
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "clientX" : "clientY";

			for (j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
					continue;
				}
				if(this.items[j].item[0] === this.currentItem[0]) {
					continue;
				}

				cur = this.items[j].item.offset()[posProperty];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up": "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
				return;
			}

			if(this.currentContainer === this.containers[innermostIndex]) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
			this.currentContainer = this.containers[innermostIndex];

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

		//Add the helper to the DOM if that didn't happen already
		if(!helper.parents("body").length) {
			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
		}

		if(helper[0] === this.currentItem[0]) {
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
		}

		if(!helper[0].style.width || o.forceHelperSize) {
			helper.width(this.currentItem.width());
		}
		if(!helper[0].style.height || o.forceHelperSize) {
			helper.height(this.currentItem.height());
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this information
		// with an ugly IE fix
		if( this.offsetParent[0] === this.document[0].body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === "document" ? this.document.width() : this.window.width() - this.helperProportions.width - this.margins.left,
				(o.containment === "document" ? this.document.width() : this.window.height() || this.document[0].body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			ce = $(o.containment)[0];
			co = $(o.containment).offset();
			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== this.document[0] && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== this.document[0] && this.scrollParent[0] !== this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) {
					pageX = this.containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < this.containment[1]) {
					pageY = this.containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > this.containment[2]) {
					pageX = this.containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > this.containment[3]) {
					pageY = this.containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																// The absolute mouse position
				this.offset.click.top -													// Click offset (relative to the element)
				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter === this.counter) {
				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
			}
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) {
			this.placeholder.before(this.currentItem);
		}
		this._noFinalSort = null;

		if(this.helper[0] === this.currentItem[0]) {
			for(i in this._storedCSS) {
				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
					this._storedCSS[i] = "";
				}
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		}
		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for (i = this.containers.length - 1; i >= 0; i--){
			if (!noPropagation) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if(this._storedOpacity) {
			this.helper.css("opacity", this._storedOpacity);
		}
		if(this._storedZIndex) {
			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
		}

		this.dragging = false;

		if(!noPropagation) {
			this._trigger("beforeStop", event, this._uiHash());
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if(!noPropagation) {
			for (i=0; i < delayedTriggers.length; i++) {
				delayedTriggers[i].call(this, event);
			} //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});



}));
/*
 * 让TrackEvent支持可视化编辑
 */
h5.define('editor/H5EditorHelper', ["jquery","jquery-ui", "util/Keys"], function ($,ui, Keys) {

    var __plugins = {};

    function EditorHelper(app) {
        var _this = this;

        function _updateFunction(e) {

            var trackEvent = e.target;

            if (trackEvent.popcornTrackEvent && __plugins[trackEvent.type]) {
                __plugins[trackEvent.type].call(_this, trackEvent, app.media.popcorn.popcorn, $);
            }
        }

        //异步调用
        app.media.addEventListener("trackeventupdated", function (e) {
            window.setTimeout(_updateFunction, 0, e);
        });

        function blurActiveEl() {
            if (document.activeElement && document.activeElement.blur) {
                document.activeElement.blur();
            }
        }

        function calculateFinalPositions(event, ui, trackEvent, targetContainer, container, options) {
            var target = targetContainer.getBoundingClientRect(),
                height = container.clientHeight,
                width = container.clientWidth,
                top = ui.position.top,
                left = ui.position.left,
                targetHeight = target.height,
                targetWidth = target.width,
                minHeightPix = targetHeight * ((options.minHeight || 0) / 100),
                minWidthPix = targetWidth * ((options.minWidth || 0) / 100);

            top = Math.max(0, top);
            left = Math.max(0, left);
            height = Math.max(minHeightPix, height);
            width = Math.max(minWidthPix, width);

            if ((container.offsetTop + height) > targetHeight) {
                top = targetHeight - height;
            }

            if ((container.offsetLeft + width) > targetWidth) {
                left = targetWidth - width;
            }

            height = (height / targetHeight) * 100;
            width = (width / targetWidth) * 100;

            if (options.end) {
                options.end();
            }

            container.style.width = width + "%";
            container.style.height = height + "%";

            blurActiveEl();

            trackEvent.update({
                height: height,
                width: width,
                top: (top / targetHeight) * 100,
                left: (left / targetWidth) * 100
            });
        }

        _this.selectable = function (trackEvent, dragContainer) {

            var highlight = function () {

                var media,
                    manifestOptions,
                    track = trackEvent.track;

                if (!track || !track._media) {
                    return;
                }

                if (!trackEvent.manifest || !trackEvent.manifest.options) {
                    return;
                }

                //console.log('editor helper  ' + trackEvent.popcornOptions.title + '  ' + trackEvent.selected);

                if (app.media.paused && trackEvent.selected) {
                    var curTime = app.media.currentTime;


                    if (curTime < trackEvent.popcornOptions.start || curTime > trackEvent.popcornOptions.end) {
                        app.media.currentTime = trackEvent.popcornOptions.start;
                    }


                }

                media = track._media;
                manifestOptions = trackEvent.manifest.options;

                if ("zindex" in manifestOptions) {
                    var newZIndex = media.maxPluginZIndex + track.order;
                    if (trackEvent.selected) {
                        dragContainer.classList.add("track-event-selected");
                      //  dragContainer.style.zIndex = newZIndex + media.maxPluginZIndex;
                    } else {
                       // dragContainer.style.zIndex = newZIndex;
                        dragContainer.classList.remove("track-event-selected");
                    }
                }
                if (trackEvent.selected) {
                    app.editor.openTrackEventProperty(trackEvent);
                }
            };

            var onSelect = function (e) {
                e.stopPropagation();

                if (!e.shiftKey) {
                    app.media.deselectAllTrackEvents();
                }
                trackEvent.selected = true;




                // If the current open editor isn't a trackevent editor,
                // open an editor for this event
                //if (!butter.editor.currentEditor.getTrackEvent) {
                //    butter.editor.editTrackEvent(trackEvent);
                //}
            };

            var update = function () {
                //console.log('editor helper  ' + trackEvent.popcornOptions.title + ' update ');
               // dragContainer.removeEventListener("mousedown", onSelect, false);
                trackEvent.removeEventListener("trackeventselected", highlight);
                trackEvent.removeEventListener("trackeventdeselected", highlight);
                trackEvent.removeEventListener("trackeventupdated", update);
            };

            highlight();

            //console.log('editor helper  ' + trackEvent.popcornOptions.title + ' init ');
            dragContainer.addEventListener("mousedown", onSelect);
            trackEvent.addEventListener("trackeventselected", highlight);
            trackEvent.addEventListener("trackeventdeselected", highlight);
            trackEvent.addEventListener("trackeventupdated", update);
        };

        /**
         * Member: draggable
         *
         * Makes a container draggable using jQueryUI
         *
         * @param {TrackEvent} trackEvent: The trackEvent to update when position changes
         * @param {DOMElement} dragContainer: the container which to apply draggable to
         * @param {media} The current media's target element in Butter ( parent container )
         * @param {Object} extra options to apply to the draggable call
         *                 Options are:
         *                    {DOMElement} handle: Restrict drag start event to this element
         *                    {Function} start: Function to execute on drag start event
         *                    {Function} end: Function to execute on drag end event
         */
        _this.draggable = function (trackEvent, dragContainer, targetContainer, options) {
            if ($(dragContainer).data("draggable")) {
                return;
            }

            //var iframeCover = targetContainer.querySelector(".butter-iframe-fix");

            options = options || {};

            var el = document.createElement("div"),
                onBlur,
                onMouseDown,
                onMouseUp,
                onDblClick,
                tooltipElement,
                editable = options.editable,
                contentContainer = options.contentContainer,
                oldText = "",
                textArea;

            if (editable) {

                textArea = contentContainer.querySelector(".inputControl");
                if (textArea) {
                    contentContainer.removeChild(textArea);
                }
                //if (!textArea) {
                    textArea = document.createElement("textArea");
                    textArea.rows = 1;
                    textArea.classList.add("inputControl");
                    dragContainer.classList.add("content-editable");
                    contentContainer.appendChild(textArea);

                    textArea.addEventListener("input", function () {
                        if (textArea.value.length > 139) {
                            textArea.value = textArea.value.substring(0, 140);
                        }
                        textArea.style.height = "auto";
                        textArea.style.height = textArea.scrollHeight + "px";
                    });

                    textArea.addEventListener("keydown", function (e) {
                        if (e.keyCode === Keys.ENTER && !e.shiftKey) {
                            textArea.blur();
                            //if (oldText == textArea.value) {
                                onBlur();
                           // }
                        }
                    });

                    textArea.addEventListener("blur", function () {
                        if (textArea.value.replace(/^\s+|\s+$/g, "").length == 0) {
                            textArea.value = 'Double click to add subtitle.';
                        }
                        trackEvent.update({
                            text: textArea.value
                        });
                        var tEle = $('.popcorn-text.on');
                        var vEle = $('#h5-video-panel');
                        if (tEle.height() + tEle.position().top > vEle.height()) {
                            var top =  vEle.height() - tEle.height() - 1;
                            tEle.css("top", top);
                            var opt = {
                                position: "custom",
                                top: (top / vEle.height()) * 100,
                                left: tEle.position().left / vEle.width() * 100,
                                width: tEle.width() / vEle.width() * 100
                            }
                            trackEvent.update(opt);
                        }
                    });
               // }
            }

            if (!options.disableTooltip) {
                tooltipElement = document.createElement("div");
                tooltipElement.innerHTML = options.tooltip || "Double Click to Edit";
                tooltipElement.classList.add("h5tooltip");
                tooltipElement.classList.add("h5tooltip-middle");
                dragContainer.appendChild(tooltipElement);
                tooltipElement.style.marginTop = "-" + (tooltipElement.offsetHeight / 2) + "px";
            }

            onBlur = function () {
                if (tooltipElement) {
                    tooltipElement.classList.remove("tooltip-off");
                }
                el.addEventListener("dblclick", onDblClick);
                document.removeEventListener("mousedown", onBlur, false);
                el.style.display = "";
                dragContainer.classList.remove("track-event-editing");
            };
            onDblClick = function () {
                if (tooltipElement) {
                    tooltipElement.classList.add("tooltip-off");
                }
                el.removeEventListener("dblclick", onDblClick, false);
                document.addEventListener("mousedown", onBlur);
                el.style.display = "none";
                dragContainer.classList.add("track-event-editing");

                if (editable) {
                    textArea.value = trackEvent.popcornOptions.text;
                    textArea.style.height = "auto";
                    textArea.style.height = textArea.scrollHeight + "px";
                    textArea.select();
                    oldText = textArea.value;
                }
            };
            el.classList.add("ui-draggable-handle");
            if (options.editable !== false) {
                el.addEventListener("dblclick", onDblClick);
            }

            dragContainer.appendChild(el);

            onMouseDown = function () {
                document.addEventListener("mouseup", onMouseUp);
                el.removeEventListener("mouseup", onMouseDown, false);
                dragContainer.style.overflow = "hidden";
            };

            onMouseUp = function () {
                document.removeEventListener("mouseup", onMouseUp, false);
                el.addEventListener("mouseup", onMouseDown);
                dragContainer.style.overflow = "";
            };

            // This ensures the height of the element is not increased
            el.addEventListener("mousedown", onMouseDown);

            $(dragContainer).draggable({
                handle: ".ui-draggable-handle",
                containment: "parent",
                start: function () {
                   // iframeCover.style.display = "block";

                    // Open the editor
                    //butter.editor.editTrackEvent(trackEvent);

                    if (options.start) {
                        options.start();
                    }
                },
                stop: function (event, ui) {
                    //iframeCover.style.display = "none";

                    calculateFinalPositions(event, ui, trackEvent, targetContainer, dragContainer, options);
                }
            });

            return {
                edit: onDblClick,
                cancel: onBlur
            };
        };

        /**
         * Member: resizable
         *
         * Makes a container resizable using jQueryUI
         *
         * @param {TrackEvent} trackEvent: The trackEvent to update when size changes
         * @param {DOMElement} resizeContainer: the container which to apply resizable to
         * @param {media} The current media's target element in Butter ( parent container )
         * @param {Object} extra options to apply to the resizeable call
         *                 Options are:
         *                    {String} handlePositions: describes where to position resize handles ( i.e. "n,s,e,w" )
         *                              - Recommended that this option is specified due to a bug in z-indexing with
         *                                jQueryUI Resizable.
         *                    {Function} start: Function to execute on resize start event
         *                    {Function} end: Function to execute on resize end event
         *                    {Number} minWidth: Minimum width that the resizeContainer should be
         *                    {Number} minHeight: Minimum height that the resizeContainer should be
         */
        _this.resizable = function (trackEvent, resizeContainer, targetContainer, options) {
            if ($(resizeContainer).data("resizable")) {
                return;
            }

            var iframeCover = targetContainer.querySelector(".h5-iframe-fix"),
                handlePositions = options.handlePositions;

            function createHelper(suffix) {
                var el = document.createElement("div");
                el.classList.add("ui-resizable-handle");
                el.classList.add("ui-resizable-" + suffix);
                return el;
            }

            if (handlePositions.search(/\bn\b/) > -1) {
                resizeContainer.appendChild(createHelper("top"));
            }
            if (handlePositions.search(/\bs\b/) > -1) {
                resizeContainer.appendChild(createHelper("bottom"));
            }
            if (handlePositions.search(/\bw\b/) > -1) {
                resizeContainer.appendChild(createHelper("left"));
            }
            if (handlePositions.search(/\be\b/) > -1) {
                resizeContainer.appendChild(createHelper("right"));
            }

            options = options || {};

            $(resizeContainer).resizable({
                handles: options.handlePositions,
                zIndex: options.zIndex || 1000,
                start: function () {
                    //iframeCover.style.display = "block";

                    // Open the editor
                    //butter.editor.editTrackEvent(trackEvent);

                    if (options.start) {
                        options.start();
                    }
                },
                containment: "parent",
                stop: function (event, ui) {
                   // iframeCover.style.display = "none";

                    calculateFinalPositions(event, ui, trackEvent, targetContainer, resizeContainer, options);
                }
            });
        };

        /**
         * Member: contentEditable
         *
         * Makes a container's content editable using contenteditable
         *
         * @param {TrackEvent} trackEvent: The trackEvent to update when content changes
         * @param {DOMElement} contentContainer: the container which to listen for changes and set as editable
         */
        _this.contentEditable = function (trackEvent, container, contentContainer) {
            if (!contentContainer ) {
                return;
            }
            var textArea = document.createElement("textArea");
            textArea.rows = 1;
            container.classList.add("content-editable");
            contentContainer.appendChild(textArea);
            //_this.inputTextArea = textArea;

            var oldText = "";

            container.addEventListener("dblclick", function () {
                textArea.value = trackEvent.popcornOptions.text;
                textArea.style.height = "auto";
                textArea.style.height = textArea.scrollHeight + "px";
                textArea.select();
                oldText = textArea.value;
            });

            textArea.addEventListener("input", function () {
                textArea.style.height = "auto";
                textArea.style.height = textArea.scrollHeight + "px";
            });

            textArea.addEventListener("keydown", function (e) {
                if (e.keyCode === Keys.ENTER && !e.shiftKey) {
                    textArea.blur();
                    if (oldText == textArea.value) {
                        document.dispatchEvent("mousedown");
                    }
                }
            });

            textArea.addEventListener("change", function () {
                trackEvent.update({
                    text: textArea.value
                });
            });
        };

        //function sendFile(file, trackEvent) {
        //    var fd = new FormData();
        //    fd.append("image", file);

        //    XHR.put("/api/image", fd, function (data) {
        //        if (!data.error && data.url) {
        //            if (trackEvent) {
        //                trackEvent.update({ src: data.url, title: file.name });
        //            }

        //            butter.dispatch("droppable-succeeded", {
        //                url: data.url,
        //                trackEvent: trackEvent
        //            });
        //        } else {
        //            butter.dispatch("droppable-upload-failed", data.error);
        //        }
        //    });

        //    if (trackEvent) {
        //        butter.editor.editTrackEvent(trackEvent);
        //    }
        //}

        ///**
        // * Member: uploader
        // *
        // * Make a container a file uploader button
        // *
        // * @param {TrackEvent} trackEvent: The trackEvent to update when content changes
        // * @param {DOMElement} dropContainer: The container that listens for the click
        // */

        //_this.uploader = function (trackEvent, dropContainer) {
        //    var fileInput = document.createElement("input");
        //    fileInput.type = "file";
        //    fileInput.accept = "image/*";

        //    dropContainer.addEventListener("click", function () {
        //        fileInput.click();
        //    });

        //    fileInput.addEventListener("change", function () {
        //        sendFile(fileInput.files[0], trackEvent);
        //    });
        //};

        /**
         * Member: droppable
         *
         * Make a container listen for drop events for loading images from a local machine
         *
         * @param {TrackEvent} trackEvent: The trackEvent to update when content changes
         * @param {DOMElement} dropContainer: The container that listens for the drop events
         */

        _this.droppable = function (trackEvent, dropContainer) {

            dropContainer.addEventListener("dragover", function (e) {
                e.preventDefault();
                dropContainer.classList.add("h5-dragover");
            });

            dropContainer.addEventListener("dragleave", function (e) {
                e.preventDefault();
                dropContainer.classList.remove("h5-dragover");
            });

            dropContainer.addEventListener("mousedown", function (e) {
                // Prevent being able to drag the images inside and re drop them
                e.preventDefault();
            });

            dropContainer.addEventListener("drop", function (e) {

                e.preventDefault();
                e.stopPropagation();

                dropContainer.classList.remove("h5-dragover");

                if (!e.dataTransfer || !e.dataTransfer.files || !e.dataTransfer.files[0]) {
                    h5.dispatch("droppable-unsupported");
                    return;
                }

                sendFile(e.dataTransfer.files[0], trackEvent);
            });
        };

        _this.addPlugin = function (plugin, callback) {
            __plugins[plugin] = callback;
        };

    }

    return EditorHelper;

});

h5.define("util/ColorSelector", ["jquery"], function ($) {

    var ColorSelector = function (container, callback) {
        var container = $(container).get(0);
        container.colorSelector = this;


        var cs = this;

        $(container).html('<div class="color-selector"><div class="color"></div><div class="wheel"></div><div class="overlay"></div><div class="h-marker marker"></div><div class="sl-marker marker"></div></div>');
        var e = $('.color-selector', container);
        cs.wheel = $('.wheel', container).get(0);
        // Dimensions
        cs.radius = 84;
        cs.square = 100;
        cs.width = 194;

        // Fix background PNGs in IE6
        if (navigator.appVersion.match(/MSIE [0-6]\./)) {
            $('*', e).each(function () {
                if (this.currentStyle.backgroundImage != 'none') {
                    var image = this.currentStyle.backgroundImage;
                    image = this.currentStyle.backgroundImage.substring(5, image.length - 2);
                    $(this).css({
                        'backgroundImage': 'none',
                        'filter': "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=crop, src='" + image + "')"
                    });
                }
            });
        }

        /**
         * Link to the given element(s) or callback.
         */
        cs.linkTo = function (callback) {
            // Unbind previous nodes
            if (typeof cs.callback == 'object') {
                $(cs.callback).unbind('keyup', cs.updateValue);
            }

            // Reset color
            cs.color = null;

            // Bind callback or elements
            if (typeof callback == 'function') {
                cs.callback = callback;
            }
            else if (typeof callback == 'object' || typeof callback == 'string') {
                cs.callback = $(callback);
                cs.callback.bind('keyup', cs.updateValue);
                if (cs.callback.get(0).value) {
                    cs.setColor(cs.callback.get(0).value);
                }
            }
            return this;
        }
        cs.updateValue = function (event) {
            if (this.value && this.value != cs.color) {
                cs.setColor(this.value);
            }
        }

        /**
         * Change color with HTML syntax #123456
         */
        cs.setColor = function (color) {
            var unpack = cs.unpack(color);
            if (cs.color != color && unpack) {
                cs.color = color;
                cs.rgb = unpack;
                cs.hsl = cs.RGBToHSL(cs.rgb);
                cs.updateDisplay();
            }
            return this;
        }

        /**
         * Change color with HSL triplet [0..1, 0..1, 0..1]
         */
        cs.setHSL = function (hsl) {
            cs.hsl = hsl;
            cs.rgb = cs.HSLToRGB(hsl);
            cs.color = cs.pack(cs.rgb);
            cs.updateDisplay();
            return this;
        }

        /////////////////////////////////////////////////////

        /**
         * Retrieve the coordinates of the given event relative to the center
         * of the widget.
         */
        cs.widgetCoords = function (event) {
            var x, y;
            var el = event.target || event.srcElement;
            var reference = cs.wheel;

            if (typeof event.offsetX != 'undefined') {
                // Use offset coordinates and find common offsetParent
                var pos = { x: event.offsetX, y: event.offsetY };

                // Send the coordinates upwards through the offsetParent chain.
                var e = el;
                while (e) {
                    e.mouseX = pos.x;
                    e.mouseY = pos.y;
                    pos.x += e.offsetLeft;
                    pos.y += e.offsetTop;
                    e = e.offsetParent;
                }

                // Look for the coordinates starting from the wheel widget.
                var e = reference;
                var offset = { x: 0, y: 0 }
                while (e) {
                    if (typeof e.mouseX != 'undefined') {
                        x = e.mouseX - offset.x;
                        y = e.mouseY - offset.y;
                        break;
                    }
                    offset.x += e.offsetLeft;
                    offset.y += e.offsetTop;
                    e = e.offsetParent;
                }

                // Reset stored coordinates
                e = el;
                while (e) {
                    e.mouseX = undefined;
                    e.mouseY = undefined;
                    e = e.offsetParent;
                }
            }
            else {
                // Use absolute coordinates
                var pos = cs.absolutePosition(reference);
                x = (event.pageX || 0 * (event.clientX + $('html').get(0).scrollLeft)) - pos.x;
                y = (event.pageY || 0 * (event.clientY + $('html').get(0).scrollTop)) - pos.y;
            }
            // Subtract distance to middle
            return { x: x - cs.width / 2, y: y - cs.width / 2 };
        }

        /**
         * Mousedown handler
         */
        cs.mousedown = function (event) {
            // Capture mouse
            if (!document.dragging) {
                $(document).bind('mousemove', cs.mousemove).bind('mouseup', cs.mouseup);
                document.dragging = true;
            }

            // Check which area is being dragged
            var pos = cs.widgetCoords(event);
            cs.circleDrag = Math.max(Math.abs(pos.x), Math.abs(pos.y)) * 2 > cs.square;

            // Process
            cs.mousemove(event);
            return false;
        }

        /**
         * Mousemove handler
         */
        cs.mousemove = function (event) {
            // Get coordinates relative to color picker center
            var pos = cs.widgetCoords(event);

            // Set new HSL parameters
            if (cs.circleDrag) {
                var hue = Math.atan2(pos.x, -pos.y) / 6.28;
                if (hue < 0) hue += 1;
                cs.setHSL([hue, cs.hsl[1], cs.hsl[2]]);
            }
            else {
                var sat = Math.max(0, Math.min(1, -(pos.x / cs.square) + .5));
                var lum = Math.max(0, Math.min(1, -(pos.y / cs.square) + .5));
                cs.setHSL([cs.hsl[0], sat, lum]);
            }
            return false;
        }

        /**
         * Mouseup handler
         */
        cs.mouseup = function () {
            // Uncapture mouse
            $(document).unbind('mousemove', cs.mousemove);
            $(document).unbind('mouseup', cs.mouseup);
            document.dragging = false;
        }

        /**
         * Update the markers and styles
         */
        cs.updateDisplay = function () {
            // Markers
            var angle = cs.hsl[0] * 6.28;
            $('.h-marker', e).css({
                left: Math.round(Math.sin(angle) * cs.radius + cs.width / 2) + 'px',
                top: Math.round(-Math.cos(angle) * cs.radius + cs.width / 2) + 'px'
            });

            $('.sl-marker', e).css({
                left: Math.round(cs.square * (.5 - cs.hsl[1]) + cs.width / 2) + 'px',
                top: Math.round(cs.square * (.5 - cs.hsl[2]) + cs.width / 2) + 'px'
            });

            // Saturation/Luminance gradient
            $('.color', e).css('backgroundColor', cs.pack(cs.HSLToRGB([cs.hsl[0], 1, 0.5])));

            // Linked elements or callback
            if (typeof cs.callback == 'object') {
                // Set background/foreground color
                $(cs.callback).css({
                    backgroundColor: cs.color,
                    color: cs.hsl[2] > 0.5 ? '#000' : '#fff'
                });

                // Change linked value
                $(cs.callback).each(function () {
                    if (this.value && this.value != cs.color) {
                        this.value = cs.color;
                    }
                });
            }
            else if (typeof cs.callback == 'function') {
                cs.callback.call(cs, cs.color);
            }
        }

        /**
         * Get absolute position of element
         */
        cs.absolutePosition = function (el) {
            var r = { x: el.offsetLeft, y: el.offsetTop };
            // Resolve relative to offsetParent
            if (el.offsetParent) {
                var tmp = cs.absolutePosition(el.offsetParent);
                r.x += tmp.x;
                r.y += tmp.y;
            }
            return r;
        };

        /* Various color utility functions */
        cs.pack = function (rgb) {
            var r = Math.round(rgb[0] * 255);
            var g = Math.round(rgb[1] * 255);
            var b = Math.round(rgb[2] * 255);
            return '#' + (r < 16 ? '0' : '') + r.toString(16) +
                   (g < 16 ? '0' : '') + g.toString(16) +
                   (b < 16 ? '0' : '') + b.toString(16);
        }

        cs.unpack = function (color) {
            if (color.length == 7) {
                return [parseInt('0x' + color.substring(1, 3)) / 255,
                  parseInt('0x' + color.substring(3, 5)) / 255,
                  parseInt('0x' + color.substring(5, 7)) / 255];
            }
            else if (color.length == 4) {
                return [parseInt('0x' + color.substring(1, 2)) / 15,
                  parseInt('0x' + color.substring(2, 3)) / 15,
                  parseInt('0x' + color.substring(3, 4)) / 15];
            }
        }

        cs.HSLToRGB = function (hsl) {
            var m1, m2, r, g, b;
            var h = hsl[0], s = hsl[1], l = hsl[2];
            m2 = (l <= 0.5) ? l * (s + 1) : l + s - l * s;
            m1 = l * 2 - m2;
            return [this.hueToRGB(m1, m2, h + 0.33333),
                this.hueToRGB(m1, m2, h),
                this.hueToRGB(m1, m2, h - 0.33333)];
        }

        cs.hueToRGB = function (m1, m2, h) {
            h = (h < 0) ? h + 1 : ((h > 1) ? h - 1 : h);
            if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
            if (h * 2 < 1) return m2;
            if (h * 3 < 2) return m1 + (m2 - m1) * (0.66666 - h) * 6;
            return m1;
        }

        cs.RGBToHSL = function (rgb) {
            var min, max, delta, h, s, l;
            var r = rgb[0], g = rgb[1], b = rgb[2];
            min = Math.min(r, Math.min(g, b));
            max = Math.max(r, Math.max(g, b));
            delta = max - min;
            l = (min + max) / 2;
            s = 0;
            if (l > 0 && l < 1) {
                s = delta / (l < 0.5 ? (2 * l) : (2 - 2 * l));
            }
            h = 0;
            if (delta > 0) {
                if (max == r && max != g) h += (g - b) / delta;
                if (max == g && max != b) h += (2 + (b - r) / delta);
                if (max == b && max != r) h += (4 + (r - g) / delta);
                h /= 6;
            }
            return [h, s, l];
        }

        // Install mousedown handler (the others are set on the document on-demand)
        $('*', e).mousedown(cs.mousedown);

        // Init color
        cs.setColor('#000000');

        // Set linked elements/callback
        if (callback) {
            cs.linkTo(callback);
        }
    };


    return ColorSelector;
});




/*
 * 提示
 */
h5.define('util/H5Tooltip', [], function () {
    var __tooltipClass = "h5tooltip",
        __tooltipOffClass = "tooltip-off",
        __toolTipNoHoverClass = "tooltip-no-hover",
        __toolTipOnNoHoverClass = "tooltip-no-transition-on",
        _registeredTooltips = {},
        ToolTipObj,
        ToolTip;

    function register(tooltip) {
        _registeredTooltips[tooltip.name] = tooltip;
    }

    function isRegistered(name) {
        return !!_registeredTooltips[name];
    }

    ToolTipObj = function (options) {
        if (options && options.name && isRegistered(options.name)) {
            return;
        }

        var parentElement,
            name,
            message,
            top,
            marginTop,
            left,
            error,
            destroyed = false,
            tooltipElement = document.createElement("div");

        tooltipElement.classList.add(__tooltipClass);
        if (options.name) {
            tooltipElement.classList.add(options.name);
        }

        if (!options.hideArrow) {
            tooltipElement.classList.add("arrow");
        }

        Object.defineProperty(this, "message", {
            get: function () {
                return message;
            },
            set: function (newMessage) {
                if (newMessage && typeof newMessage === "string") {
                    message = newMessage;
                    tooltipElement.innerHTML = newMessage;
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "hidden", {
            get: function () {
                return !tooltipElement.classList.contains(__tooltipOffClass);
            },
            set: function (hidden) {
                if (hidden || hidden === undefined) {
                    tooltipElement.classList.add(__tooltipOffClass);
                } else {
                    tooltipElement.classList.remove(__tooltipOffClass);
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "hover", {
            get: function () {
                return !tooltipElement.classList.contains(__toolTipNoHoverClass);
            },
            set: function (hover) {
                if (hover || hover === undefined) {
                    tooltipElement.classList.remove(__toolTipNoHoverClass);
                } else {
                    tooltipElement.classList.add(__toolTipNoHoverClass);
                    tooltipElement.classList.add(__toolTipOnNoHoverClass);
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "top", {
            get: function () {
                return top;
            },
            set: function (newTop) {
                if (parentElement && newTop && typeof newTop === "string") {
                    top = newTop;
                    tooltipElement.style.top = newTop;
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "marginTop", {
            get: function () {
                return marginTop;
            },
            set: function (newMarginTop) {
                if (parentElement && newMarginTop && typeof newMarginTop === "string") {
                    marginTop = newMarginTop;
                    tooltipElement.style.marginTop = newMarginTop;
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "left", {
            get: function () {
                return left;
            },
            set: function (newLeft) {
                if (parentElement && newLeft && typeof newLeft === "string") {
                    left = newLeft;
                    tooltipElement.style.left = newLeft;
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "tooltipElement", {
            get: function () {
                return tooltipElement;
            },
            enumerable: true
        });

        Object.defineProperty(this, "parent", {
            get: function () {
                return parentElement;
            },
            set: function (newParent) {
                if (newParent) {
                    // Tooltip的父元素必须具有这些定位属性
                    if (["absolute", "relative", "fixed"].indexOf(getComputedStyle(newParent).getPropertyValue("position")) === -1) {
                        newParent.style.position = "relative";
                    }

                    parentElement = newParent;
                    parentElement.appendChild(tooltipElement);
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "name", {
            get: function () {
                return name;
            },
            enumerable: true
        });

        Object.defineProperty(this, "error", {
            get: function () {
                return error;
            },
            set: function (value) {
                error = !!value;

                if (error) {
                    tooltipElement.classList.add("tooltip-error");
                } else {
                    tooltipElement.classList.remove("tooltip-error");
                }
            },
            enumerable: true
        });

        Object.defineProperty(this, "destroyed", {
            get: function () {
                return destroyed;
            },
            enumerable: true
        });

        this.destroy = function () {
            if (!destroyed) {
                if (parentElement && tooltipElement.parentNode === parentElement) {
                    parentElement.removeChild(tooltipElement);
                }
                _registeredTooltips[name] = undefined;
                destroyed = true;
            }
        };

        this.parent = options.element;
        this.top = options.top;
        this.marginTop = options.marginTop;
        this.left = options.left || "50%";
        this.message = options.message || parentElement.getAttribute("data-tooltip") || parentElement.getAttribute("title") || "";
        this.hidden = options.hidden;
        this.hover = options.hover;
        this.error = options.error;

        name = options.name;

        if (name) {
            register(this);
        }

        return this;
    };

    ToolTip = {
        create: function (options) {
            return new ToolTipObj(options);
        },
        apply: function (rootElement) {
            var elements,
                i,
                l;

            rootElement = rootElement || document;
            elements = rootElement.querySelectorAll("[data-tooltip]");

            for (i = 0, l = elements.length; i < l; i++) {
                ToolTip.create({
                    element: elements[i]
                });
            }
        },
        get: function (title) {
            return _registeredTooltips[title];
        }
    };
    return ToolTip;
});


h5.define('util/H5Textbox', [], function () {

    function __highlight(e) {
        var input = e.target;
        input.select();
        input.removeEventListener("focus", __highlight, false);
    }

    function __ignoreMouseUp(e) {
        e.preventDefault();
        var input = e.target;
        input.removeEventListener("mouseup", __ignoreMouseUp, false);
    }

    function __addListeners(input) {
        input.addEventListener("focus", __highlight);
        input.addEventListener("mouseup", __ignoreMouseUp);
    }

    return {
        applyTo: function (input, options) {
            if (!(input && (
                    input.type === "text" ||
                    input.type === "textarea" ||
                    input.type === "url")
                 )) {
                throw "Textbox: Expected an input element of type text";
            }

            options = options || {};
            input.readOnly = !!options.readOnly;

            input.addEventListener("blur", function (e) {
                __addListeners(e.target);
            });

            __addListeners(input);

            return input;
        }
    };

});
/*
 * 可视化编辑器基类
 */
h5.define('editor/BaseEditor', ["jquery", "util/Object", "util/ColorSelector", "util/H5Scrollbar", "util/H5Tooltip", "util/H5Textbox", ],
  function ($, Obj, ColorSelector, Scrollbars, ToolTip, H5Textbox) {


      var _colorHexCodes = {
              "black": "#000000",
              "silver": "#c0c0c0",
              "gray": "#808080",
              "white": "#ffffff",
              "maroon": "#800000",
              "red": "#ff00000",
              "purple": "#800080",
              "fuchsia": "#ff00ff",
              "green": "#008000",
              "lime": "#00ff00",
              "olive": "#808000",
              "yellow": "#ffff00",
              "navy": "#000080",
              "blue": "#0000ff",
              "teal": "#008080",
              "aqua": "#00ffff"
          };

      var BaseEditor = Obj.extend({
          init: function (rootElement, app, events) {

              this._super();

              this.app = app;
              this.rootElement = rootElement;
              this.parentElement = null;
              this._events = events;


              this._errorMessageContainer;

              if (!this._errorMessageContainer && rootElement) {
                  this._errorMessageContainer = rootElement.querySelector("div.error-message");
              }






              var _this = this;
              window.addEventListener("resize", function () {
                  if (_this.scrollbar) {
                      _this.scrollbar.update();
                  }
              });

          },
            /**
              * 打开编辑器
              *
              * @param {DOMElement} parentElement: 父级元素
              */
          open: function (parentElement) {

              this.parentElement = parentElement;
              this.parentElement.appendChild(this.rootElement);

              if (this.scrollbar) {
                  this.scrollbar.update();
              }

              if (this._events.open) {
                  this._events.open.apply(this, arguments);
              }

              this.addTooltips();

              this.dispatchEvent("open");
          },
             /**
               * 关闭编辑器
               *
               */
          close : function () {
              this.rootElement.parentNode.removeChild(this.rootElement);

              if (this._events.close) {
                  this._events.close.apply(this, arguments);
              }

              this.dispatchEvent("closed");
          },
          attachColorChangeHandler : function (element, trackEvent, propertyName, callback) {

              var colorPickerElement = element.querySelector(".color-picker"),
                  inputElement = element.querySelector("input"),
                  initialValue = inputElement.value,
                  self = this,
                  colorToggle = element.querySelector(".color-picker-toggle"),
                  colorPicker = new ColorSelector(colorPickerElement, {
                      callback: function () { },
                      height: 195,
                      width: 195
                  });

              function validateColorValue(value) {
                  var message,
                      i;

                  if (value.indexOf("#") === -1) {
                      message = (lang[_curLang].colorUpdateError) + " ";
                      for (i in _colorHexCodes) {
                          if (_colorHexCodes.hasOwnProperty(i)) {
                              if (i === value.toLowerCase()) {
                                  // Valid colour found.
                                  return "";
                              } else {
                                  message += i + ", ";
                              }
                          }
                      }

                      return message.substring(0, message.lastIndexOf(",")) + ".";
                  } else if (!value.match(/^#(?:[0-9a-fA-F]{3}){1,2}$/)) {
                      return lang[_curLang].colorValueError;
                  }

                  return "";
              }

              function updateColor(value) {
                  var message = validateColorValue(value),
                      updateOptions = {};

                  // This is a valid colour
                  if (!message) {
                      inputElement.value = value;
                      if (_colorHexCodes[value]) {
                          // Colour picker only works with hex values, do not send named colours.
                          colorPicker.setColor(_colorHexCodes[value]);
                      } else {
                          colorPicker.setColor(value);
                      }
                      colorToggle.style.background = value;
                      self.setErrorState(false);
                  }

                  updateOptions[propertyName] = value;
                  if (callback) {
                      callback(trackEvent, updateOptions, message, propertyName);
                  } else {
                      trackEvent.update(updateOptions);
                  }
              }

              // Set default, but don't fire any callbacks yet.
              colorPicker.setColor(initialValue);
              colorToggle.style.background = initialValue;
              // Now we can setup the callback.
              colorPicker.linkTo(function (value) {
                  if (inputElement.value !== value) {
                      updateColor(value);
                  }
              });

              inputElement.addEventListener("change", function () {
                  updateColor(inputElement.value);
              });

              function onMousedown(e) {
                  e.stopPropagation();
                  e.preventDefault();
                  window.removeEventListener("mousedown", onMousedown, true);
                  updateColor(inputElement.value);
                  inputElement.blur();
                  colorPickerElement.classList.add("hidden");
              }

              function onMouseover() {
                  colorPickerElement.removeEventListener("mouseover", onMouseover);
                  inputElement.removeEventListener("mouseover", onMouseover);
                  colorPickerElement.addEventListener("mouseout", onMouseout);
                  inputElement.addEventListener("mouseout", onMouseout);
                  window.removeEventListener("mousedown", onMousedown, true);
              }

              function onMouseout() {
                  colorPickerElement.addEventListener("mouseover", onMouseover);
                  inputElement.addEventListener("mouseover", onMouseover);
                  colorPickerElement.removeEventListener("mouseout", onMouseout);
                  inputElement.removeEventListener("mouseout", onMouseout);
                  window.addEventListener("mousedown", onMousedown, true);
              }

              function onFocus() {
                  colorPickerElement.classList.remove("hidden");
              }

              inputElement.addEventListener("focus", onFocus);
              colorPickerElement.addEventListener("mouseover", onMouseover);
              inputElement.addEventListener("mouseover", onMouseover);

              colorToggle.addEventListener("click", function () {
                  inputElement.focus();
                  window.addEventListener("mousedown", onMousedown, true);
                  inputElement.addEventListener("mouseout", onMouseout);
              });
          },
            /**
              * 添加滚动条
              *
              * 参数:
              *    outer:      外层元素
              *    inner:      内层元素
              *    container:  追加滚动条的容器元素.
              */
          addScrollbar : function (options) {
              var innerDefault = this.rootElement.querySelector(".content");

              options = options || innerDefault && {
                  inner: innerDefault,
                  outer: this.rootElement.querySelector(".wrapper") || innerDefault.parentNode,
                  appendTo: this.rootElement.querySelector(".h5-editor-body") || this.rootElement
              };

              if (!options) {
                  return;
              }

              this.scrollbar = new Scrollbars.Vertical(options.outer, options.inner);
              options.appendTo.appendChild(this.scrollbar.element);

              this.scrollbar.update();

              return this.scrollBar;
          },
          /**
             *
             *  添加提示信息
             */
          addTooltips : function () {
              ToolTip.apply(this.rootElement);
          },
          /**
              * 创建Tooltip
              *
              *
              * @param {DOMElement} element: 关联元素.
              * @param {Object} options: 配置:
              *                   name: Tooltip名称.
              *                   element: Tooltip的定位元素.
              *                   message: 提示消息.
              *                   top: 在元素中的 css top属性.
              *                   left: 在元素中的 css left属性.
              *                   hidden: 是否隐藏.
              *                   hover: 鼠标位于其上时的处理函数.
              */
          createTooltip : function (element, options) {
              var tooltip;

              if (options && options.name) {
                  ToolTip.create(options);

                  tooltip = ToolTip.get(options.name);

                  element.addEventListener("focus", function () {
                      tooltip.hidden = false;
                  });
                  element.addEventListener("blur", function () {
                      tooltip.hidden = true;
                  });
              }
          },
          /**
           * Member: 包裹输入控件
           *           *
           * @param {DOMElement} element: Input元素
           * @param {Object} options: 配置：
           *                   readOnly: 是否只读.
           */
          wrapTextInputElement : function (element, options) {
              return H5Textbox.applyTo(element, options);
          },
            /**
               * Member: 设置错误状态
               *
               */
          setErrorState : function (message) {
              if (message && this._errorMessageContainer) {
                  this._errorMessageContainer.innerHTML = message;
                  this._errorMessageContainer.parentNode.style.height = this._errorMessageContainer.offsetHeight + "px";
                  this._errorMessageContainer.parentNode.style.visibility = "visible";
                  this._errorMessageContainer.parentNode.classList.add("open");
              }
              else {
                  this._errorMessageContainer.innerHTML = "";
                  this._errorMessageContainer.parentNode.style.height = "";
                  this._errorMessageContainer.parentNode.style.visibility = "";
                  this._errorMessageContainer.parentNode.classList.remove("open");
              }
          },

          setErrorMessageContainer : function (messageContainer) {
              this._errorMessageContainer = messageContainer;
          }

      });


      return BaseEditor;

  });

h5.define('templates/TrackEventEditorLayout', [], function () {
    return '<div class="trackevent-warning">\
  <strong>' + lang[_curLang].warning + '</strong> <span class="trackevent-warning-message"></span>\
</div>\
\
<fieldset class="trackevent-property default input">\
  <label class="property-name"></label>\
  <div class="info_textbox"><input class="value" type="text" title="' + lang[_curLang].pressEnter + '" /></div>\
</fieldset>\
\
<fieldset class="trackevent-property default input range">\
  <div class="h5-editor-inline slider-container">\
    <label class="property-name"></label>\
    <div>\
      <div class="h5-slider">\
        <span class="h5-slider-scrubber"></span>\
        <label class="slider-start"></label>\
        <div class="h5-tooltip h5-slider-tooltip tooltip-no-hover"></div>\
        <label class="slider-end"></label>\
      </div>\
    </div>\
  </div>\
</fieldset>\
\
<fieldset class="trackevent-property default input units">\
  <label class="property-name"></label>\
  <div class="h5-form-append">\
    <div class="info_textbox"><input onpaste="return false"  class="value" type="text" title="' + lang[_curLang].pressEnter + '" style="ime-mode: disabled;" />\
    <span class="h5-unit"></span></div>\
  </div>\
</fieldset>\
\
<fieldset class="trackevent-property default input checkbox">\
  <label class="h5-form-checkbox">\
    <input type="checkbox" class="value" style="margin-left:-32px;"/>\
    <span class="property-name" style=""></span>\
  </label>\
</fieldset>\
\
<fieldset class="trackevent-property default input color">\
  <label class="property-name"></label>\
  <div class="h5-form-append">\
    <div class="info_textbox"><input class="value" onpaste="return false" type="text" style="ime-mode: disabled;" />\
    <span class="color-picker-toggle h5-unit"></span></div>\
  </div>\
  <div class="color-picker hidden"></div>\
</fieldset>\
\
<fieldset class="trackevent-property select">\
  <label class="property-name"></label>\
  <div class="info_textbox"><select>\
  </select></div>\
</fieldset>\
\
<fieldset class="trackevent-property targets">\
  <label class="property-name">' + lang[_curLang].target + '</label>\
  <div class="info_textbox"><select data-manifest-key="target">\
    <option class="default-target-option" value="' + lang[_curLang].mediaElement + '">' + lang[_curLang].mediaElement + '</option>\
  </select></div>\
</fieldset>\
\
<fieldset class="trackevent-property textarea">\
  <label class="property-name"></label>\
  <div class="info_textbox2"><textarea class="value"></textarea></div>\
</fieldset>\
\
<fieldset class="trackevent-property checkbox-group">\
  <div class="checkbox-group">\
    <input type="checkbox" class="value" style="position: relative;left: -73px;top: 10px;"/>\
    <label class="property-name" style="padding-left:10px;"></label>\
  </div>\
</fieldset>\
\
<fieldset class="h5-form-inline form-half start-end">\
  <div class="h5-form-append">\
    <label class="property-name">' + lang[_curLang].start + '</label>\
    <div class="info_textbox"><input type="text" onpaste="return false" class="value" data-manifest-key="start" style="ime-mode: disabled;"></div>\
  </div>\
  <div class="h5-form-append">\
    <label class="property-name">' + lang[_curLang].end + '</label>\
    <div class="info_textbox"><input type="text" onpaste="return false"  class="value" data-manifest-key="end" style="ime-mode: disabled;" ></div>\
  </div>\
</fieldset>\
<div class="h5-breadcrumbs">\
  <span class="h5-editor-title">' + lang[_curLang].active + '</span>\
</div>';



});


/*
 * TrackEvent可视化编辑器
 */
h5.define('editor/TrackEventEditor', [
            "jquery",
            "util/Keys",
            "util/Time",
            "util/util",
            "editor/BaseEditor",
            "util/H5Tooltip",
          "templates/TrackEventEditorLayout"],
  function ($, Keys, Time, util, BaseEditor, ToolTip,
            TRACK_EVENT_EDITOR_LAYOUT) {

      var NULL_FUNCTION = function () { };

      var __defaultLayouts = util.domFragment(TRACK_EVENT_EDITOR_LAYOUT),   //$(TRACK_EVENT_EDITOR_LAYOUT),
          //__googleFonts = [
          //  lang[_curLang].MSYH,
          //  lang[_curLang].song,
          //  "SimHei",
          //  "NSimSun",
          //  "FangSong ",
          //  "LiSu",
          //  "KaiTi",
          //  "YouYuan",
          //  "Times New Roman",
          //  "Georgia",
          //  "Arial"
          //];
          //addby hzr 20161118 通过读取网管配置中的字体
          __googleFonts = _installedFontCollection.split(";");

      /**
       * Class: TrackEventEditor
       *
       * Extends a given object to be a TrackEvent editor, giving it capabilities to work with TrackEvents
       *
       * @param {Object} extendObject: Object to be extended to become a TrackEvent editor
       * @param {Butter} butter: An instance of Butter
       * @param {DOMElement} rootElement: The root element to which the editor's content will be attached
       * @param {Object} events: Events such as 'open' and 'close' can be defined on this object to be called at the appropriate times
       */
      var TrackEventEditor = BaseEditor.extend({
          init: function (rootElement, app, events) {

              var events = events || {},
                  _oldOpenEvent = events.open,

                  _trackEvent;
              this._trackEventUpdateErrorCallback = NULL_FUNCTION;
              this._app = app;
              this._rootElement = rootElement;
              var  _this = this;

              events.open = function (parentElement, trackEvent) {
                  var basicButton = rootElement.querySelector(".basic-tab"),
                      advancedButton = rootElement.querySelector(".advanced-tab"),
                      basicTab = rootElement.querySelector(".editor-options"),
                      advancedTab = rootElement.querySelector(".advanced-options"),
                      wrapper = rootElement.querySelector(".wrapper"),
                      content = rootElement.querySelector(".content"),
                      container = rootElement.querySelector(".scrollbar-container");

                  _trackEvent = trackEvent;

                  _this.setTrackEventUpdateErrorCallback(_this.setErrorState);

                  if (_oldOpenEvent) {
                      _oldOpenEvent.apply(this, arguments);
                  }

                  this.addScrollbar({
                      inner: content,
                      outer: wrapper,
                      appendTo: container
                  });

                  if (basicButton && advancedButton) {

                      advancedTab.classList.add("display-off");
                      basicButton.classList.add("active");

                      basicButton.addEventListener("mouseup", function () {
                          if (basicTab.classList.contains("display-off")) {
                              basicTab.classList.toggle("display-off");
                              advancedTab.classList.toggle("display-off");
                              basicButton.classList.add("active");
                              advancedButton.classList.remove("active");
                              _this.scrollbar.update();
                          }
                      });

                      advancedButton.addEventListener("mouseup", function () {
                          if (!basicTab.classList.contains("display-off")) {
                              basicTab.classList.toggle("display-off");
                              advancedTab.classList.toggle("display-off");
                              basicButton.classList.remove("active");
                              advancedButton.classList.add("active");
                              _this.scrollbar.update();
                          }
                      });




                  }

                  if (this.scrollbar) {
                      this.scrollbar.update();
                  }

                  this.showPluginPreview(trackEvent);

              };

              this._super(rootElement, app, events);

              this.defaultLayouts = __defaultLayouts.cloneNode(true);

              this.getTrackEvent = function () {
                  return _trackEvent;
              };

              Object.defineProperties(this, {
                  trackEvent: {
                      enumerable: true,
                      get: function () {
                          return _trackEvent;
                      }
                  }
              });

          },
          /**
           *
           * 尝试更新TrackEvent，如果失败，调用失败回调
           *
           * @param {TrackEvent} trackEvent: 需要更新的TrackEvent
           * @param {Object} properties: 需要更新的属性
           */
          updateTrackEventSafe: function (trackEvent, properties) {
              var _this = this;
              var _ui = [];
              if (properties.hasOwnProperty("start")) {
                  if (properties.start < 0) {
                      properties.start = 0;
                  }

                  var r = trackEvent.plugin.canUpdateStart(trackEvent, properties);
                  if (!r.can) {
                      //properties.start = r.start;
                      for (var key in r) {
                          if (properties.hasOwnProperty(key)) {
                              properties[key] = r[key];
                          }
                      }

                      _this._trackEventUpdateErrorCallback(lang[_curLang].startTimeError);
                      _ui.push('start');
                  }
                  if (r.callback && typeof r.callback == "function") {
                      r.callback();
                  }
              }

              if (properties.hasOwnProperty("end")) {
                  var r = trackEvent.plugin.canUpdateEnd(trackEvent, properties);
                  if (!r.can) {
                      //properties.end = r.end;
                      for (var key in r) {
                          if (properties.hasOwnProperty(key)) {
                              properties[key] = r[key];
                          }
                      }

                      _this._trackEventUpdateErrorCallback(lang[_curLang].endTimeError);
                      _ui.push('end');
                  }
                  if (r.callback && typeof r.callback == "function") {
                      r.callback();
                  }
              }


              //if (properties.hasOwnProperty("end")) {
              //    if (properties.end > this._app.duration) {
              //        properties.end = this._app.duration;
              //    }
              //}
              try {
                  trackEvent.update(properties);
                  _this._app.media.updateDuration();
                  if (_ui.length > 0) {
                      _this.updatePropertiesFromManifest(trackEvent, _ui);
                  } else {
                      _this.setErrorState(false);
                  }
              }
              catch (e) {
                  _this._trackEventUpdateErrorCallback(e.toString());
              }
          },
          /*
           * 创建编辑器顶部标题
           */
          createBreadcrumbs: function (trackEvent) {
              var oldTitleEl = this._rootElement.querySelector("h1"),
                  breadcrumbsLayout = this.defaultLayouts.querySelector(".h5-breadcrumbs"),
                  //backLink = breadcrumbsLayout.querySelector(".h5-breadcrumbs-back"),
                  editorTitle = breadcrumbsLayout.querySelector(".h5-editor-title"),
                  //closeEditorLink = breadcrumbsLayout.querySelector(".close-btn"),
                  pluginName = trackEvent.manifest.displayName || trackEvent.type;

              if (!trackEvent || !oldTitleEl) {
                  return;
              }

              //closeEditorLink.addEventListener("click", function () {
              //    extendObject.dispatchEvent("back");
              //});

              //backLink.addEventListener("click", function () {
              //    extendObject.dispatchEvent("back");
              //});

              if (trackEvent.type) {
                  editorTitle.innerHTML = "";
                  editorTitle.appendChild(document.createTextNode(pluginName));
              }

              oldTitleEl.parentNode.replaceChild(breadcrumbsLayout, oldTitleEl);
          },
          /**
            *  目标下拉列表
            */
          createTargetsList: function (targets) {
              var propertyRootElement = __defaultLayouts.querySelector(".trackevent-property.targets").cloneNode(true),
                  selectElement = propertyRootElement.querySelector("select"),
                  mediaOptionElement = selectElement.firstChild,
                  optionElement;

              for (var i = 1; i < targets.length; ++i) {
                  optionElement = document.createElement("option");
                  optionElement.value = targets[i].element.id;
                  optionElement.innerHTML = targets[i].element.id;

                  if (mediaOptionElement) {
                      selectElement.insertBefore(optionElement, mediaOptionElement);
                  }
                  else {
                      selectElement.appendChild(optionElement);
                  }
              }

              return propertyRootElement;
          },
          showPluginPreview: function (trackEvent) {
              var startTime = trackEvent.popcornOptions.start,
                  endTime = trackEvent.popcornOptions.end,
                  currentTime = this._app.currentTime,
                  accuracy = startTime * Math.pow(10, Time.timeAccuracy - 1);

              if (currentTime < startTime || currentTime > endTime) {
                  this._app.media.currentTime = startTime === 0 ? startTime : Math.ceil(startTime * accuracy) / accuracy;
              }
          },
          attachSelectChangeHandler: function (element, trackEvent, propertyName) {
              var _this = this;
              element.addEventListener("change", function () {
                  var updateOptions = {};
                  updateOptions[propertyName] = element.value;
                  trackEvent.update(updateOptions);
                  _this._app.dispatchEvent("resize");

                 // _this._app.media.view.blink();

              });
          },
          attachSecondsChangeHandler: function (element, trackEvent, propertyName, callback) {

              var _this = this;
              this.attachInputChangeHandler(element, trackEvent, propertyName, function (te, options) {
                  try{
                      options[propertyName] = util.roundTime(options[propertyName]); //Time.toSeconds(options[propertyName]);
                      if (_this.app.media.json.duration < options[propertyName] && trackEvent.type == "PopcornMediaPlugin") {
                          _this._trackEventUpdateErrorCallback('error value');
                          return ;
                      }
                      callback.call(_this, trackEvent, options);
                  } catch (e) {
                      _this._trackEventUpdateErrorCallback(e.toString());
                  }
              });

          },
          attachCheckboxChangeHandler: function (element, trackEvent, propertyName, callBack) {
              callBack = callBack || function (trackEvent, updateOptions) {
                  trackEvent.update(updateOptions);
              };

              var _this = this;
              element.addEventListener("click", function () {
                  var updateOptions = {};
                  updateOptions[propertyName] = element.checked;
                  callBack.call(_this,trackEvent, updateOptions, propertyName);
              });
          },
          attachSliderChangeHandler: function (element, trackEvent, propertyName, callback) {
              var scrubber = element.querySelector(".h5-slider-scrubber"),
                  manifestOptions = trackEvent.manifest.options[propertyName],
                  MAX_VAL = manifestOptions.max || 100,
                  MIN_VAL = manifestOptions.min || 0,
                  sliderUnit = manifestOptions.slider_unit || "",
                  precision = manifestOptions.precision || 0,
                  SCRUBBER_OFFSET = 4,
                  SCRUBBER_TOOLTIP_OFFSET = 3,
                  sliderToolTip = element.querySelector(".h5-slider-tooltip"),
                  rects = element.getBoundingClientRect(),
                  _this = this;


              callback = callback || this.updateTrackEventSafe;

              function toReal(n) {
                  var maxUI = element.offsetWidth;
                  return (n / maxUI) * MAX_VAL;
              }

              function toUI(n) {
                  var maxUI = element.offsetWidth;
                  return (n / MAX_VAL) * maxUI;
              }

              function normalize(n) {
                  if (n < MIN_VAL) {
                      n = MIN_VAL;
                  } else if (n > MAX_VAL) {
                      n = MAX_VAL;
                  }

                  n = n.toFixed(manifestOptions.precision);

                  return n;
              }

              function setSliderToolTip(val) {
                  val = parseFloat(normalize(toReal(val - rects.left)));
                  sliderToolTip.style.left = toUI(val) + "px";
                  sliderToolTip.innerHTML = val.toFixed(precision) + sliderUnit;
              }

              function setScrubber(val) {
                  val = normalize(toReal(val - rects.left));
                  scrubber.style.left = toUI(val) - SCRUBBER_OFFSET + "px";
              }

              function updateUI() {
                  var val = parseFloat(trackEvent.popcornOptions[propertyName]),
                      left = toUI(val) - SCRUBBER_OFFSET;
                  scrubber.style.left = left + "px";
                  sliderToolTip.style.left = left + SCRUBBER_TOOLTIP_OFFSET + "px";
                  sliderToolTip.innerHTML = val.toFixed(precision) + sliderUnit;
              }

              function updateTrackEvent(options) {
                  callback.call(_this, trackEvent, options);
                  updateUI();
              }

              function onSlideStop(e) {
                  var left = e.clientX - rects.left,
                      properties = {};

                  properties[propertyName] = normalize(toReal(left));
                  updateTrackEvent(properties);

                  sliderToolTip.classList.remove("tooltip-no-transition-on");
                  element.addEventListener("mousedown", onSliderMouseDown);
                  onMouseOut();
                  document.removeEventListener("mousemove", onSliding, false);
                  document.removeEventListener("mouseup", onSlideStop, false);
              }

              function onSliding(e) {
                  setSliderToolTip(e.clientX);
                  setScrubber(e.clientX);
              }

              function onSlideStart(e) {
                  e.preventDefault();
                  element.removeEventListener("mouseover", onMouseOver, false);
                  element.removeEventListener("mousemove", onMouseMove, false);
                  element.removeEventListener("mouseout", onMouseOut, false);
                  element.removeEventListener("mousedown", onSliderMouseDown, false);
                  sliderToolTip.classList.add("tooltip-no-transition-on");
                  document.addEventListener("mousemove", onSliding);
                  document.addEventListener("mouseup", onSlideStop);
              }

              function onSliderMouseDown(e) {
                  e.preventDefault();

                  document.addEventListener("mousemove", onSliding);
                  document.addEventListener("mouseup", onSlideStop);
                  element.removeEventListener("mouseout", onMouseOut, false);
                  sliderToolTip.classList.add("tooltip-no-transition-on");
                  setScrubber(e.clientX);
              }

              function onMouseMove(e) {
                  setSliderToolTip(e.clientX);
              }

              function onMouseOver(e) {
                  sliderToolTip.classList.add("tooltip-no-transition-on");
                  setSliderToolTip(e.clientX);
                  element.removeEventListener("mouseover", onMouseOver, false);
                  element.addEventListener("mouseout", onMouseOut);
                  element.addEventListener("mousemove", onMouseMove);
              }

              function onMouseOut() {
                  sliderToolTip.classList.remove("tooltip-no-transition-on");
                  element.removeEventListener("mouseout", onMouseOut, false);
                  element.removeEventListener("mousemove", onMouseMove, false);
                  element.addEventListener("mouseover", onMouseOver);
              }

              scrubber.addEventListener("mousedown", onSlideStart);
              element.addEventListener("mouseover", onMouseOver);
              element.addEventListener("mousedown", onSliderMouseDown);
              updateUI();
          },
          attachInputChangeHandler: function (element, trackEvent, propertyName, callback) {

              var _this = this;
              function updateTrackEvent(trackEvent, callback, updateOptions) {
                  if (!trackEvent.track) {
                      return;
                  }
                  if (callback) {
                      callback.call(_this, trackEvent, updateOptions);
                  } else {
                      trackEvent.update(updateOptions);
                  }
              }

              var ignoreChange,
                  manifestType,
                  manifestElem,
                  isNumber;

              if (trackEvent.popcornTrackEvent) {
                  manifestType = trackEvent.manifest.options[propertyName].type;
                  manifestElem = trackEvent.manifest.options[propertyName].elem;
              }

              isNumber = manifestType === "number" ? true : false;

              function validateNumber(val) {
                  var popcornOptions = trackEvent.popcornOptions;

                  // Not so pretty looking workaround for Firefox not implementing input type=number
                  if (isNaN(val) || val === "") {
                      val = popcornOptions[propertyName];
                  }
                  return val;
              }

              function onMousedown(e) {
                  e.stopPropagation();
                  e.preventDefault();
                  if (propertyName == 'text') {
                      if (element.value.replace(/^\s+|\s+$/g, "").length == 0) {
                          element.value = 'Double click to add subtitle.';
                      }
                  }
                  else if (propertyName == "name") {
                      document.querySelector("#mvTimeLineTitle").innerText = element.value;
                  }
                  var val = element.value,
                      updateOptions = {};
                  window.removeEventListener("mousedown", onMousedown, true);
                  if (isNumber) {
                      val = validateNumber(val);
                  }

                  updateOptions[propertyName] = val;
                  updateTrackEvent(trackEvent, callback, updateOptions);

                  if (propertyName == 'text') {
                      element.blur();
                      var tEle = $('.popcorn-text.on');
                      var vEle = $('#h5-video-panel');
                      if (tEle.height() + tEle.position().top > vEle.height()) {
                          var top = vEle.height() - tEle.height() - 1;
                          tEle.css("top", top);
                          var opt = {
                              position: "custom",
                              top: (top / vEle.height()) * 100,
                              left: tEle.position().left / vEle.width() * 100,
                              width: tEle.width() / vEle.width() * 100
                          }
                          trackEvent.update(opt);
                      }
                  }
              }

              if (manifestElem === "textarea") {
                  element.addEventListener("input", function (e) {

                      if (element.value.length > 139) {
                          element.value = element.value.substring(0, 140);
                      }

                      window.addEventListener("mousedown", onMousedown, true);
                      var updateOptions = {},
                          val = element.value;

                      e.preventDefault();

                      if (isNumber) {
                          val = validateNumber(val);
                      }

                     // updateOptions[propertyName] = val;
                     // updateTrackEvent(trackEvent, callback, updateOptions);
                     // ignoreChange = true;
                     // element.style.height = "auto";
                    //  element.style.height = element.scrollHeight + "px";
                  }, false);
              } else {
                  element.addEventListener("change", function (e) {
                      e.preventDefault();
                      if (propertyName == 'fontSize') {
                          var isFont = true;
                          if (element.value > 20 ) {
                              element.value = 20;
                          }
                          else if(element.value < 1){
                              element.value = 1;
                          }
                      }
                      var updateOptions = {},
                          val = element.value;
                      if (isNumber) {
                          val = validateNumber(val);
                      }

                      updateOptions[propertyName] = val;
                      if (trackEvent.track) {
                          updateTrackEvent(trackEvent, callback, updateOptions);
                      }
                      if (isFont) {
                          var tEle = $('.popcorn-text.on');
                          var vEle = $('#h5-video-panel');
                          if (tEle.height() + tEle.position().top > vEle.height()) {
                              var top = vEle.height() - tEle.height() - 1;
                              tEle.css("top", top);
                              var opt = {
                                position: "custom",
                                top: (top / vEle.height()) * 100,
                                left: tEle.position().left / vEle.width() * 100,
                                width: tEle.width() / vEle.width() * 100
                            }
                              trackEvent.update(opt);
                          }
                      }
                      if (propertyName == "name") {
                          document.querySelector("#mvTimeLineTitle").innerText = val;
                      }
                      ignoreChange = true;
                  });
                  element.addEventListener("keypress", function (e) {
                          var a = /[\d.:]/.test(String.fromCharCode(event.keyCode));
                          if (!a && (propertyName == 'start' || propertyName == 'end' || propertyName == 'inpoint' || propertyName == 'outpoint') && (event.keyCode != 8 && event.keyCode != 46 && event.keyCode != 13)) {
                              e.stopPropagation();
                              e.preventDefault();
                              return false;
                          }
                          if (propertyName == 'fontSize') {
                              if (element.value > 20) {
                                  element.value = 20;
                              }
                              else if (element.value < 1) {
                                  element.value = 1;
                              }
                          }
                      var updateOptions = {},
                          val = element.value;

                      window.addEventListener("mousedown", onMousedown, true);
                      if (e.keyCode === Keys.ENTER) {
                          e.preventDefault();

                          if (isNumber) {
                              val = validateNumber(val);
                          }

                          updateOptions[propertyName] = val;
                          if (trackEvent.track) {
                              updateTrackEvent(trackEvent, callback, updateOptions);
                          }
                          if (propertyName == "name") {
                              if (val) {
                                  document.querySelector("#mvTimeLineTitle").innerText = val;
                              }
                          }
                          ignoreChange = true;
                      }
                  });
              }

              if (element.type === "number" || isNumber) {
                  element.addEventListener("change", function () {

                      var updateOptions = {},
                          val = element.value;

                      if (ignoreChange) {
                          ignoreChange = false;
                      } else {

                          val = validateNumber(val);

                          updateOptions[propertyName] = val;
                          updateTrackEvent(trackEvent, callback, updateOptions);
                      }
                  });
              }
          },
          createStartEndInputs: function (trackEvent, callback) {
              var editorElement = __defaultLayouts.querySelector(".start-end").cloneNode(true),
                  start = editorElement.querySelector("input[data-manifest-key='start']"),
                  end = editorElement.querySelector("input[data-manifest-key='end']");

              this.attachSecondsChangeHandler(start, trackEvent, "start", callback);
              this.attachSecondsChangeHandler(end, trackEvent, "end", callback);

              return editorElement;
          },
          ////设为默认
          //createSetAsDefaultsButton: function (trackEvent) {
          //    var editorElement = __defaultLayouts.querySelector(".checkbox").cloneNode(true),
          //        span = editorElement.querySelector(".h5-form-checkbox span"),
          //        checkbox = editorElement.querySelector(".h5-form-checkbox input");
          //    span.innerHTML = lang[_curLang].default;
          //    if (trackEvent.isDefault) {
          //        checkbox.checked = true;
          //    }
          //    checkbox.addEventListener("change", function () {
          //        if (!trackEvent.isDefault) {
          //            if (trackEvent.defaults.current) {
          //                trackEvent.defaults.current.isDefault = false;
          //            }
          //            trackEvent.isDefault = true;
          //        } else {
          //            trackEvent.isDefault = false;
          //        }
          //    });
          //    return editorElement;
          //},
          createManifestItem: function (name, manifestEntry, data, trackEvent, itemCallback) {
              var elem = manifestEntry.elem || "default",
                  itemLabel = name,
                  isStartOrEnd = ["start", "end"].indexOf(name.toLowerCase()) > -1,
                  units = (manifestEntry.units == "%" ? "" : manifestEntry.units) || (isStartOrEnd ? lang[_curLang].second : ""),
                  propertyArchetypeSelector,
                  propertyArchetype,
                  editorElement,
                  option,
                  tooltip,
                  manifestEntryOption,
                  i, l;

              if (manifestEntry.label) {
                  itemLabel = manifestEntry.label;
              }

              var _this = this;
              function attachCheckboxGroupChangeHandler(element, trackEvent, propertyName) {
                  element.addEventListener("click", function () {
                      var updateOption = {},
                          updateOptions = {},
                          i,
                          labels = trackEvent.manifest.options[propertyName].labels,
                          currentElement;

                      // Add in the rest
                      for (i in labels) {
                          if (labels.hasOwnProperty(i)) {
                              currentElement = _this.rootElement.querySelector("[data-manifest-key='" + i + "']");
                              updateOptions[i] = currentElement.checked;
                          }
                      }

                      updateOption[propertyName] = updateOptions;

                      trackEvent.update(updateOption);
                  });
              }


              // Get the right property archetype
              propertyArchetypeSelector = ".trackevent-property." + elem;
              if (units) {
                  propertyArchetypeSelector += ".units";
              }
              if (manifestEntry.type === "checkbox") {
                  propertyArchetypeSelector += ".checkbox";
              }
              if (manifestEntry.type === "radio") {
                  propertyArchetypeSelector += ".radio";
              }
              if (manifestEntry.type === "range") {
                  propertyArchetypeSelector += ".range";
              }
              if (manifestEntry.type === "color") {
                  propertyArchetypeSelector += ".color";
              }

              propertyArchetype = __defaultLayouts.querySelector(propertyArchetypeSelector).cloneNode(true);

              if (manifestEntry.hidden) {
                  return;
              }

              if (units) {
                  propertyArchetype.querySelector(".h5-unit").innerHTML = units;
              }

              if (propertyArchetype.querySelector(".property-name")) {
                  propertyArchetype.querySelector(".property-name").innerHTML = itemLabel;
              }

              if (manifestEntry.elem === "select") {
                  editorElement = propertyArchetype.querySelector("select");

                  editorElement.setAttribute("data-manifest-key", name);

                  if (manifestEntry.options) {
                      for (i = 0, l = manifestEntry.options.length; i < l; ++i) {
                          option = document.createElement("option");
                          manifestEntryOption = manifestEntry.options[i];

                          if (manifestEntry.values && manifestEntry.values[i]) {
                              option.innerHTML = manifestEntryOption;
                              option.value = manifestEntry.values[i];
                          }
                          else {
                              option.value = option.innerHTML = manifestEntryOption;
                          }

                          editorElement.appendChild(option);
                      }
                  }
                  else if (manifestEntry.googleFonts && __googleFonts) {
                      var font,
                          m,
                          fLen;

                      __googleFonts = __googleFonts.sort();

                      for (m = 0, fLen = __googleFonts.length; m < fLen; m++) {
                          font = document.createElement("option");

                          font.value = font.innerHTML = __googleFonts[m];
                          editorElement.appendChild(font);
                      }
                  }
              } else if (manifestEntry.elem === "textarea") {
                  editorElement = propertyArchetype.querySelector("textarea");

                  editorElement.setAttribute("data-manifest-key", name);

                  if (data) {
                      // Don't print "undefined" or the like
                      if (data === undefined || typeof data === "object") {
                          data = "";
                      }
                      editorElement.value = data;
                  }

              } else if (manifestEntry.elem === "checkbox-group") {
                  var item,
                      elementParent = propertyArchetype,
                      checkbox,
                      label;

                  editorElement = propertyArchetype.querySelector(".checkbox-group").cloneNode(true);

                  // Remove originally defined element
                  elementParent.removeChild(elementParent.querySelector("div"));

                  for (item in manifestEntry.labels) {
                      if (manifestEntry.labels.hasOwnProperty(item)) {
                          checkbox = editorElement.querySelector(".value");
                          label = editorElement.querySelector(".property-name");

                          attachCheckboxGroupChangeHandler(checkbox, trackEvent, name);

                          label.innerHTML =manifestEntry.labels[item];
                          checkbox.value = manifestEntry.default[item];
                          checkbox.setAttribute("data-manifest-key", item);

                          elementParent.appendChild(editorElement);
                          editorElement = propertyArchetype.querySelector(".checkbox-group").cloneNode(true);
                      }
                  }
              } else {
                  if (manifestEntry.type === "range") {
                      tooltip = propertyArchetype.querySelector(".h5-slider-tooltip");

                      propertyArchetype.querySelector(".slider-start").innerHTML = manifestEntry.min || 0;
                      propertyArchetype.querySelector(".slider-end").innerHTML = (manifestEntry.max || 100) + (manifestEntry.slider_unit || "");

                      tooltip.setAttribute("data-manifest-key", name);

                      editorElement = propertyArchetype.querySelector(".h5-slider");
                  } else if (manifestEntry.type === "color") {
                      editorElement = propertyArchetype;
                      // Don't print "undefined" or the like
                      if (data) {
                          editorElement.querySelector("input").value = data;
                          editorElement.querySelector(".color-picker-toggle").style.background = data;
                      }

                      // data-manifest-key is used to update this property later on
                      editorElement.querySelector("input").setAttribute("data-manifest-key", name);
                  } else {
                      editorElement = propertyArchetype.querySelector("input");
                      if (data) {
                          // Don't print "undefined" or the like
                          if (data === undefined || typeof data === "object") {
                              data = manifestEntry.type === "number" ? 0 : "";
                          }
                          editorElement.placeholder = editorElement.value = data;
                      }

                      try {
                          editorElement.type = manifestEntry.type;
                          // step="any" will stop the :invalid pseudo class in Chrome from being applied if the value is a not a "whole" number. i.e. 1.234
                          if (editorElement.type === "number") {
                              editorElement.step = manifestEntry.step || "any";
                          }

                          if (manifestEntry.readonly) {
                              editorElement.setAttribute("readonly", true);
                          }
                      }
                      catch (e) {
                          // Suppress IE9 errors
                      }
                      // data-manifest-key is used to update this property later on
                      editorElement.setAttribute("data-manifest-key", name);
                  }
              }

              if (itemCallback) {
                  var _this = this;
                  itemCallback.call(_this, manifestEntry.elem, editorElement, trackEvent, name);
              }

              return propertyArchetype;
          },
          updatePropertiesFromManifest: function (trackEvent, manifestKeys, forceTarget) {
              var element,
                  popcornOptions = trackEvent.popcornOptions,
                  manifestOptions = trackEvent.manifest.options,
                  manifestEntry,
                  option,
                  units,
                  i, l;

              manifestKeys = manifestKeys || Object.keys(manifestOptions);

              if (forceTarget && manifestKeys.indexOf("target") === -1) {
                  manifestKeys = manifestKeys.concat("target");
              }

              for (i = 0, l = manifestKeys.length; i < l; ++i) {
                  option = manifestKeys[i];
                  if (manifestOptions[option]) {
                      manifestEntry = manifestOptions[option];
                      units = manifestEntry.units;
                  }

                  element = this.rootElement.querySelector("[data-manifest-key='" + option + "']");

                  if (element) {
                      if (element.type === "checkbox") {
                          element.checked = popcornOptions[option];
                      }
                      else if (manifestEntry.type === "range") {
                          element.innerHTML = parseFloat(popcornOptions[option]).toFixed(manifestEntry.precision) + (manifestEntry.slider_unit || "");
                      }
                      else {
                          if (typeof popcornOptions[option] !== "undefined") {
                              if (units === lang[_curLang].second) {
                                  //element.value = Time.toTimecode(popcornOptions[option]);
                                  element.value = util.toSmpteString(popcornOptions[option] * 1000);
                              } else {
                                  element.value = popcornOptions[option];
                              }
                          } else {
                              element.value = manifestOptions[option].default || "";
                          }
                      }
                  }
                  else if (manifestOptions[option] && manifestOptions[option].elem === "checkbox-group") {
                      var m,
                          labels = manifestOptions[option].labels,
                          popcornOption = popcornOptions[option];

                      for (m in labels) {
                          if (labels.hasOwnProperty(m)) {
                              element = this.rootElement.querySelector("[data-manifest-key='" + m + "']");

                              if (typeof popcornOptions[option] !== "undefined") {
                                  element.checked = popcornOption[m];
                              } else {
                                  element.checked = manifestOptions[option].default[m];
                              }
                          }
                      }
                  }
              }
          },
          createPropertiesFromManifest: function (options) {
              var manifestOptions,
                  item,
                  element,
                  container,
                  optionGroup,
                  manifestKeys,
                  basicContainer,
                  advancedContainer,
                  trackEvent = options.trackEvent,
                  ignoreManifestKeys = options.ignoreManifestKeys || [],
                  i, l;

              basicContainer = options.basicContainer || this.rootElement;
              advancedContainer = options.advancedContainer || this.rootElement;

              if (!trackEvent.manifest) {
                  throw lang[_curLang].noMetadata;
              }

              this.createBreadcrumbs(trackEvent);

              manifestOptions = trackEvent.manifest.options;

              manifestKeys = options.manifestKeys || Object.keys(manifestOptions);

              for (i = 0, l = manifestKeys.length; i < l; ++i) {
                  item = manifestKeys[i];
                  optionGroup = manifestOptions[item].group ? manifestOptions[item].group : "basic";
                  container = optionGroup === "advanced" ? advancedContainer : basicContainer;
                  if (ignoreManifestKeys && ignoreManifestKeys.indexOf(item) > -1) {
                      continue;
                  }
                  element = this.createManifestItem(item, manifestOptions[item], trackEvent.popcornOptions[item], trackEvent, options.callback);

                  if (element) {
                      container.appendChild(element);
                  }
              }
          },
          setTrackEventUpdateErrorCallback: function (errorCallback) {
              this._trackEventUpdateErrorCallback = errorCallback || NULL_FUNCTION;
          }


      });


      return {
          TrackEventEditor: TrackEventEditor,
          EDITOR_FRAGMENTS: __defaultLayouts
      };
  });

/*
 * 管理可视化编辑器
 */
h5.define('editor/EditorManager', ["editor/BaseEditor", "editor/TrackEventEditor"],
  function (BaseEditor, TrackEventEditor) {

      var __editors = {},
          __editorHelperCallbacks = {};


      var Editor =  function(){

          this.BaseEditor =  BaseEditor;
          this.TrackEventEditor =TrackEventEditor;

          /**
           * 注册一个可视化编辑器
           *
           * @param {String} name: 编辑器名称
           * @param {String} layout: 编辑器布局
           * @param {Function} ctor: Constructor to be run when the Editor is being created
           * @param {Boolean} persist: Persist the HTML layout on close and reuse on each open rather than starting fresh with each open.
           * @param {Function} editorHelperCallback: trackeventupdated 事件引发时的回调函数
           */
          this.register=function (name, layout, ctor, persist, editorHelperCallback) {
              __editors[name] = {
                  create: ctor,
                  persist: !!persist,
                  layout: layout || "",
                  deferredLayouts: []
              };

              if (editorHelperCallback) {
                  __editorHelperCallbacks[name] = editorHelperCallback;
              }
          };

          /**
           * 初始化编辑器
           *
           * @param {Function} readyCallback: After all layouts have been loaded, call this function.
           * @param {String} baseDir: The baseDir found in Butter's config which is used to replace {{baseDir}} in urls.
           */
          this.initialize = function (readyCallback, baseDir) {
              var editorName,
                  editorsLoaded = 0,
                  editorsToLoad = [];

              // 异步载入的编辑器......暂时没有
              for (editorName in __editors) {
                  if (__editors.hasOwnProperty(editorName) && __editors[editorName].deferredLayouts.length > 0) {
                      editorsToLoad.push(__editors[editorName]);
                  }
              }

              readyCallback(__editorHelperCallbacks);

          };


          this.create = function (editorName, app) {
              var description = __editors[editorName],
                  completeLayout,
                  compiledLayout;

              if (!description) {
                  throw lang[_curLang].theEditorL + editorName + lang[_curLang].theEditorL;
              }

              if (description.layout) {
                  compiledLayout = $(description.layout);
                  completeLayout = compiledLayout;

                  if (compiledLayout.length >1 ) {
                      compiledLayout = compiledLayout.find(".h5-editor");
                  }

                  if (!compiledLayout) {
                      throw lang[_curLang].editorLayoutWrong;
                  }
              }

              return new description.create(compiledLayout[0], app, completeLayout);
          };

          this.isRegistered = function (name) {
              return !!__editors[name];
          };


          this.isPersistent= function (editorName) {
              return __editors[editorName].persist;
          };

      };

      return Editor;

  });


h5.define('templates/TextTrackEventEditorLayout', [], function () {
    return '<div class="h5-editor h5-form default-editor">\
  <h1>' + lang[_curLang].textEditor + '</h1>\
  <ul class="tb2 small">\
      <li class="basic-tab active" style="font-size:12px;"><a >' + lang[_curLang].basic + '</a></li>\
      <li class="advanced-tab" style="font-size:12px;"><a >' + lang[_curLang].advanced + '</a></li>\
  </ul>\
  <div class="h5-editor-body h5-tabs-spacing scrollbar-container">\
        <div class="wrapper">\
            <div class="content">\
                  <div class="error-message-container">\
                    <div class="error-message"></div>\
                  </div>\
                  <div class="editor-options"></div>\
                  <div class="advanced-options"></div>\
            </div>\
        </div>\
    </div>\
  </div>\
</div>';
});




/*
 * 可视化编辑器基类
 */
h5.define('editor/TextEditor', ["jquery",  "editor/TrackEventEditor" , "templates/TextTrackEventEditorLayout"],
  function ($,  TrackEventEditor, TEXT_TRACKEVENT_EDITOR_LAYOUT) {

      var TextEditor = TrackEventEditor.TrackEventEditor.extend({
          init: function (rootElement, app) {

              var _this = this;

              var _rootElement = rootElement,
                  _trackEvent,
                  _app,
                  _popcornOptions,
                  _falseClick = function () {
                      return false;
                  },
                  _trueClick = function () {
                      return true;
                  };


              function setup(trackEvent) {
                  _trackEvent = trackEvent;
                  _popcornOptions = _trackEvent.popcornOptions;

                  var basicContainer = _rootElement.querySelector(".editor-options"),
                      advancedContainer = _rootElement.querySelector(".advanced-options"),
                      pluginOptions = {},
                      pickers = {};

                  function callback(elementType, element, trackEvent, name) {
                      pluginOptions[name] = { element: element, trackEvent: trackEvent, elementType: elementType };
                  }

                  function attachHandlers() {
                      var key,
                          option;

                      function colorCallback(te, options, message, prop) {
                          var newOpts = {};
                          if (message) {
                              _this.setErrorState(message);
                              return;
                          } else {
                              newOpts[prop] = options[prop];
                              te.update(newOpts);
                          }
                      }
                      function checkboxCallback(trackEvent, updateOptions, prop) {
                          if ("background shadow".match(prop)) {
                              if (updateOptions[prop]) {
                                  pickers[prop].classList.remove("disabled");
                                  pickers[prop].onclick = _trueClick;
                              } else {
                                  pickers[prop].classList.add("disabled");
                                  pickers[prop].onclick = _falseClick;
                              }
                          }
                          trackEvent.update(updateOptions);
                      }
                      function urlCallback(trackEvent, updateOptions) {
                          if (updateOptions.linkUrl) {
                              pickers.linkTarget.classList.remove("disabled");
                              pickers.linkTarget.disabled = false;
                          } else {
                              pickers.linkTarget.classList.add("disabled");
                              pickers.linkTarget.disabled = true;
                          }
                          trackEvent.update(updateOptions);
                      }

                      for (key in pluginOptions) {
                          if (pluginOptions.hasOwnProperty(key)) {
                              option = pluginOptions[key];

                              if (option.elementType === "select") {
                                  _this.attachSelectChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);
                                  //if (key === "linkTarget") {
                                  //    pickers.linkTarget = option.element;
                                  //    if (!_popcornOptions.linkUrl) {
                                  //        option.element.classList.add("disabled");
                                  //        pickers.linkTarget.disabled = true;
                                  //    }
                                  //}
                              }
                              else if (option.elementType === "input") {
                                  //if (key === "linkUrl") {
                                  //    _this.createTooltip(option.element, {
                                  //        name: "text-link-tooltip" + Date.now(),
                                  //        element: option.element.parentElement,
                                  //        message: "....",
                                  //        top: "105%",
                                  //        left: "50%",
                                  //        hidden: true,
                                  //        hover: false
                                  //    });
                                  //}

                                  if (option.element.type === "checkbox") {
                                      _this.attachCheckboxChangeHandler(option.element, option.trackEvent, key, checkboxCallback);
                                  } else if (key === "fontColor") {
                                      _this.attachColorChangeHandler(option.element, option.trackEvent, key, colorCallback);
                                  } else if (key === "backgroundColor") {
                                      pickers.background = option.element;
                                      // set initial state
                                      if (!_popcornOptions.background) {
                                          option.element.classList.add("disabled");
                                          option.element.onclick = _falseClick;
                                      }
                                      _this.attachColorChangeHandler(option.element, option.trackEvent, key, colorCallback);
                                  } else if (key === "shadowColor") {
                                      pickers.shadow = option.element;
                                      // set initial state
                                      if (!_popcornOptions.shadow) {
                                          option.element.classList.add("disabled");
                                          option.element.onclick = _falseClick;
                                      }
                                      _this.attachColorChangeHandler(option.element, option.trackEvent, key, colorCallback);
                                  }
                                      //} else if (key === "linkUrl") {
                                      //    _this.attachInputChangeHandler(option.element, option.trackEvent, key, urlCallback);
                                      //}
                                  else {
                                      _this.attachInputChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);
                                  }
                              }
                              else if (option.elementType === "textarea") {
                                  _this.attachInputChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);
                              }
                          }
                      }

                      basicContainer.insertBefore(_this.createStartEndInputs(trackEvent, _this.updateTrackEventSafe), basicContainer.firstChild);
                  }

                  // backwards comp
                  if ("center left right".match(_popcornOptions.position)) {
                      _popcornOptions.alignment = _popcornOptions.position;
                      _popcornOptions.position = "middle";
                  }

                  _this.createPropertiesFromManifest({
                      trackEvent: trackEvent,
                      callback: callback,
                      basicContainer: basicContainer,
                      advancedContainer: advancedContainer,
                      ignoreManifestKeys: ["start", "end"]
                  });

                  attachHandlers();
                  //basicContainer.appendChild(_this.createSetAsDefaultsButton(trackEvent));
                  _this.updatePropertiesFromManifest(trackEvent);

              }

              function anchorClickPrevention(anchorContainer) {
                  if (anchorContainer) {

                      anchorContainer.onclick = _falseClick;
                  }
              }

              function onTrackEventUpdated(e) {
                  _trackEvent = e.target;

                  var anchorContainer = _trackEvent.popcornTrackEvent._container.querySelector("a");
                  anchorClickPrevention(anchorContainer);

                  _this.updatePropertiesFromManifest(_trackEvent);
                  _this.setErrorState(false);
              }

              var events = {};
              events.open = function (parentElement, trackEvent) {
                  var anchorContainer = trackEvent.popcornTrackEvent._container.querySelector("a");

                  anchorClickPrevention(anchorContainer);

                  _app = app;

                  trackEvent.addEventListener("trackeventupdated", onTrackEventUpdated);
                  setup(trackEvent);

              }
              events.close = function () {
                  _trackEvent.removeEventListener("trackeventupdated", onTrackEventUpdated);
              }

              _this._super(rootElement, app, events);
          }
      });


      return {
          name: 'PopcornTextPlugin',
          editor: TextEditor,
          layout: TEXT_TRACKEVENT_EDITOR_LAYOUT,
          persist: false,
          callback: function (trackEvent) {
              //更新回调
              var _container,
                  target;

              _container = trackEvent.popcornTrackEvent.container;
              target = trackEvent.popcornTrackEvent.timelinePlayer.element;

              this._draggable = this.draggable(trackEvent, _container, target, {
                  editable: true,
                  contentContainer: _container.querySelector(".text-inner-div"),
                  end: function () {
                      if (trackEvent.popcornOptions.position !== "custom") {
                          trackEvent.update({
                              position: "custom"
                          });
                      }
                  }
              });
              this.resizable(trackEvent, _container, target, {
                  minWidth: 10,
                  handlePositions: "e,w",
                  end: function () {
                      if (trackEvent.popcornOptions.position !== "custom") {
                          trackEvent.update({
                              position: "custom"
                          });
                      }
                  }
              });

              this.selectable(trackEvent, _container);
              //this.contentEditable(trackEvent, _container, _container.querySelector(".text-inner-div"));
          }
      };

  });
h5.define('templates/MediaTrackEventEditorLayout', [], function () {
    return '<div class="h5-editor h5-form media-editor">\
  <h1>' + lang[_curLang].edit + '</h1>\
  <div class="h5-editor-body scrollbar-container" style="top:30px;">\
    <div class="wrapper">\
        <div class="content">\
            <div class="error-message-container">\
                <div class="error-message"></div>\
            </div>\
            <div class="editor-options">\
                \
                <fieldset class="h5-form-inline in-out butter-form-inline form-half">\
                    <div class="clip-duration" data-manifest-key="from" dir="ltr">\
                    <label class="clip-start">0:00</label>\
                    <label class="clip-end"></label>\
                    <div class="clip-section" dir="ltr">\
                        <span class="trimmer-resizable-handle trimmer-resizable-e" dir="ltr"></span>\
                        <span class="trimmer-resizable-handle trimmer-resizable-w" dir="ltr"></span>\
                    </div>\
                    </div>\
                    <div class="h5-form-append"">\
                    <label>' + lang[_curLang].in + '</label>\
                        <div class="info_textbox"><input class="trimmer-input-left"></div>\
                    </div>\
                    <div class="h5-form-append">\
                    <label>'+lang[_curLang].out+'</label>\
                    <div class="info_textbox"><input class="trimmer-input-right"></div>\
                    </div>\
                </fieldset>\
                \
                <div class="start-end-container"></div>\
                <fieldset class="trackevent-property createdate">\
                    <label class="property-createdate">' + lang[_curLang].createTime + '</label>\
                    <div class="info_textbox"><input class="value" type="text" readonly="true"></div>\
                </fieldset>\
            </div>\
        </div>\
    </div>\
  </div>\
</div>';
});




/*
 * 媒体可视化编辑器
 */
h5.define('editor/MediaEditor', ["jquery", "editor/TrackEventEditor","util/util", "templates/MediaTrackEventEditorLayout"],
  function ($, TrackEventEditor, util, MEDIA_TRACKEVENT_EDITOR_LAYOUT) {

      var MediaEditor = TrackEventEditor.TrackEventEditor.extend({
          init: function (rootElement, app) {
              var _this = this;

              var _rootElement = rootElement,
                  _trackEvent,
                  _app = app,
                  _manifest = null,
                  _popcornOptions = null,
                  _fields = {};

              var events = {};







              function Input(el, property, callback, customUpdate) {
                  _this.attachInputChangeHandler(el, _trackEvent, property, callback);

                  function updateUI() {
                      var val = _popcornOptions[property];
                      el.value = val;
                      if (customUpdate) {
                          customUpdate(el);
                      }
                  }

                  updateUI(_popcornOptions[property]);

                  return {
                      el: el,
                      updateUI: updateUI
                  };
              };

              function StartEnd(el) {
                  var container = _this.createStartEndInputs(_trackEvent, _this.updateTrackEventSafe),
                      startEl = container.querySelector("[data-manifest-key=start]"),
                      endEl = container.querySelector("[data-manifest-key=end]");

                  el.appendChild(container);

                  function updateUI() {
                      startEl.value = util.toSmpteString(_popcornOptions.start * 1000);
                      endEl.value = util.toSmpteString(_popcornOptions.end * 1000);
                  }


                  updateUI();

                  return {
                      el: el,
                      updateUI: updateUI
                  };
              };

              function Trimmer(el) {
                  var __this = _this;
                  var MIN_VISUAL_WIDTH = 5;

                  var rightHandle = el.querySelector(".trimmer-resizable-e"),
                      leftHandle = el.querySelector(".trimmer-resizable-w"),
                      outInput = _rootElement.querySelector(".trimmer-input-right"),
                      inInput = _rootElement.querySelector(".trimmer-input-left"),
                      clipSection = el.querySelector(".clip-section"),
                      clipEndLabel = el.querySelector(".clip-end"),
                      clipStartLabel = el.querySelector(".clip-start");




                  var firstX,
                      startLeft,
                      startWidth,
                      activeHandle,
                      updateOptions = {};

                  function positionToTime(pos) {
                      var w = $(el).width();
                      var len = _trackEvent.clipdata.duration - _trackEvent.clipdata.from;

                      return util.roundTime((pos / w) * len);

                      //return util.roundTime(_app.pixelToTime(pos) / 1000);
                  }

                  function timeToPosition(time) {

                      //var p = _app.timeToPixel(time * 1000);
                      var w = $(el).width();
                      var len = _trackEvent.clipdata.duration - _trackEvent.clipdata.from;
                      //var u = len / w;

                      return (time / len) * w;

                      //return p * u;
                  }

                  function updateUI(options) {
                      var start,
                          end,
                          from;

                      options = options || _popcornOptions;
                      start = options.start;
                      end = options.end;
                      from = options.from;

                      if (!from && from !== 0) {
                          from = _popcornOptions.from;
                      }

                      if (!end && end !== 0) {
                          end = _popcornOptions.end;
                      }

                      if (!start && start !== 0) {
                          start = _popcornOptions.start;
                      }

                      // Adjust UI to account for very small durations
                      if (timeToPosition(end - start) < MIN_VISUAL_WIDTH) {
                          clipSection.classList.add("small");
                      } else {
                          clipSection.classList.remove("small");
                      }

                      clipSection.style.left = timeToPosition(from - _trackEvent.clipdata.from) + "px";
                      inInput.value = util.toSmpteString(from * 1000);

                      clipSection.style.width = timeToPosition(end - start) + "px";
                      var endt = from + end - start;
                      if (Math.abs(endt - _popcornOptions.duration) < 0.06) {
                          endt = _popcornOptions.duration;
                      }
                      outInput.value = util.toSmpteString(endt* 1000);

                      if (options.duration) {
                          clipEndLabel.innerHTML = util.toSmpteString(_trackEvent.clipdata.duration * 1000);
                      }
                      clipStartLabel.innerHTML = util.toSmpteString(_trackEvent.clipdata.from * 1000);
                  }

                  //function updateEndAfterExpand() {
                  //    var track = _trackEvent.track;
                  //    track.removeTrackEvent(_trackEvent);
                  //    track.addTrackEvent(_trackEvent);
                  //    _this.updateTrackEventSafe(_trackEvent, updateOptions);
                  //    _butter.unlisten("mediaready", updateEndAfterExpand);
                  //    _butter.currentTime = _popcornOptions.start;
                  //    updateUI();
                  //    updateOptions = {};
                  //}

                  function updateTrackEvent(options) {
                      if (!_app.media.paused) {
                          _app.media.pause();
                      }
                      _this.updateTrackEventSafe(_trackEvent, options);
                      updateOptions = {};
                      updateUI();

                      _app.media.updateDuration();
                  }

                  function onResizeStop() {
                      var accuracy,
                          start = updateOptions.start || _popcornOptions.start,
                          end = updateOptions.end || _popcornOptions.end;

                      el.classList.remove("editing");

                      if (activeHandle === "left") {
                          //accuracy = start * Math.pow(10, Time.timeAccuracy - 1);
                          //butter.currentTime = start === 0 ? start : Math.ceil(start * accuracy) / accuracy;
                      } else if (activeHandle === "right") {
                          //accuracy = end * Math.pow(10, Time.timeAccuracy - 1);
                          //butter.currentTime = Math.floor(end * accuracy) / accuracy;
                      }

                      updateTrackEvent(updateOptions);
                      activeHandle = "";

                      document.removeEventListener("mousemove", onResizingRight, false);
                      document.removeEventListener("mousemove", onResizingLeft, false);
                      document.removeEventListener("mouseup", onResizeStop, false);
                  }


                  function onResizingLeft(e) {
                      e.preventDefault();
                      var left = startLeft + e.clientX - firstX,
                          width = startWidth - (e.clientX - firstX);

                      if (left < 0) {
                          width += left;
                          left = 0;
                      }

                      if (width < 0) {
                          return;
                      }

                      updateOptions.end = _popcornOptions.start + positionToTime(width);
                      updateOptions.from = positionToTime(left) + _trackEvent.clipdata.from;
                      updateOptions.duration = updateOptions.from + (updateOptions.end -_popcornOptions.start);
                      updateUI({
                          from: updateOptions.from,
                          end: updateOptions.end
                      });

                  }

                  function onResizingRight(e) {
                      e.preventDefault();
                      var left = clipSection.offsetLeft,
                          width = startWidth + e.clientX - firstX;

                      if (left + width > el.offsetWidth) {
                          width = el.offsetWidth - left;
                      }

                      if (width < 0) {
                          return;
                      }

                      updateOptions.end = _popcornOptions.start + positionToTime(width);
                      updateOptions.duration = _popcornOptions.from + (updateOptions.end - _popcornOptions.start);

                      updateUI({
                          end: updateOptions.end
                      });

                  }

                  function onResizeStart(e) {
                      e.preventDefault(); // Prevent selection
                      el.classList.add("editing");

                      firstX = e.clientX;
                      startLeft = clipSection.offsetLeft;
                      startWidth = clipSection.offsetWidth;

                      if (this === rightHandle) {
                          document.addEventListener("mousemove", onResizingRight);
                          activeHandle = "right";
                      } else if (this === leftHandle) {
                          activeHandle = "left";
                          document.addEventListener("mousemove", onResizingLeft);
                      }
                      document.addEventListener("mouseup", onResizeStop);
                  }


                  function onDragStop() {
                      el.classList.remove("editing");
                      updateTrackEvent(updateOptions);
                      document.removeEventListener("mouseup", onDragStop, false);
                      document.removeEventListener("mousemove", onDragging, false);
                  }

                  function onDragging(e) {
                      e.preventDefault(); // Prevent selection
                      var left = startLeft + e.clientX - firstX,
                          width = clipSection.offsetWidth;

                      if (left < 0) {
                          left = 0;
                      }

                      if (left + width > el.offsetWidth) {
                          left = el.offsetWidth - width;
                      }

                      if (width < 0) {
                          return;
                      }

                      updateOptions.from = positionToTime(left);
                      updateUI({
                          from: updateOptions.from
                      });
                  }

                  function onDragStart(e) {
                      e.preventDefault();
                      if (e.target !== clipSection) {
                          // We are resizing, not dragging.
                          return;
                      }

                      el.classList.add("editing");

                      firstX = e.clientX;
                      startLeft = clipSection.offsetLeft;
                      startWidth = clipSection.offsetWidth;
                      document.addEventListener("mousemove", onDragging);
                      document.addEventListener("mouseup", onDragStop);
                  }

                  function onRightInputChange() {
                      try {
                          var val = util.roundTime(this.value);
                          if (val > _popcornOptions.duration) {
                              __this._trackEventUpdateErrorCallback('error value');
                              return;
                          }
                          updateOptions.end = _popcornOptions.start + val - _popcornOptions.from;
                          updateTrackEvent(updateOptions);
                      } catch (e) {
                          __this._trackEventUpdateErrorCallback(e.toString());
                      }
                  }

                  function onLeftInputChange() {
                      try {
                          var val = util.roundTime(this.value);
                          updateOptions.from = val;
                          updateOptions.end = _popcornOptions.end + (_popcornOptions.from - val);
                          updateTrackEvent(updateOptions);
                      } catch (e) {
                          __this._trackEventUpdateErrorCallback(e.toString());
                      }
                  }

                  function onWindowMousedownRight(e) {
                      e.stopPropagation();
                      e.preventDefault();
                      // This triggers a change event.
                      outInput.blur();
                      outInput.addEventListener("keydown", onRightKeydown);
                      window.removeEventListener("mousedown", onWindowMousedownRight, true);
                  }
                  function onWindowMousedownLeft(e) {
                      e.stopPropagation();
                      e.preventDefault();
                      // This triggers a change event.
                      inInput.blur();
                      inInput.addEventListener("keydown", onLeftKeydown);
                      window.removeEventListener("mousedown", onWindowMousedownLeft, true);
                  }
                  function onRightKeydown(e) {
                          var a = /[\d.:]/.test(String.fromCharCode(event.keyCode));
                          if (!a && (event.keyCode != 8 && event.keyCode != 46)) {
                              e.stopPropagation();
                              e.preventDefault();
                              return false;
                          }
                      outInput.removeEventListener("keydown", onRightKeydown, false);
                      window.addEventListener("mousedown", onWindowMousedownRight, true);
                  }
                  function onLeftKeydown(e) {
                      var a = /[\d.:]/.test(String.fromCharCode(event.keyCode));
                      if (!a && (event.keyCode != 8 && event.keyCode != 46)) {
                          e.stopPropagation();
                          e.preventDefault();
                          return false;
                      }
                      inInput.removeEventListener("keydown", onLeftKeydown, false);
                      window.addEventListener("mousedown", onWindowMousedownLeft, true);
                  }
                  function onRightKeyup(e) {
                      element.value = element.value.replace(/[\u4e00-\u9fa5]/g, '');
                      outInput.removeEventListener("keyup", onRightKeyup, false);
                     // window.addEventListener("mousedown", onWindowMousedownRight, true);
                  }
                  function onLeftKeyup(e) {
                      element.value = element.value.replace(/[\u4e00-\u9fa5]/g, '');
                      inInput.removeEventListener("keyup", onLeftKeyup, false);
                     // window.addEventListener("mousedown", onWindowMousedownLeft, true);
                  }
                  // Setup
                  outInput.addEventListener("change", onRightInputChange);
                  inInput.addEventListener("change", onLeftInputChange);
                  outInput.addEventListener("keypress", onRightKeydown);
                  inInput.addEventListener("keypress", onLeftKeydown);
                  //outInput.addEventListener("keyup", onRightKeyup);
                 // inInput.addEventListener("keyup", onLeftKeyup);
                  rightHandle.addEventListener("mousedown", onResizeStart);
                  leftHandle.addEventListener("mousedown", onResizeStart);
                  clipSection.addEventListener("mousedown", onDragStart);
                  updateUI();

                  return {
                      el: el,
                      updateUI: updateUI
                  };
              };


              function setup(trackEvent) {
                  _trackEvent = trackEvent;
                  _popcornOptions = _trackEvent.popcornOptions,
                  _manifest = _trackEvent.manifest.options,
                  basicContainer = _rootElement.querySelector(".editor-options");

                  var startEndContainer = _rootElement.querySelector(".start-end-container"),
                      clipTrimmerEl = _rootElement.querySelector(".clip-duration"),
                      createdateEl = basicContainer.querySelector(".trackevent-property.createdate input");
                  if (trackEvent.track.trackType == 'A'){
                      _rootElement.querySelector('h1').innerText = lang[_curLang].audio;
                      }
                  _fields.startEnd = new StartEnd(startEndContainer, "start", _this.updateTrackEventSafe);
                  _fields.from = new Trimmer(clipTrimmerEl);

                  if (_popcornOptions.createdate) createdateEl.value = _popcornOptions.createdate;

                  var titleElement = _this.createManifestItem("title", trackEvent.manifest.options["title"], trackEvent.popcornOptions["title"], trackEvent);
                  if (titleElement) {
                      basicContainer.insertBefore(titleElement, basicContainer.firstChild);
                      _fields.title = {
                          el: titleElement,
                          updateUI: function () {
                              titleElement.querySelector("input").value = _popcornOptions.title;
                          }
                      };
                      _fields.title.updateUI();
                  }



                  window.setTimeout(function () {
                      _fields.from.updateUI();
                  }, 0);
              };

              function onTrackEventUpdated(e) {
                  _trackEvent = e.target;
                  _popcornOptions = _trackEvent.popcornOptions;

                  for (var key in _manifest) {
                      if (_manifest.hasOwnProperty(key)) {
                          if (key === "start" || key === "end") {
                              key = "startEnd";
                          }
                          if (_fields[key] && _fields[key].updateUI) {
                              _fields[key].updateUI();
                          }
                      }
                  }
                  _this.setErrorState(false);
              };

              function panelResize() {
                  if (_fields && _fields.from) {
                      _fields.from.updateUI();
                  }

              }

              events.open = function (parentElement, trackEvent) {
                  trackEvent.addEventListener("trackeventupdated", onTrackEventUpdated);
                  setup(trackEvent);
                  app.propertyPanel.addEventListener("resize", panelResize);
              };
              events.close = function () {
                  _trackEvent.removeEventListener("trackeventupdated", onTrackEventUpdated);
                  app.propertyPanel.removeEventListener("resize", panelResize);
              };

              _this._super(rootElement, app, events);
          }
      });


      return {
          name: 'PopcornMediaPlugin',
          editor: MediaEditor,
          layout: MEDIA_TRACKEVENT_EDITOR_LAYOUT,
          persist: false,
          callback: function (trackEvent) {
              //更新回调
              var _container,
                  target;

              _container = trackEvent.popcornTrackEvent.container;
              target = trackEvent.popcornTrackEvent.timelinePlayer.element;


              this.selectable(trackEvent, _container);
          }
      };

  });


h5.define('templates/ImageTrackEventEditorLayout', [], function () {
    return '<div class="h5-editor h5-form image-editor">\
  <h1>' + lang[_curLang].picture + '</h1>\
  <div class="h5-editor-body scrollbar-container" style="top:30px;">\
    <div class="wrapper">\
            <div class="content">\
                  <div class="error-message-container">\
                    <div class="error-message"></div>\
                  </div>\
                <div class="editor-options">\
                    <fieldset class="trackevent-property createdate">\
                        <label class="property-createdate">' + lang[_curLang].createTime + '</label>\
                        <div class="info_textbox"><input class="value" type="text" readonly="true"></div>\
                    </fieldset>\
                </div>\
            </div>\
        </div>\
    </div>\
</div>';


//<style>
//  .image-toggler > select {
//        width: 50%;
//  }

//    .image-number > input {
//        width: 35%;
//    }

//    .flickr-image-time {
//        float: right;
//        padding-right: 10px;
//    }

//    .image-time-bold {
//        font-weight: bold;
//    }

//    .image-text {
//        font-size: 10px;
//    }

//    </style>';


});


/*
 * 图片可视化编辑器
 */
h5.define('editor/ImageEditor', ["jquery", "editor/TrackEventEditor", "util/util", "templates/ImageTrackEventEditorLayout"],
  function ($, TrackEventEditor, util, IMAGE_TRACKEVENT_EDITOR_LAYOUT) {

      var ImageEditor = TrackEventEditor.TrackEventEditor.extend({
          init: function (rootElement, app) {

              var events = {},
                  _this = this,
                  _rootElement = rootElement,
                  _trackEvent,
                  _popcornOption,
                  basicContainer;

              function setup(trackEvent) {

                  _trackEvent = trackEvent;
                  _popcornOptions = _trackEvent.popcornOptions;
                  basicContainer = _rootElement.querySelector(".editor-options");

                  var createdateEl = basicContainer.querySelector(".trackevent-property.createdate input");
                  if (_popcornOptions.createdate) createdateEl.value = _popcornOptions.createdate;


                  basicContainer.insertBefore(_this.createStartEndInputs(trackEvent, _this.updateTrackEventSafe), basicContainer.firstChild);

                  var titleElement = _this.createManifestItem("title", trackEvent.manifest.options["title"], trackEvent.popcornOptions["title"], trackEvent);
                  if (titleElement) {
                      basicContainer.insertBefore(titleElement, basicContainer.firstChild);
                  }


                  //basicContainer.appendChild(_this.createSetAsDefaultsButton(trackEvent));
                  _this.updatePropertiesFromManifest(trackEvent);

              }



              function onTrackEventUpdated(e) {
                  _trackEvent = e.target;

                  _this.updatePropertiesFromManifest(_trackEvent);
                  _this.setErrorState(false);
              }

              var events = {};
              events.open = function (parentElement, trackEvent) {
                  trackEvent.addEventListener("trackeventupdated", onTrackEventUpdated);
                  setup(trackEvent);

              }
              events.close = function () {
                  _trackEvent.removeEventListener("trackeventupdated", onTrackEventUpdated);
              }

              _this._super(rootElement, app, events);
          }
      });



      function updateCallback(trackEvent, popcornInstance, $) {

          var _popcornOptions = trackEvent.popcornTrackEvent,
             // _container = _popcornOptions._container,
                           _container = trackEvent.popcornTrackEvent.container,
          _target = trackEvent.popcornTrackEvent.timelinePlayer.element,

              _clone,
              _cloneContainer,
              _src = _popcornOptions.src;
             // _target = _popcornOptions._target;

          var __EditorHelper = this;

          function createHelper(suffix) {
              var el = document.createElement("div");
              el.classList.add("ui-resizable-handle");
              el.classList.add("ui-resizable-" + suffix);
              return el;
          }

          this.selectable(trackEvent, _container);

          trackEvent.draggable = this.draggable(trackEvent, _container, _target, {
              disableTooltip: true,
              editable: false
          });


          _container.appendChild(createHelper("top"));
          _container.appendChild(createHelper("bottom"));
          _container.appendChild(createHelper("left"));
          _container.appendChild(createHelper("right"));

          if (!$(_container).data("resizable")) {
              $(_container).resizable({
                  //handles: "n,ne,e,se,s,sw,w,nw",
                  handles: "all",
                  containment: "parent",
                  zIndex: 1000,
                  start: function () {
                      var image = trackEvent.popcornTrackEvent.image;
                      if (image && _container.classList.contains("track-event-editing")) {
                          image.style.top = image.offsetTop + "px";
                          image.style.left = image.offsetLeft + "px";
                          image.style.width = image.clientWidth + "px";
                          image.style.height = image.clientHeight + "px";
                          if (_clone) {
                              _clone.style.width = _clone.clientWidth + "px";
                              _clone.style.height = _clone.clientHeight + "px";
                              _cloneContainer.style.width = _cloneContainer.clientWidth + "px";
                              _cloneContainer.style.height = _cloneContainer.clientHeight + "px";
                              _clone.style.top = _clone.offsetTop + "px";
                              _clone.style.left = _clone.offsetLeft + "px";
                              _cloneContainer.style.top = _cloneContainer.offsetTop + "px";
                              _cloneContainer.style.left = _cloneContainer.offsetLeft + "px";
                          }
                      }
                  },
                  stop: function (event, ui) {
                      var image = trackEvent.popcornTrackEvent.image,
                          width = _container.clientWidth,
                          height = _container.clientHeight,
                          left = ui.position.left,
                          top = ui.position.top,
                          imageHeight,
                          imageWidth,
                          imageTop,
                          imageLeft;

                      if (left < 0) {
                          width += left;
                          left = 0;
                      }
                      if (top < 0) {
                          height += top;
                          top = 0;
                      }

                      if (width + left > _target.clientWidth) {
                          width = _target.clientWidth - left;
                      }
                      if (height + top > _target.clientHeight) {
                          height = _target.clientHeight - top;
                      }

                      width = width / _target.clientWidth * 100;
                      height = height / _target.clientHeight * 100;
                      left = left / _target.clientWidth * 100;
                      top = top / _target.clientHeight * 100;

                      if (image) {

                          imageWidth = image.offsetWidth / _container.clientWidth * 100;
                          imageHeight = image.offsetHeight / _container.clientHeight * 100;
                          imageTop = image.offsetTop / _container.clientHeight * 100;
                          imageLeft = image.offsetLeft / _container.clientWidth * 100;

                          _container.style.width = width + "%";
                          _container.style.height = height + "%";
                          _container.style.top = top + "%";
                          _container.style.left = left + "%";

                          image.style.width = imageWidth + "%";
                          image.style.height = imageHeight + "%";
                          image.style.top = imageTop + "%";
                          image.style.left = imageLeft + "%";

                          trackEvent.update({
                              innerWidth: imageWidth,
                              innerHeight: imageHeight,
                              innerTop: imageTop,
                              innerLeft: imageLeft,
                              width: width,
                              height: height,
                              left: left,
                              top: top
                          });
                      } else {

                          trackEvent.update({
                              width: width,
                              height: height,
                              left: left,
                              top: top
                          });
                      }
                  }
              });
          }

          //// The image plugin doesn't use an update function.
          //// If it did, we wouldn't be able to set this up again and again.
          //// We would need to make sure nothing gets duplicated on an update.
          //if (trackEvent.popcornTrackEvent.image && trackEvent.popcornOptions.src) {
          //    _cloneContainer = document.createElement("div");
          //    _cloneContainer.classList.add("clone-container");
          //    _clone = trackEvent.popcornTrackEvent.image.cloneNode();
          //    _clone.classList.add("image-crop-clone");
          //    _cloneContainer.appendChild(_clone);
          //    _container.appendChild(_cloneContainer);

          //    _clone.appendChild(createHelper("top"));
          //    _clone.appendChild(createHelper("bottom"));
          //    _clone.appendChild(createHelper("left"));
          //    _clone.appendChild(createHelper("right"));

          //    $(_clone).draggable({
          //        drag: function (event, ui) {
          //            trackEvent.popcornTrackEvent.image.style.top = ui.position.top + "px";
          //            trackEvent.popcornTrackEvent.image.style.left = ui.position.left + "px";
          //        },
          //        stop: function (event, ui) {
          //            var top = ui.position.top / _container.clientHeight * 100,
          //                left = ui.position.left / _container.clientWidth * 100;

          //            trackEvent.update({
          //                innerTop: top,
          //                innerLeft: left
          //            });
          //            trackEvent.draggable.edit();
          //        }
          //    });

          //    $(_clone).resizable({
          //        handles: "n, ne, e, se, s, sw, w, nw",
          //        resize: function (event, ui) {
          //            trackEvent.popcornTrackEvent.image.style.height = _clone.clientHeight + "px";
          //            trackEvent.popcornTrackEvent.image.style.width = _clone.clientWidth + "px";
          //            _clone.style.height = _clone.clientHeight + "px";
          //            _clone.style.width = _clone.clientWidth + "px";
          //            trackEvent.popcornTrackEvent.image.style.top = ui.position.top + "px";
          //            trackEvent.popcornTrackEvent.image.style.left = ui.position.left + "px";
          //            _clone.style.top = ui.position.top + "px";
          //            _clone.style.left = ui.position.left + "px";
          //        },
          //        stop: function (event, ui) {
          //            trackEvent.update({
          //                innerHeight: _clone.offsetHeight / _container.clientHeight * 100,
          //                innerWidth: _clone.offsetWidth / _container.clientWidth * 100,
          //                innerTop: ui.position.top / _container.clientHeight * 100,
          //                innerLeft: ui.position.left / _container.clientWidth * 100
          //            });
          //            trackEvent.draggable.edit();
          //        }
          //    });
          //}
      };

      return {
          name: 'PopcornImagePlugin',
          editor: ImageEditor,
          layout: IMAGE_TRACKEVENT_EDITOR_LAYOUT,
          persist: false,
          callback: updateCallback
      };
  });
//(function (Butter) {

//    var Editor = Butter.Editor;

//    var __EditorHelper;

//    Editor.register("image", "load!{{baseDir}}plugins/image-editor.html",
//                     function (rootElement, butter, compiledLayout) {

//                         var _rootElement = rootElement,
//                             _tagRadio = _rootElement.querySelector("#image-tag-radio"),
//                             _galleryRadio = _rootElement.querySelector("#image-gallery-radio"),
//                             _tagInput = _rootElement.querySelector("#image-tag-input"),
//                             _galleryInput = _rootElement.querySelector("#image-gallery-input"),
//                             _urlInput = _rootElement.querySelector("#image-url-input"),
//                             _titleInput = _rootElement.querySelector("#image-title-input"),
//                             _linkInput = _rootElement.querySelector("#image-link-input"),
//                             _countInput = _rootElement.querySelector("#image-count-input"),
//                             _singleImageTab = _rootElement.querySelector(".image-single"),
//                             _flickrImageTab = _rootElement.querySelector(".image-flickr"),
//                             _dropArea = _rootElement.querySelector(".image-droparea"),
//                             _imageToggler = _rootElement.querySelector("#image-toggler"),
//                             _urlRegex,
//                             _this = this,
//                             _trackEvent,
//                             _galleryActive = false,
//                             _tagsActive = false,
//                             _flickrActive = false,
//                             _singleActive = false,
//                             _popcornInstance,
//                             _inSetup,
//                             _cachedValues;

//                         function updateTrackEvent(te, props) {
//                             _this.setErrorState();
//                             _this.updateTrackEventSafe(te, props);
//                         }

//                         function toggleTabs() {
//                             _singleImageTab.classList.toggle("display-off");
//                             _flickrImageTab.classList.toggle("display-off");
//                         }

//                         function attachDropHandlers() {
//                             __EditorHelper.uploader(_trackEvent, _dropArea);
//                             __EditorHelper.droppable(_trackEvent, _dropArea);
//                             butter.listen("droppable-unsupported", unSupported);
//                             butter.listen("droppable-upload-failed", failedUpload);
//                             butter.listen("droppable-succeeded", uploadSuceeded);
//                         }

//                         function unSupported() {
//                             _this.setErrorState(Butter.localized.get("Sorry, but your browser doesn't support this feature."));
//                         }

//                         function failedUpload(e) {
//                             _this.setErrorState(e.data);
//                         }

//                         function uploadSuceeded(e) {
//                             _dropArea.querySelector("img").src = e.data.url;
//                         }

//                         function calcImageTime() {
//                             var imageTime = rootElement.querySelector(".image-time-bold"),
//                                 popcornOptions = _trackEvent.popcornOptions,
//                                 eventDuration = popcornOptions.end - popcornOptions.start,
//                                 time;

//                             time = Math.round((eventDuration / popcornOptions.count) * (Math.pow(10, 1))) / Math.pow(10, 1);
//                             time = time > 0.01 ? time : 0.01;

//                             imageTime.innerHTML = time + " seconds";
//                         }

//                         function galleryHandler() {
//                             if (!_galleryActive && !_inSetup) {
//                                 _galleryActive = true;
//                                 _trackEvent.update({
//                                     src: "",
//                                     linkSrc: "",
//                                     tags: "",
//                                     photosetId: _cachedValues.photosetId.data
//                                 });
//                             }
//                             _tagsActive = _galleryInput.disabled = false;
//                             _tagInput.disabled = _galleryRadio.checked = true;
//                             _galleryInput.classList.remove("butter-disabled");
//                             _tagInput.classList.add("butter-disabled");
//                         }

//                         function tagHandler() {
//                             if (!_tagsActive && !_inSetup) {
//                                 _tagsActive = true;
//                                 _trackEvent.update({
//                                     tags: _cachedValues.tags.data,
//                                     src: "",
//                                     linkSrc: "",
//                                     photosetId: ""
//                                 });
//                             }

//                             _galleryActive = _tagInput.disabled = false;
//                             _tagInput.classList.remove("butter-disabled");
//                             _galleryInput.disabled = _tagRadio.checked = true;
//                             _galleryInput.classList.add("butter-disabled");
//                         }

//                         function isEmptyInput(value) {
//                             return value === "";
//                         }

//                         function isDataURI(url) {
//                             return (/^data:image/).test(url);
//                         }

//                         function flickrHandler() {
//                             var popcornOptions = _trackEvent.popcornOptions;

//                             _flickrActive = true;
//                             _singleActive = false;

//                             if (_flickrImageTab.classList.contains("display-off")) {
//                                 toggleTabs();
//                                 _imageToggler.value = "image-flickr";
//                             }

//                             // Default state is Using a Flickr Tag Search. This ensures that even if the first two conditions are false
//                             // that a default state is still properly applied
//                             if (_tagsActive || popcornOptions.tags || (!popcornOptions.tags && !popcornOptions.photosetId)) {
//                                 tagHandler();
//                             } else {
//                                 galleryHandler();
//                             }

//                             calcImageTime();
//                         }

//                         function singleImageHandler() {
//                             _galleryActive = _tagsActive = _flickrActive = false;

//                             if (!_singleActive && !_inSetup) {
//                                 _singleActive = true;
//                                 _trackEvent.update({
//                                     src: _cachedValues.src.data,
//                                     linkSrc: _cachedValues.linkSrc.data,
//                                     tags: "",
//                                     photosetId: ""
//                                 });
//                             }

//                             if (isDataURI(_trackEvent.popcornOptions.src)) {
//                                 _urlInput.value = "data:image";
//                             }

//                             if (_singleImageTab.classList.contains("display-off")) {
//                                 toggleTabs();
//                                 _imageToggler.value = "image-single";
//                             }
//                         }

//                         // Mode specifies what values should be retrieved from the cached values
//                         function displayCachedValues(mode) {
//                             var element;

//                             // Repopulate fields with old values to prevent confusion
//                             for (var i in _cachedValues) {
//                                 if (_cachedValues.hasOwnProperty(i)) {
//                                     element = _rootElement.querySelector("[data-manifest-key='" + i + "']");

//                                     if (_cachedValues[i].type === mode) {
//                                         if (isDataURI(_cachedValues[i].data)) {
//                                             _urlInput.value = "data:image";
//                                         } else {
//                                             element.value = _cachedValues[i].data;
//                                         }
//                                     }
//                                 }
//                             }
//                         }

//                         function setup(trackEvent) {
//                             var container = _rootElement.querySelector(".editor-options"),
//                                 startEndElement,
//                                 manifestOpts = trackEvent.popcornTrackEvent._natives.manifest.options;

//                             _inSetup = true;
//                             _urlRegex = manifestOpts.linkSrc.validation;

//                             function callback(elementType, element, trackEvent, name) {
//                                 if (elementType === "select") {
//                                     _this.attachSelectChangeHandler(element, trackEvent, name);
//                                 }
//                             }

//                             function attachHandlers() {
//                                 _this.attachInputChangeHandler(_urlInput, trackEvent, "src", function (te, prop) {
//                                     var src = prop.src;

//                                     if (isEmptyInput(src)) {
//                                         return;
//                                     }

//                                     // Chrome can't display really long dataURIs in their text inputs. This is to prevent accidentally
//                                     // removing their image
//                                     if (src === "data:image" && isDataURI(te.popcornTrackEvent.src)) {
//                                         src = te.popcornTrackEvent.src;
//                                     }

//                                     _dropArea.querySelector("img").src = _cachedValues.src.data = src;

//                                     updateTrackEvent(te, {
//                                         src: src,
//                                         tags: "",
//                                         photosetId: ""
//                                     });
//                                 });

//                                 _this.attachInputChangeHandler(_titleInput, trackEvent, "title", updateTrackEvent);

//                                 _this.createTooltip(_linkInput, {
//                                     name: "image-link-tooltip" + Date.now(),
//                                     element: _linkInput.parentElement,
//                                     message: Butter.localized.get("Links will be clickable when shared."),
//                                     top: "105%",
//                                     left: "50%",
//                                     hidden: true,
//                                     hover: false
//                                 });

//                                 _this.attachInputChangeHandler(_linkInput, trackEvent, "linkSrc", function (te, prop) {
//                                     if (prop.linkSrc.match(_urlRegex)) {
//                                         _cachedValues.linkSrc.data = prop.linkSrc;

//                                         updateTrackEvent(te, {
//                                             linkSrc: prop.linkSrc
//                                         });
//                                     } else if (prop.linkSrc !== "") {
//                                         _this.setErrorState(Butter.localized.get("Not a valid URL"));
//                                     } else {
//                                         updateTrackEvent(te, {
//                                             linkSrc: ""
//                                         });
//                                     }
//                                 });

//                                 _this.attachInputChangeHandler(_galleryInput, trackEvent, "photosetId", function (te, prop) {
//                                     if (isEmptyInput(prop.photosetId)) {
//                                         return;
//                                     }

//                                     _cachedValues.photosetId.data = prop.photosetId;

//                                     updateTrackEvent(te, {
//                                         src: "",
//                                         linkSrc: "",
//                                         tags: "",
//                                         photosetId: prop.photosetId
//                                     });
//                                 });

//                                 _this.attachInputChangeHandler(_tagInput, trackEvent, "tags", function (te, prop) {
//                                     if (isEmptyInput(prop.tags)) {
//                                         return;
//                                     }

//                                     _cachedValues.tags.data = prop.tags;

//                                     updateTrackEvent(te, {
//                                         src: "",
//                                         linkSrc: "",
//                                         tags: prop.tags,
//                                         photosetId: ""
//                                     });
//                                 });

//                                 _this.attachInputChangeHandler(_countInput, trackEvent, "count", function (te, prop) {
//                                     var count = prop.count > 0 ? prop.count : 1;

//                                     if (isEmptyInput(prop.count)) {
//                                         return;
//                                     }

//                                     _cachedValues.count.data = count;

//                                     updateTrackEvent(te, {
//                                         count: count
//                                     });
//                                 });

//                                 // Wrap specific input elements
//                                 _this.wrapTextInputElement(_urlInput);
//                                 _this.wrapTextInputElement(_titleInput);
//                                 _this.wrapTextInputElement(_linkInput);
//                                 _this.wrapTextInputElement(_galleryInput);

//                                 _tagRadio.addEventListener("click", tagHandler);
//                                 _galleryRadio.addEventListener("click", galleryHandler);

//                                 attachDropHandlers();
//                             }

//                             startEndElement = _this.createStartEndInputs(trackEvent, updateTrackEvent);
//                             container.insertBefore(startEndElement, container.firstChild);

//                             _this.createPropertiesFromManifest({
//                                 trackEvent: trackEvent,
//                                 callback: callback,
//                                 basicContainer: container,
//                                 manifestKeys: ["transition"]
//                             });

//                             attachHandlers();
//                             container.appendChild(_this.createSetAsDefaultsButton(trackEvent));
//                             _this.updatePropertiesFromManifest(trackEvent);
//                             _this.setTrackEventUpdateErrorCallback(_this.setErrorState);

//                             if (trackEvent.popcornOptions.src) {
//                                 _singleActive = true;
//                                 singleImageHandler();
//                                 displayCachedValues("single");
//                             } else {
//                                 flickrHandler();
//                                 displayCachedValues("flickr");
//                             }

//                             _this.scrollbar.update();
//                             _inSetup = false;
//                         }

//                         function toggleHandler(e) {
//                             toggleTabs();

//                             if (e.target.value === "image-single") {
//                                 singleImageHandler();
//                             } else {
//                                 flickrHandler();
//                             }

//                             _this.scrollbar.update();
//                         }

//                         function clickPrevention() {
//                             return false;
//                         }

//                         function onTrackEventUpdated(e) {
//                             _trackEvent = e.target;
//                             calcImageTime();
//                             _this.updatePropertiesFromManifest(_trackEvent);
//                             _this.setErrorState(false);

//                             var links, i, ln,
//                                 src = _trackEvent.popcornOptions.src;

//                             if (_trackEvent.popcornTrackEvent._container) {
//                                 links = _trackEvent.popcornTrackEvent._container.querySelectorAll("a");

//                                 if (links) {
//                                     for (i = 0, ln = links.length; i < ln; i++) {
//                                         links[i].onclick = clickPrevention;
//                                     }
//                                 }
//                             }

//                             // Droppable images aren't getting their data URIs cached so just perform a double check here
//                             // on updating
//                             if (src) {
//                                 _cachedValues.src.data = src;
//                             }

//                             // Ensure right group is displayed
//                             // Mode is flipped here to ensure cached values aren't placed right back in after updating
//                             if (src && !_flickrActive) {
//                                 singleImageHandler();
//                                 displayCachedValues("flickr");
//                             } else if (_flickrActive) {
//                                 flickrHandler();
//                                 displayCachedValues("single");
//                             }

//                             _this.scrollbar.update();
//                         }

//                         Editor.TrackEventEditor.extend(_this, butter, rootElement, {
//                             open: function (parentElement, trackEvent) {
//                                 var popcornOptions = trackEvent.popcornOptions,
//                                     manifestOpts = trackEvent.popcornTrackEvent._natives.manifest.options;

//                                 if (!_cachedValues) {
//                                     _cachedValues = {
//                                         src: {
//                                             data: popcornOptions.src || manifestOpts.src.default,
//                                             type: "single"
//                                         },
//                                         linkSrc: {
//                                             data: popcornOptions.linkSrc,
//                                             type: "single"
//                                         },
//                                         tags: {
//                                             data: popcornOptions.tags || manifestOpts.tags.default,
//                                             type: "flickr"
//                                         },
//                                         photosetId: {
//                                             data: popcornOptions.photosetId || manifestOpts.photosetId.default,
//                                             type: "flickr"
//                                         },
//                                         count: {
//                                             data: popcornOptions.count,
//                                             type: "flickr"
//                                         }
//                                     };
//                                 }

//                                 _popcornInstance = trackEvent.track._media.popcorn.popcorn;
//                                 _imageToggler.addEventListener("change", toggleHandler);

//                                 _this.applyExtraHeadTags(compiledLayout);
//                                 _trackEvent = trackEvent;
//                                 _dropArea.querySelector("img").src = _trackEvent.popcornOptions.src;

//                                 // The current popcorn instance
//                                 _popcornInstance.on("invalid-flickr-image", function () {
//                                     _this.setErrorState(Butter.localized.get("Invalid Flicker Gallery URL"));
//                                 });

//                                 _popcornInstance.on("popcorn-image-count-update", function (count) {
//                                     _trackEvent.popcornOptions.count = count;
//                                     _cachedValues.count.data = count;
//                                     _countInput.value = count;
//                                 });

//                                 _popcornInstance.on("popcorn-image-failed-retrieve", function () {
//                                     _this.setErrorState(Butter.localized.get("No Images"));
//                                 });

//                                 _trackEvent.listen("trackeventupdated", onTrackEventUpdated);

//                                 setup(trackEvent);
//                             },
//                             close: function () {
//                                 _imageToggler.removeEventListener("change", toggleHandler, false);
//                                 _this.removeExtraHeadTags();
//                                 butter.unlisten("droppable-unsupported", unSupported);
//                                 butter.unlisten("droppable-upload-failed", failedUpload);
//                                 butter.unlisten("droppable-succeeded", uploadSuceeded);
//                                 _popcornInstance.off("invalid-flickr-image");
//                                 _trackEvent.unlisten("trackeventupdated", onTrackEventUpdated);
//                             }
//                         });
//                     }, false, function (trackEvent, popcornInstance, $) {

//                         var _popcornOptions = trackEvent.popcornTrackEvent,
//                             _container = _popcornOptions._container,
//                             _clone,
//                             _cloneContainer,
//                             _src = _popcornOptions.src,
//                             _target = _popcornOptions._target;

//                         // Work around since I can't just require it in for this editor.
//                         __EditorHelper = this;

//                         function createHelper(suffix) {
//                             var el = document.createElement("div");
//                             el.classList.add("ui-resizable-handle");
//                             el.classList.add("ui-resizable-" + suffix);
//                             return el;
//                         }

//                         this.selectable(trackEvent, _container);
//                         if (_src) {
//                             this.droppable(trackEvent, _container);

//                             var options = {
//                                 tooltip: "Double click to crop image"
//                             };

//                             if (_src.indexOf(trackEvent.manifest.options.src.FLICKR_SINGLE_CHECK) > -1) {
//                                 options.disableTooltip = true;
//                                 options.editable = false;
//                             }

//                             trackEvent.draggable = this.draggable(trackEvent, _container, _target, options);
//                         } else {
//                             trackEvent.draggable = this.draggable(trackEvent, _container, _target, {
//                                 disableTooltip: true,
//                                 editable: false
//                             });
//                         }

//                         _container.appendChild(createHelper("top"));
//                         _container.appendChild(createHelper("bottom"));
//                         _container.appendChild(createHelper("left"));
//                         _container.appendChild(createHelper("right"));

//                         if (!$(_container).data("resizable")) {
//                             $(_container).resizable({
//                                 handles: "n,ne,e,se,s,sw,w,nw",
//                                 containment: "parent",
//                                 start: function () {
//                                     var image = trackEvent.popcornTrackEvent.image;
//                                     if (image && _container.classList.contains("track-event-editing")) {
//                                         image.style.top = image.offsetTop + "px";
//                                         image.style.left = image.offsetLeft + "px";
//                                         image.style.width = image.clientWidth + "px";
//                                         image.style.height = image.clientHeight + "px";
//                                         if (_clone) {
//                                             _clone.style.width = _clone.clientWidth + "px";
//                                             _clone.style.height = _clone.clientHeight + "px";
//                                             _cloneContainer.style.width = _cloneContainer.clientWidth + "px";
//                                             _cloneContainer.style.height = _cloneContainer.clientHeight + "px";
//                                             _clone.style.top = _clone.offsetTop + "px";
//                                             _clone.style.left = _clone.offsetLeft + "px";
//                                             _cloneContainer.style.top = _cloneContainer.offsetTop + "px";
//                                             _cloneContainer.style.left = _cloneContainer.offsetLeft + "px";
//                                         }
//                                     }
//                                 },
//                                 stop: function (event, ui) {
//                                     var image = trackEvent.popcornTrackEvent.image,
//                                         width = _container.clientWidth,
//                                         height = _container.clientHeight,
//                                         left = ui.position.left,
//                                         top = ui.position.top,
//                                         imageHeight,
//                                         imageWidth,
//                                         imageTop,
//                                         imageLeft;

//                                     if (left < 0) {
//                                         width += left;
//                                         left = 0;
//                                     }
//                                     if (top < 0) {
//                                         height += top;
//                                         top = 0;
//                                     }

//                                     if (width + left > _target.clientWidth) {
//                                         width = _target.clientWidth - left;
//                                     }
//                                     if (height + top > _target.clientHeight) {
//                                         height = _target.clientHeight - top;
//                                     }

//                                     width = width / _target.clientWidth * 100;
//                                     height = height / _target.clientHeight * 100;
//                                     left = left / _target.clientWidth * 100;
//                                     top = top / _target.clientHeight * 100;

//                                     if (image) {

//                                         imageWidth = image.offsetWidth / _container.clientWidth * 100;
//                                         imageHeight = image.offsetHeight / _container.clientHeight * 100;
//                                         imageTop = image.offsetTop / _container.clientHeight * 100;
//                                         imageLeft = image.offsetLeft / _container.clientWidth * 100;

//                                         _container.style.width = width + "%";
//                                         _container.style.height = height + "%";
//                                         _container.style.top = top + "%";
//                                         _container.style.left = left + "%";

//                                         image.style.width = imageWidth + "%";
//                                         image.style.height = imageHeight + "%";
//                                         image.style.top = imageTop + "%";
//                                         image.style.left = imageLeft + "%";

//                                         trackEvent.update({
//                                             innerWidth: imageWidth,
//                                             innerHeight: imageHeight,
//                                             innerTop: imageTop,
//                                             innerLeft: imageLeft,
//                                             width: width,
//                                             height: height,
//                                             left: left,
//                                             top: top
//                                         });
//                                     } else {

//                                         trackEvent.update({
//                                             width: width,
//                                             height: height,
//                                             left: left,
//                                             top: top
//                                         });
//                                     }
//                                 }
//                             });
//                         }

//                         // The image plugin doesn't use an update function.
//                         // If it did, we wouldn't be able to set this up again and again.
//                         // We would need to make sure nothing gets duplicated on an update.
//                         if (trackEvent.popcornTrackEvent.image && trackEvent.popcornOptions.src) {
//                             _cloneContainer = document.createElement("div");
//                             _cloneContainer.classList.add("clone-container");
//                             _clone = trackEvent.popcornTrackEvent.image.cloneNode();
//                             _clone.classList.add("image-crop-clone");
//                             _cloneContainer.appendChild(_clone);
//                             _container.appendChild(_cloneContainer);

//                             _clone.appendChild(createHelper("top"));
//                             _clone.appendChild(createHelper("bottom"));
//                             _clone.appendChild(createHelper("left"));
//                             _clone.appendChild(createHelper("right"));

//                             $(_clone).draggable({
//                                 drag: function (event, ui) {
//                                     trackEvent.popcornTrackEvent.image.style.top = ui.position.top + "px";
//                                     trackEvent.popcornTrackEvent.image.style.left = ui.position.left + "px";
//                                 },
//                                 stop: function (event, ui) {
//                                     var top = ui.position.top / _container.clientHeight * 100,
//                                         left = ui.position.left / _container.clientWidth * 100;

//                                     trackEvent.update({
//                                         innerTop: top,
//                                         innerLeft: left
//                                     });
//                                     trackEvent.draggable.edit();
//                                 }
//                             });

//                             $(_clone).resizable({
//                                 handles: "n, ne, e, se, s, sw, w, nw",
//                                 resize: function (event, ui) {
//                                     trackEvent.popcornTrackEvent.image.style.height = _clone.clientHeight + "px";
//                                     trackEvent.popcornTrackEvent.image.style.width = _clone.clientWidth + "px";
//                                     _clone.style.height = _clone.clientHeight + "px";
//                                     _clone.style.width = _clone.clientWidth + "px";
//                                     trackEvent.popcornTrackEvent.image.style.top = ui.position.top + "px";
//                                     trackEvent.popcornTrackEvent.image.style.left = ui.position.left + "px";
//                                     _clone.style.top = ui.position.top + "px";
//                                     _clone.style.left = ui.position.left + "px";
//                                 },
//                                 stop: function (event, ui) {
//                                     trackEvent.update({
//                                         innerHeight: _clone.offsetHeight / _container.clientHeight * 100,
//                                         innerWidth: _clone.offsetWidth / _container.clientWidth * 100,
//                                         innerTop: ui.position.top / _container.clientHeight * 100,
//                                         innerLeft: ui.position.left / _container.clientWidth * 100
//                                     });
//                                     trackEvent.draggable.edit();
//                                 }
//                             });
//                         }
//                     });
//}(window.Butter));


h5.define('templates/EffectTrackEventEditorLayout', [], function () {
    return '<div class="h5-editor h5-form image-editor">\
  <h1>Effect</h1>\
  <div class="h5-editor-body scrollbar-container" style="top:30px;">\
    <div class="wrapper">\
            <div class="content">\
                  <div class="error-message-container">\
                    <div class="error-message"></div>\
                  </div>\
                <div class="editor-options">\
                </div>\
            </div>\
        </div>\
    </div>\
</div>';


//<style>
//  .image-toggler > select {
//        width: 50%;
//  }

//    .image-number > input {
//        width: 35%;
//    }

//    .flickr-image-time {
//        float: right;
//        padding-right: 10px;
//    }

//    .image-time-bold {
//        font-weight: bold;
//    }

//    .image-text {
//        font-size: 10px;
//    }

//    </style>';


});

/*
 * 可视化编辑器基类
 */
h5.define('editor/EffectEditor', ["jquery", "editor/TrackEventEditor", "templates/EffectTrackEventEditorLayout"],
  function ($,  TrackEventEditor, EFFECT_TRACKEVENT_EDITOR_LAYOUT) {

      var EffectEditor = TrackEventEditor.TrackEventEditor.extend({
          init: function (rootElement, app) {

              var _this = this;

              var _rootElement = rootElement,
                  _trackEvent,
                  _app,
                  _popcornOptions,
                  _pluginOptions,
                  _falseClick = function () {
                      return false;
                  },
                  _trueClick = function () {
                      return true;
                  };



              function setup(trackEvent) {

                  _trackEvent = trackEvent;
                  _popcornOptions = _trackEvent.popcornOptions;
                  _pluginOptions = {};
                  basicContainer = _rootElement.querySelector(".editor-options");

                  function callback(elementType, element, trackEvent, name) {
                      _pluginOptions[name] = { element: element, trackEvent: trackEvent, elementType: elementType };
                  }

                  function attachHandlers() {
                      var key,
                          option;

                      function colorCallback(te, options, message, prop) {
                          var newOpts = {};
                          if (message) {
                              _this.setErrorState(message);
                              return;
                          } else {
                              newOpts[prop] = options[prop];
                              te.update(newOpts);
                          }
                      }

                      var options = _pluginOptions;
                      for (key in options) {
                          if (options.hasOwnProperty(key)) {
                              option = options[key];

                              if (option.elementType === "select") {
                                  _this.attachSelectChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);

                              }
                              else if (option.elementType === "input") {
                                 if (key === "color") {
                                      _this.attachColorChangeHandler(option.element, option.trackEvent, key, colorCallback);
                                  }
                                  else {
                                      _this.attachInputChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);
                                  }
                              }
                              else if (option.elementType === "textarea") {
                                  _this.attachInputChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);
                              }
                          }
                      }

                      basicContainer.insertBefore(_this.createStartEndInputs(trackEvent, _this.updateTrackEventSafe), basicContainer.firstChild);
                  }




                  if (_popcornOptions.effectType.toLowerCase() == "color") {
                      _this.createPropertiesFromManifest({
                          trackEvent: trackEvent,
                          callback: callback,
                          basicContainer: basicContainer,
                          manifestKeys: ['color', 'merg'],
                          ignoreManifestKeys: ["start", "end"]
                      });
                  }
                  attachHandlers();
                  _this.updatePropertiesFromManifest(trackEvent);

                  //basicContainer.insertBefore(_this.createStartEndInputs(trackEvent, _this.updateTrackEventSafe), basicContainer.firstChild);

                  //var titleElement = _this.createManifestItem("title", trackEvent.manifest.options["title"], trackEvent.popcornOptions["title"], trackEvent);
                  //if (titleElement) {
                  //    basicContainer.insertBefore(titleElement, basicContainer.firstChild);
                  //}


                  //basicContainer.appendChild(_this.createSetAsDefaultsButton(trackEvent));
                //  _this.updatePropertiesFromManifest(trackEvent);
              }

              function onTrackEventUpdated(e) {
                  _trackEvent = e.target;

                  _this.updatePropertiesFromManifest(_trackEvent);
                  _this.setErrorState(false);
              }

              var events = {};
              events.open = function (parentElement, trackEvent) {
                  trackEvent.addEventListener("trackeventupdated", onTrackEventUpdated);
                  setup(trackEvent);


              }
              events.close = function () {
                  _trackEvent.removeEventListener("trackeventupdated", onTrackEventUpdated);
              }

              _this._super(rootElement, app, events);
          }
      });


      return {
          name: 'PopcornEffectPlugin',
          editor: EffectEditor,
          layout: EFFECT_TRACKEVENT_EDITOR_LAYOUT,
          persist: false,
          callback: function (trackEvent) {
              var _container,
                  target;

              _container = trackEvent.popcornTrackEvent.container;
              target = trackEvent.popcornTrackEvent.timelinePlayer.element;


              this.selectable(trackEvent, _container);
          }
      };

  });




h5.define('templates/SelectBoxEditorLayout', [], function () {
    return '<div class="h5-editor h5-form selectbox-editor">\
  <h1>' + lang[_curLang].inOrOutPoint + '</h1>\
  <div class="h5-editor-body scrollbar-container" style="top:30px;">\
    <div class="wrapper">\
            <div class="content">\
                  <div class="error-message-container">\
                    <div class="error-message"></div>\
                  </div>\
                <div class="editor-options">\
                </div>\
            </div>\
        </div>\
    </div>\
</div>';


//<style>
//  .image-toggler > select {
//        width: 50%;
//  }

//    .image-number > input {
//        width: 35%;
//    }

//    .flickr-image-time {
//        float: right;
//        padding-right: 10px;
//    }

//    .image-time-bold {
//        font-weight: bold;
//    }

//    .image-text {
//        font-size: 10px;
//    }

//    </style>';


});

/*
 * 媒体可视化编辑器
 */
h5.define('editor/SelectBoxEditor', ["jquery", "editor/TrackEventEditor", "util/util", "templates/SelectBoxEditorLayout"],
  function ($, TrackEventEditor, util, SELECTBOX_EDITOR_LAYOUT) {

      var SelectBoxEditor = TrackEventEditor.TrackEventEditor.extend({
          init: function (rootElement, app) {

              var events = {},
                  _this = this,
                  _rootElement = rootElement,
                  _selectBox = null;

              function setup(trackEvent) {
                  _selectBox = trackEvent;
                  var basicContainer = _rootElement.querySelector(".editor-options"),
                  pluginOptions = {};

                  function callback(elementType, element, trackEvent, name) {
                      pluginOptions[name] = { element: element, trackEvent: trackEvent, elementType: elementType };
                  }
                  _this.createPropertiesFromManifest({
                      basicContainer: basicContainer,
                      trackEvent: trackEvent,
                      callback:callback
                  });
                  _this.updatePropertiesFromManifest(trackEvent);


                  function inputChanged(trackEvent, options) {
                      app.setSelection(options.inpoint, options.outpoint);
                  }

                  for (key in pluginOptions) {
                      if (pluginOptions.hasOwnProperty(key)) {
                          var option = pluginOptions[key];

                          _this.attachSecondsChangeHandler(option.element, option.trackEvent, key, inputChanged);
                      }
                  }

              }



              function onTrackEventUpdated(e) {
                  _this.updatePropertiesFromManifest(_selectBox);
                  _this.setErrorState(false);
              }

              var events = {};
              events.open = function (parentElement, trackEvent) {
                  app.addEventListener("selectionchanged", onTrackEventUpdated);
                  setup(trackEvent);

              }
              events.close = function () {
                  app.removeEventListener("selectionchanged", onTrackEventUpdated);
              }

              _this._super(rootElement, app, events);
          }
      });


      return {
          name: 'H5SelectBox',
          editor: SelectBoxEditor,
          layout: SELECTBOX_EDITOR_LAYOUT,
          persist: false,
          callback: function (trackEvent) {

          }
      };

  });


h5.define('templates/ProjectInfoEditorLayout', [], function () {
    return '<div class="h5-editor h5-form selectbox-editor">\
  <h1>' + lang[_curLang].programInfo + '</h1>\
  <div class="h5-editor-body scrollbar-container" style="top:30px;">\
    <div class="wrapper">\
            <div class="content">\
                  <div class="error-message-container">\
                    <div class="error-message"></div>\
                  </div>\
                <div class="editor-options">\
                </div>\
            </div>\
        </div>\
    </div>\
</div>';


//<style>
//  .image-toggler > select {
//        width: 50%;
//  }

//    .image-number > input {
//        width: 35%;
//    }

//    .flickr-image-time {
//        float: right;
//        padding-right: 10px;
//    }

//    .image-time-bold {
//        font-weight: bold;
//    }

//    .image-text {
//        font-size: 10px;
//    }

//    </style>';


});

/*
 * 媒体可视化编辑器
 */
h5.define('editor/ProjectInfoEditor', ["jquery", "editor/TrackEventEditor", "util/util", "templates/ProjectInfoEditorLayout"],
  function ($, TrackEventEditor, util, PROJECTINFO_EDITOR_LAYOUT) {

      var ProjectInfoEditor = TrackEventEditor.TrackEventEditor.extend({
          init: function (rootElement, app) {

              var events = {},
                  _this = this,
                  _rootElement = rootElement,
                  _projectInfo = null;

              function setup(trackEvent) {
                  _projectInfo = trackEvent;
                  var basicContainer = _rootElement.querySelector(".editor-options"),
                  pluginOptions = {};

                  function callback(elementType, element, trackEvent, name) {
                      pluginOptions[name] = { element: element, trackEvent: trackEvent, elementType: elementType };
                  }
                  _this.createPropertiesFromManifest({
                      basicContainer: basicContainer,
                      trackEvent: trackEvent,
                      callback: callback
                  });
                  _this.updatePropertiesFromManifest(trackEvent);


                  //function inputChanged(trackEvent, options) {

                  //}


                  for (key in pluginOptions) {
                      if (pluginOptions.hasOwnProperty(key)) {
                          var option = pluginOptions[key];

                          if (option.elementType === "select") {
                              _this.attachSelectChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);
                          }
                          else if (option.elementType === "input") {

                              _this.attachInputChangeHandler(option.element, option.trackEvent, key, _this.updateTrackEventSafe);

                          }

                      }
                  }

              }



              function onTrackEventUpdated(e) {
                  _this.updatePropertiesFromManifest(_projectInfo);
                  _this.setErrorState(false);
              }

              var events = {};
              events.open = function (parentElement, trackEvent) {
                  setup(trackEvent);
                  trackEvent.addEventListener("mediapopcornsettingschanged", onTrackEventUpdated);
              }
              events.close = function () {
                  if (_projectInfo) {
                      _projectInfo.removeEventListener("mediapopcornsettingschanged", onTrackEventUpdated);
                  }
              }

              _this._super(rootElement, app, events);
          }
      });


      return {
          name: 'ProjectInfo',
          editor: ProjectInfoEditor,
          layout: PROJECTINFO_EDITOR_LAYOUT,
          persist: false,
          callback: function (trackEvent) {

          }
      };

  });
h5.define("editor/Editor", ["jquery",
    "editor/H5EditorHelper",
    "editor/EditorManager",
    "editor/TextEditor",
    "editor/MediaEditor",
    "editor/ImageEditor",
    "editor/EffectEditor",
    'editor/SelectBoxEditor',
    'editor/ProjectInfoEditor',
    "core/TrackEvent"], function ($, EditorHelper, EditorManager,
        TextEditor, MediaEditor, ImageEditor, EffectEditor, SelectBoxEditor,
        ProjectInfoEditor,
        TrackEvent) {

        var Editor = function (app, rootElement) {
            var _em = new EditorManager(app),
                _eh = new EditorHelper(app),
                _editors = [
                    TextEditor,
                    MediaEditor,
                    ImageEditor,
                    SelectBoxEditor,
                    ProjectInfoEditor,
                    EffectEditor
                ],
                _this = this,
                _currentEditor = null,
                _createdEditors = {},
                _rootElement = rootElement;

            for (var i = 0; i < _editors.length; i++) {
                var e = _editors[i];
                _em.register(e.name, e.layout, e.editor, e.persist, e.callback);
            }

            _em.initialize(function (pc) {
                for (var key in pc) {
                    _eh.addPlugin(key, pc[key]);
                }
            });

            app.propertyPanel.addEventListener("resize", function () {
                if (_currentEditor && _currentEditor.scrollbar ) {
                    _currentEditor.scrollbar.update();
                }
            });

            // 打开TrackEvent属性窗口
            _this.openTrackEventProperty = function (trackEvent) {
                var editorType = _em.isRegistered(trackEvent.type) ? trackEvent.type : "default";

                //if (!trackEvent || !(trackEvent instanceof TrackEvent)) {
                //    throw new Error("必须传入TrackEvent实例");
                //}

                if (_currentEditor && _currentEditor.getTrackEvent) {
                    if (trackEvent.id === _currentEditor.getTrackEvent().id) {
                        return _currentEditor;
                    }
                }

                return _this.openEditor(editorType, { openData: trackEvent });
            };


            _this.openEditor = function (editorName, options) {
                options = options || {};

                var persist = options.persist,
                    onTransitionEnd,
                    onEditorOpened;

                onEditorOpened = function () {
                    app.dispatchEvent("editoropened", editorName);
                };

                onTransitionEnd = function () {
                    //LangUtils.removeTransitionEndListener(_editorAreaDOMRoot, onTransitionEnd);
                    onEditorOpened();
                };

                persist = persist === true || persist === false ? persist : _em.isPersistent(editorName);

                //  _toggler.state = false;

                if (_currentEditor && _currentEditor.trackEvent === options.openData) {
                    _currentEditor.updatePropertiesFromManifest(options.openData);
                    app.propertyPanel.updateScroll();
                    app.propertyPanel.show();
                    return;
                }

                if (_currentEditor) {
                    _currentEditor.close();
                }

                if (persist && _createdEditors[editorName]) {
                    _currentEditor = _createdEditors[editorName];
                } else {
                    _currentEditor = _createdEditors[editorName] = _em.create(editorName, app);
                }

                _currentEditor.open(_rootElement, options.openData);
                _currentEditor.addEventListener("back", function () {
                });

                window.setTimeout(function () {
                    app.propertyPanel.show();
                    app.propertyPanel.updateScroll();
                    if (_currentEditor.scrollbar) {
                        _currentEditor.scrollbar.update();
                    }
                }, 0);

                return _currentEditor;
            };


            _this.closeEditor = function () {
                _currentEditor.close();
                _currentEditor = null;
            };


            _this.closeTrackEventProperty = function (trackEvent) {
                var isTrackEventEditor = _currentEditor.getTrackEvent;

                if (trackEvent && isTrackEventEditor &&
                    isTrackEventEditor().id === trackEvent.id) {

                    _this.closeEditor();
                }
            };


            Object.defineProperties(this, {
                manager: {
                    enumerable: true,
                    get: function () {
                        return _em;
                    }
                },
                helper: {
                    enumerable: true,
                    get: function () {
                        return _eh;
                    }
                }
            });
        };


        return Editor;

    });
/*
 * 下拉操作菜单组件
 */
h5.define('templates/H5OperationMenuLayout', [], function () {
    return '<div class="operationMenu">\
    <div class="wrapper">\
        <span class="title"></span>\
        <span class="icon"></span>\
    </div>\
    <ul class="v-menu context hidden">\
    </ul>\
</div>';
});
/*
 * 操作菜单
    var _OperationMenu = new H5OperationMenu({
        parent: '.listview',
        menuTitle: '测试',
        iconClass: 'fa fa-navicon',
        buttonClass:'按钮样式'
    })
 */
h5.define('plug/H5OperationMenu', ["jquery", "util/Object", "templates/H5OperationMenuLayout", "util/util"],
    function ($, Obj, H5_OPERATIONMENU_LAYOUT, util) {
        var H5OperationMenu = Obj.extend({
            init: function (options) {
                this._super();

                this.options = options;
                this.dataList = [];
                var _this = this,
                    _operationMenuElement = $(H5_OPERATIONMENU_LAYOUT)[0],
                    _buttonElement = _operationMenuElement.querySelector(".wrapper"),
                    _iconElement = _operationMenuElement.querySelector(".icon");

                if (options.title) $(_operationMenuElement).attr("title", options.title);
                _this._menusElement = _operationMenuElement.querySelector("ul.v-menu");

                if (options.buttonClass) $(_buttonElement).addClass(options.buttonClass);
                if (options.ulClass) $(_this._menusElement).addClass(options.ulClass);
                if (options.menuTitle) $(_operationMenuElement.querySelector(".title")).text(options.menuTitle);
                if (options.iconClass) $(_operationMenuElement.querySelector(".icon")).removeClass().addClass("icon").addClass(options.iconClass);

                $(options.parent).append(_operationMenuElement);

                this.bindingButtonEnter = function () {
                    if(_this._menusElement.querySelector("li")){
                        $(_buttonElement).addClass("no-border-bottom");
                        $(_this._menusElement).removeClass("hidden");
                        _iconElement.classList.add("active");
                    }
                }
                this.bindingButtonLeave = function () {
                    $(_buttonElement).removeClass("no-border-bottom");
                    $(_this._menusElement).addClass("hidden");
                    _iconElement.classList.remove("active");
                }
                _buttonElement.addEventListener("mouseenter", _this.bindingButtonEnter);
                _buttonElement.addEventListener("mouseleave", _this.bindingButtonLeave);
                _this._menusElement.addEventListener("mouseenter", _this.bindingButtonEnter);
                _this._menusElement.addEventListener("mouseleave", _this.bindingButtonLeave);
            }
        });

        return H5OperationMenu;
    }
)
;
/*
 * 菜单中的一项操作
    var _OpMenu1 = new H5OpMenuLi(_OperationMenu, {icon: 'mif-tools',text: '操作一'})
    _OpMenu1.addEventListener("click", function () {
        alert("操作一")
    })
 */
h5.define('plug/H5OpMenuLi', ["jquery", "util/Object", "util/util"],
    function ($, Obj, util) {
        var H5OpMenuLi = Obj.extend({
            init: function (operationMenu, options) {
                this._super();
                var _this = this;
                _this.saveData = {};

                var _menuliHtml = '<li><a href="javascript:void(0);" style="' + (options.style ? options.style : "") + '"><span class="icon ' + (options.icon ? options.icon : "") + '"></span> <span class="text">' + (options.text ? options.text : "") + '</span></a></li>';
                var _menuliElement = $(_menuliHtml)[0];
                $(operationMenu._menusElement).append(_menuliElement);

                _menuliElement.addEventListener("click", function () {
                    _this.dispatchEvent("click");
                    operationMenu.bindingButtonLeave();
                })
                this.updateSaveData = function(newSaveData){
                    if (newSaveData.name) {
                        util.forEach(operationMenu.dataList, function (item, idx) {
                            if (item.guid == newSaveData.guid) {
                                operationMenu.dataList.splice(idx, 1);
                            }
                        });
                        operationMenu.dataList.unshift(newSaveData);
                    }
                }
            }
        })
        return H5OpMenuLi;
    }
)
;
h5.define('templates/H5PropertyPanelLayout', [], function () {
    return '<div class="h5-editor-wrapper h5-form">\
        <div class="h5-editor-panel">\
        </div>\
    </div>';
});
h5.define("h5plugin/PropertyPanelPlugin", ["core/EditorPluginBase", "templates/H5PropertyPanelLayout"],
    function (EditorPluginBase, H5_PEOPERTY_PANEL_LAYOUT) {

        var PROPERTY_PAGE_ID = "H5_PROPERTY_PANEL";
    var PropertyPanelPlugin = EditorPluginBase.extend({
        init: function (app) {
            //必须将app传给基类
            this._super(app);
            var _this = this;

            var p = this.createPanel(PROPERTY_PAGE_ID, lang[_curLang].property, lang[_curLang].displayPropertyInfo, true);
            //var _element = $(H5_PEOPERTY_PANEL_LAYOUT)[0],
            //    _editorRoot = _element.querySelector(".h5-editor-panel");
            // p.appendChild(_element);

            this.show = function () {
                _this.activePanel(PROPERTY_PAGE_ID);
                _this.dispatchEvent("resize");
            };

            app.playerPanel.pluginPanel.addEventListener("resize", function () {
                _this.dispatchEvent("resize");
            });


            Object.defineProperties(this, {
                root: {
                    enumerable: true,
                    get: function () {
                        return p;
                    }
                }
            });
        },
        name: function () {
            return "PropertyPanelPlugin";
        }
    });

    return PropertyPanelPlugin;

});


h5.define('templates/H5WindowLayout', [], function () {
    return '<div  class="h5 window">\
                <div class="window-caption">\
                    <span class="window-caption-icon">\
                        <span></span>\
                    </span>\
                    <span class="window-caption-title">\
                        <span></span>\
                    </span>\
                    <span class="btn-close"></span>\
\
                </div>\
                <div class="window-content" ></div>\
            </div>';


});
h5.define('templates/WindowModalDiv', [], function () {
    return '<div class="windowModalDiv" style="width:100%;height:100%;background-color:#000;position:absolute;top:0;left:0;z-index:10049;opacity:0;"/>';


});
h5.define("util/H5Window", ["jquery", "util/Object", "util/util", "templates/H5WindowLayout", "templates/WindowModalDiv"], function ($, Obj, util, H5_WINDOW_LAYOUT, WINDOW_MODAL_DIV) {
    var H5Window = Obj.extend({
        init: function (options) {
            var _this = this,
                _options = options || {},
                _element = $(H5_WINDOW_LAYOUT)[0],
                _captionElement = _element.querySelector(".window-caption"),
                _iconElement = _element.querySelector(".window-caption-icon"),
                _titleElement = _element.querySelector(".window-caption-title"),
                _closeElement = _element.querySelector(".btn-close"),
                _contentElement = _element.querySelector(".window-content");
            var _modalDiv = $(WINDOW_MODAL_DIV)[0];

            _this._super();

            if (_options.content) {
                _contentElement.appendChild(_options.content);
            }

            if (_options.closeCss) {
                _closeElement.classList.add(_options.closeCss);
            }

            if (!_options.icon) {
                _iconElement.classList.add("hidden");
            }
            if (_options.iconCss) {
                _iconElement.querySelector("span").classList.add(_options.iconCss);
            }
            if (_options.title) {
                _titleElement.querySelector("span").innerText = _options.title;
            }
            if (_options.captionCss) {
                _captionElement.classList.add(_options.captionCss);
            }

            _this.updateContent = function (newContent) {
                _contentElement = "";
                _contentElement = _element.querySelector(".window-content");
                _contentElement.appendChild(newContent);
            }

            _this.show = function () {



                document.body.appendChild(_element);
                document.body.appendChild(_modalDiv);

                if (this.pointData) {
                    var _markers = $(_element.querySelector(".markPointMenuUl")).find("li");
                    for (var i = 0; i < _markers.length; i++) {
                        $(_markers[i]).removeClass('active');
                    }
                    var index = this.pointData.name;
                    //if (this.pointData.name == 't')
                    //{
                    //    index = 10;
                    //}
                    $(_markers[index]).addClass('active');
                }
                var w = $(_element).width(),
                    h = $(_element).height(),
                    bw = $(window).width(),
                    bh = $(window).height();

                $(_element).css({
                    left: (bw - w) / 2 + 'px',
                    top: (bh - h) /2 + 'px'
                });
                _translate = [0, 0];
                util.setTransformProperty(_element, "translate(" + _translate[0] + "px, " + _translate[1] + "px)");
            };

            _this.hide = function () {
                try{
                    document.querySelector(".saveplugin").querySelector(".path").value = "";
                }
                catch (e) { }
                document.body.removeChild(_element);
                document.body.removeChild(_modalDiv);
            }

            _closeElement.addEventListener("click", function () {
                _this.hide();
            });


            _captionElement.addEventListener("mousedown", onCaptionMouseDown);

            var _mousedown = false,
                _downposition = [0, 0],
                _translate = [0, 0],
                _lastDiff = [0, 0],
                _oldSelectStartProc = null;


            function onSelectStart(e){
                return false;
            }

            function onCaptionMouseDown(e) {
                _mousedown = true;
                _downposition = [e.pageX, e.pageY];
                _lastDiff = [0, 0];
                _captionElement.removeEventListener("mousedown", onCaptionMouseDown);
                window.addEventListener("mousemove", onCaptionMouseMove);
                window.addEventListener("mouseup", onCaptionMouseup);
                _oldSelectStartProc = document.onselectstart;
                document.onselectstart = onSelectStart;
            }

            function onCaptionMouseMove(e) {
                _lastDiff = [e.pageX - _downposition[0], e.pageY - _downposition[1]];
                util.setTransformProperty(_element, "translate(" + (_translate[0] + _lastDiff[0]) + "px, " + (_translate[1] + _lastDiff[1]) + "px)");
            }

            function onCaptionMouseup(e) {
                _mousedown = false;
                _translate[0] = _translate[0] + _lastDiff[0];
                _translate[1] = _translate[1] + _lastDiff[1];
                _captionElement.addEventListener("mousedown", onCaptionMouseDown);
                window.removeEventListener("mousemove", onCaptionMouseMove);
                window.removeEventListener("mouseup", onCaptionMouseup);
                document.onselectstart = _oldSelectStartProc;
            }
        }
    });


    return H5Window;
});
h5.define('templates/H5MarkpointWindowLayout', [], function () {
    return '<div class="mp-memo-content">\
                <div class="mp-chosemarkpoint"></div>\
                <span>' + lang[_curLang].description + '</span>\
                <div class="mp-input-wrapper">\
                    <div class="mp-input-r">\
                        <textarea class="mp-input"></textarea>\
                    </div>\
                    <div class="dropdown">\
                        <span class="dropdown-icon"></span>\
                        <ul class="mp-short"></ul>\
                    </div>\
                    <div class="dropdown-content hidden">\
                        <ul class="v-menu subdown block-shadow-impact">\
                        </ul>\
                    </div>\
                </div>\
                <div class="mp-foot">\
                    <button class="mp-btn cancel">' + lang[_curLang].cancel + '</button>\
                    <button class="mp-btn ok">' + lang[_curLang].confirm + '</button>\
                </div>\
            </div>';


});
h5.define('templates/H5MarkpointWindowLayout2', [], function () {
    return '<div class="operationMenu" style="left: 10px;top: 10px;">\
        <ul class="v-menu context markPointMenuUl" style="width:auto;">\
           <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-0"></span> \
                <span class="text" draggable="true">0</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-1"></span>\
                <span class="text" draggable="true">1</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-2"></span> \
                <span class="text" draggable="true">2</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-3"></span> \
                <span class="text" draggable="true">3</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-4"></span> \
                <span class="text" draggable="true">4</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-5"></span> \
                <span class="text" draggable="true">5</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-6"></span> \
            <span class="text" draggable="true">6</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-7"></span>\
                <span class="text" draggable="true">7</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-8"></span>\
                <span class="text" draggable="true">8</span>\
            </a></li>\
            <li><a href="javascript:void(0);">\
                <span class="icon markpoint-li mp-9"></span> \
                <span class="text" draggable="true">9</span>\
            </a></li>\
        </ul>\
            </div>';
});
h5.define('plug/ShortcutKey', ["jquery", "util/Object", "util/util", "util/H5Window", "templates/H5MarkpointWindowLayout2", "plug/Dialog" ],
    function ($, Obj, util, H5Window, MARKPOINT_CONTENT_LAYOUT2, Dialog) {
        var ShortcutKey = Obj.extend({
            init: function (app,options) {
                this._super();

                this.options = options;
                var _this = this,
                    keyDataArr = [];

                document.onkeydown = function (event) {
                    if (event.target.tagName != "INPUT" && event.target.tagName != "TEXTAREA") {
                        //获取键值
                        var keyCode = event.keyCode;
                        var keyValue = String.fromCharCode(event.keyCode);

                        util.forEach(keyDataArr, function (currentData) {
                            if (currentData.MainKey) {
                                if (keyCode == currentData.MainKey) currentData.currentMainKey = keyCode;
                                if (currentData.currentMainKey != null) {
                                    if (keyValue == currentData.keyValue) {
                                        currentData.currentMainKey = null;
                                        if (currentData.func != null) currentData.func();
                                    }
                                }
                            } else {
                                if (!isNaN(currentData.keyValue)) {
                                    if (currentData.keyValue == keyCode) {
                                        if (currentData.func != null) currentData.func();
                                    }
                                } else {
                                    if (currentData.keyValue == keyValue) {
                                        if (currentData.func != null) currentData.func();
                                    }
                                }
                            }
                        })

                    }
                }
                document.onkeyup = function (e) {
                    util.forEach(keyDataArr, function (currentData) {
                        currentData.currentMainKey = null;
                    })
                }

                _this.editOkClick = function () {
                    app.media.pause();
                    var _inputWindow = _this.options.inputWindow,
                     _contentElement = _this.options.contentElement,
                     _menuMap = _this.options.menuMap,
                     _OperationMenu = _this.options.OperationMenu,
                     _chosemarkpointElement = _contentElement.querySelector(".mp-chosemarkpoint"),
                     _textArea = _contentElement.querySelector(".mp-input");

                    if (app.media.isEmpty()) {
                        _inputWindow.pointData = undefined;
                        _inputWindow.hide();
                        var dialog = new Dialog({
                            title: lang[_curLang].tip,
                            content: lang[_curLang].timeLineEmpty,
                            style: 'error',
                            button: lang[_curLang].ok
                        });
                        dialog.open();
                    }
                    else{
                        var text = $(_textArea).val();
                        var _choseElement = $(_chosemarkpointElement).find("ul li.active");
                        /*if (!text) {
                            var dialog = new Dialog({
                                title: lang[_curLang].tip,
                                content: lang[_curLang].markPointEmpty,
                                style: 'error',
                                button: lang[_curLang].ok
                            });
                            dialog.open();
                        } else*/ if (_choseElement.length < 1) {
                        var dialog = new Dialog({
                            title: lang[_curLang].tip,
                            content: lang[_curLang].selectMarkPoint,
                            style: 'error',
                            button: lang[_curLang].ok
                        });
                        dialog.open();
                    } else {
                        //保存标记点信息并创建标记点
                        var choseIndex = $(_chosemarkpointElement).find("ul li").index($(_chosemarkpointElement).find("ul li.active"));
                        var guid;
                        if (_inputWindow.pointData) {
                            guid = _inputWindow.pointData.guid;
                        }
                        _inputWindow.pointData = { menu: _menuMap[choseIndex], name: $(_choseElement).find("span:last-child").text().toLowerCase(), color: $(_choseElement).find("span:first-child").css("color"), };
                        var data = _inputWindow.pointData;

                        var newSaveData = { menu: data.menu, name: data.name, color: data.color, text: text, time: app.media.currentTime, guid: guid || new Date().getTime() };
                        data.menu.updateSaveData(newSaveData);
                        app.markPointPlugin.updateMarkPoint(_OperationMenu.dataList);
                        _inputWindow.pointData = undefined;
                        _inputWindow.hide();
                    }
                    }
                }

                _this.Register = function (tag, value, func) {
                    var MainKey;
                    switch (tag) {
                        case "Ctrl":
                            MainKey = 17; //Ctrl
                            break;
                        case "Shift":
                            MainKey = 16; //Shift
                            break;
                        case "Alt":
                            MainKey = 18; //Alt
                            break;
                        default:
                            MainKey = "";
                    }
                    //控制键键码值处理
                    switch (value) {
                        case "Home": value = 36;break;
                        case "Left": value = 37;break;
                        case "Space": value = 32;break;
                        case "Right": value = 39;break;
                        case "End": value = 35;break;
                        case "[": case "{": value = 219; break;
                        case "]": case "}": value = 221; break;
                        case "P": value = 80; break;
                        case '\\': value = 220; break;
                        case "Delete": value = 46; break;

                        case "BackSpace": value = 8; break;
                        case "Tab": value = 9; break;
                        case "Enter": value = 13; break;
                        case "Esc": value = 27; break;
                        case "PageUp": value = 33; break;
                        case "PageDown": value = 34; break;
                        case "Up": value = 38; break;
                        case "Dw": value = 40; break;
                        case "Insert": value = 45; break;
                        case ";": case ":": value = 186; break;
                        case "=": case "+": value = 187; break;
                        case ",": case "<": value = 188; break;
                        case "-": case "_": value = 189; break;
                        case ".": case ">": value = 190; break;
                        case "/": case "?": value = 191; break;
                        case "`": case "~": value = 192; break;
                        case "|": value = 220; break;
                        case "'": case '"': value = 222; break;
                        case "": value = String.fromCharCode(17); break;

                        default: value = value; break;
                    }
                    var currentData = {
                        currentMainKey:null,
                        MainKey: MainKey,
                        keyValue: value,
                        func: func
                    };
                    keyDataArr.push(currentData);
                }
                function onkeySecondDown(e) {
                    //e.preventDefault();
                    e.stopPropagation();
                    if (event.target.tagName != "INPUT" && event.target.tagName != "TEXTAREA") {
                        //获取键值
                        var keyValue = String.fromCharCode(event.keyCode);
                        switch (keyValue) {
                            case "E": $(".toolbar-btn.add").click(); break;
                            case "Z": $(".toolbar-btn.undo").click(); break;
                            case "Y": $(".toolbar-btn.redo").click(); break;
                        }
                    }
                }
                function onkeySecondUp(e) {
                    if (e.keyCode == 17) {
                        document.removeEventListener('keydown', onkeySecondDown);
                    }
                }
                //修改节目信息(E)
               /* _this.Register("", "E", function () {
                    $(".toolbar-btn.info").click();
                });*/
                _this.Register("Ctrl", "", function () {
                    document.addEventListener('keydown', onkeySecondDown);
                    document.addEventListener('keyup', onkeySecondUp);
                });

                _this.Register("", "\\", function () {
                    $(".toolbar-btn.clear").click();
                });

                /*//新建时间线(N)
                _this.Register("", "N", function () {
                    $(".toolbar-btn.add").click();
                });*/
                //保存(S)
                _this.Register("", "S", function () {
                    $(".toolbar-btn.save").click();
                });
                //撤销(Z)
                /*_this.Register("", "Z", function () {
                    $(".toolbar-btn.undo").click();
                });
                //重做(R)
                _this.Register("", "R", function () {
                    $(".toolbar-btn.redo").click();
                });  */
                //添加字幕(T)
                _this.Register("", "T", function () {
                    $(".toolbar-btn.addtext").click();
                });
                //跳到开头(Home)
                _this.Register("", "Home", function () {
                    if (_svFlag) {
                        window.frames[0].postMessage({ ep: "JOVE", operation: "Home" }, '*');
                    }
                    else {
                        $(".toolbar-btn.startframe").click();
                    }
                });
                //上一帧(方向键左)
                _this.Register("", "Left", function () {
                    if (_svFlag) {
                        window.frames[0].postMessage({ ep: "JOVE", operation: "LastFrame" }, '*');
                    }
                    else {
                        $(".toolbar-btn.prevframe").click();
                    }
                });
                //播放(空格Space)
                _this.Register("", "Space", function () {
                    if (_svFlag) {
                        window.frames[0].postMessage({ ep: "JOVE", operation: "Space" }, '*');
                    }
                    else {
                        $(".toolbar-btn.play").click();
                    }
                });
                //下一帧(方向键右)
                _this.Register("", "Right", function () {
                    if (_svFlag) {
                        window.frames[0].postMessage({ ep: "JOVE", operation: "NextFrame" }, '*');
                    }
                    else {
                        $(".toolbar-btn.nextframe").click();
                    }
                });
                //跳到结尾(End)
                _this.Register("", "End", function () {
                    if (_svFlag) {
                        window.frames[0].postMessage({ ep: "JOVE", operation: "End" }, '*');
                    }
                    else {
                        $(".toolbar-btn.endframe").click();
                    }
                });
                //入点([)
                _this.Register("", "[", function () {
                    $(".toolbar-btn.inpoint").click();
                });
                //出点(])
                _this.Register("", "]", function () {
                    $(".toolbar-btn.outpoint").click();
                });
                //剪开(/)
                _this.Register("", "P", function () {
                    $(".toolbar-btn.clipper").click();
                });
                //删除(Delete)
                _this.Register("", "Delete", function () {
                    $(".toolbar-btn.delete").click();
                });
                //标记点(M)
                _this.Register("", "M", function () {
                    $("#mv").trigger("click");
                    if (app.media.duration <= 0)
                        return;
                    app.media.pause();
                    var _inputWindow = _this.options.inputWindow,
                        _contentElement = _this.options.contentElement,
                        _chosemarkpointElement = _contentElement.querySelector(".mp-chosemarkpoint"),
                        _spanElement = _contentElement.querySelector("span"),
                        _inputElement = _contentElement.querySelector(".mp-input-wrapper"),
                        _btnOk = _contentElement.querySelector(".ok"),
                        _textArea = _contentElement.querySelector(".mp-input"),
                        _addContentElement = $(MARKPOINT_CONTENT_LAYOUT2)[0];
                    $(_chosemarkpointElement).empty();
                    _chosemarkpointElement.appendChild(_addContentElement);
                    $(_spanElement).css("top", "55px");
                    $(_inputElement).css("top", "50px");
                    $(_contentElement).css("height", "220px").css("width", "550px");

                    var _lisElement = $(_addContentElement).find("ul li");
                    _lisElement.each(function () {
                        $(this).click(function () {
                            _lisElement.each(function () {
                                $(this).removeClass("active");
                            })
                            $(this).addClass("active");
                        })
                    });
                    $(_textArea).val("");
                    _inputWindow.show();

                    _btnOk.removeEventListener("click", _this.options.markpointPlugin.editOkClick);
                    _btnOk.removeEventListener("click", _this.editOkClick);
                    _btnOk.addEventListener("click", _this.editOkClick);
                });
            }
        });

        return ShortcutKey;
    }
)
;
h5.define("h5plugin/MarkPointPlugin", ["core/EditorPluginBase", "util/util",
    "plug/H5OperationMenu",
     "plug/H5OpMenuLi",
     "util/H5Window",
     "plug/Dialog",
     "templates/H5MarkpointWindowLayout",
     "templates/H5MarkpointWindowLayout2",
     "plug/ShortcutKey"
],
    function (EditorPluginBase, util, H5OperationMenu, H5OpMenuLi, H5Window, Dialog, MARKPOINT_CONTENT_LAYOUT, MARKPOINT_CONTENT_LAYOUT2, ShortcutKey) {

        var PAGE_ID = "H5_MARKPOINT_PANEL";
        var MarkPointPlugin = EditorPluginBase.extend({
            init: function (app) {
                //必须将app传给基类
                this._super(app);
                var _this = this,
                    _contentElement = $(MARKPOINT_CONTENT_LAYOUT)[0],
                    _dropdownElement = _contentElement.querySelector(".dropdown"),
                    _dropdownContentElement = _contentElement.querySelector(".dropdown-content"),
                    _btnOk = _contentElement.querySelector(".ok"),
                    _btnCancel = _contentElement.querySelector(".cancel"),
                    _textArea = _contentElement.querySelector(".mp-input"),
                    _chosemarkpointElement = _contentElement.querySelector(".mp-chosemarkpoint"),
                    _spanElement = _contentElement.querySelector("span"),
                    _inputElement = _contentElement.querySelector(".mp-input-wrapper"),
                    _inputWindow = new H5Window({
                        content: _contentElement,
                        title: lang[_curLang].markPoint
                    }),
                _OperationMenu,
                    _dataList = ["Commonly used sentence 1", "Commonly used sentence 2", "Commonly used sentence 3", "Commonly used sentence 4", "Commonly used sentence 5", "Commonly used sentence 6"],
                    _menuMap = {};
                var _addContentElement = $(MARKPOINT_CONTENT_LAYOUT2)[0];
                $(_chosemarkpointElement).empty();
                _chosemarkpointElement.appendChild(_addContentElement);
                $(_spanElement).css("top", "15px");
                $(_inputElement).css("top", "15px");
                $(_contentElement).css("height", "150px").css("width", "550px");
                function createMarkPoint() {
                    //在工具栏内创建标记点下拉菜单
                    var buttonPlug1 = app.pluginService.createToolbarButton("markButtonDiv");

                    buttonPlug1.addEventListener("click", function () {
                        _this.activePanel(PAGE_ID);
                            if (app.media.duration <= 0)
                                return;
                            app.media.pause();
                             _addContentElement = $(MARKPOINT_CONTENT_LAYOUT2)[0];
                            $(_chosemarkpointElement).empty();
                            _chosemarkpointElement.appendChild(_addContentElement);
                            $(_spanElement).css("top", "55px");
                            $(_inputElement).css("top", "50px");
                            $(_contentElement).css("height", "220px").css("width", "550px");

                            var _lisElement = $(_addContentElement).find("ul li");
                            _lisElement.each(function () {
                                $(this).click(function () {
                                    _lisElement.each(function () {
                                        $(this).removeClass("active");
                                    })
                                    $(this).addClass("active");
                                })
                            });
                            $(_textArea).val("");
                            _inputWindow.show();

                            _btnOk.removeEventListener("click", _this.shortcutKey.editOkClick);
                            _btnOk.removeEventListener("click", _this.editOkClick);
                            _btnOk.addEventListener("click", _this.editOkClick);
                    });

                    //标记点菜单
                   _OperationMenu = new H5OperationMenu({
                        parent: '#markButtonDiv',
                        iconClass: 'toolbar-btn  markpoint',
                        ulClass: 'markPointMenuUl',
                        buttonClass: '',
                        title: lang[_curLang].markPointM
                    })
                    //标记点菜单操作项
                    var _OpMenu1 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-1', text: '1' });
                    _OpMenu1.addEventListener("click", function () { bindingMarkPointClick(_OpMenu1, '1', 'rgb(244,112,104)') });
                    var _OpMenu2 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-2', text: '2' });
                    _OpMenu2.addEventListener("click", function () { bindingMarkPointClick(_OpMenu2, '2', 'rgb(244,112,104)') });
                    var _OpMenu3 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-3', text: '3' });
                    _OpMenu3.addEventListener("click", function () { bindingMarkPointClick(_OpMenu3, '3', 'rgb(243,178,102)') });
                    var _OpMenu4 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-4', text: '4' });
                    _OpMenu4.addEventListener("click", function () { bindingMarkPointClick(_OpMenu4, '4', 'rgb(239,239,97)') });
                    var _OpMenu5 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-5', text: '5' });
                    _OpMenu5.addEventListener("click", function () { bindingMarkPointClick(_OpMenu5, '5', 'rgb(129,233,154)') });
                    var _OpMenu6 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-6', text: '6' });
                    _OpMenu6.addEventListener("click", function () { bindingMarkPointClick(_OpMenu6, '7', 'rgb(129,231,235)') });
                    var _OpMenu7 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-7', text: '7' });
                    _OpMenu7.addEventListener("click", function () { bindingMarkPointClick(_OpMenu7, '7', 'rgb(179,111,242)') });
                    var _OpMenu8 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-8', text: '8' });
                    _OpMenu8.addEventListener("click", function () { bindingMarkPointClick(_OpMenu8, '8', 'rgb(243,112,175)') });
                    var _OpMenu9 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-9', text: '9' });
                    _OpMenu9.addEventListener("click", function () { bindingMarkPointClick(_OpMenu9, '9', 'rgb(142,87,0)') });
                    var _OpMenu0 = new H5OpMenuLi(_OperationMenu, { icon: 'markpoint-li mp-0', text: '0' });
                    _OpMenu0.addEventListener("click", function () { bindingMarkPointClick(_OpMenu0, '0', 'rgb(208,208,208)') });
                    _menuMap = {
                        "0": _OpMenu0,
                        "1": _OpMenu1,
                        "2": _OpMenu2,
                        "3": _OpMenu3,
                        "4": _OpMenu4,
                        "5": _OpMenu5,
                        "6": _OpMenu6,
                        "7": _OpMenu7,
                        "8": _OpMenu8,
                        "9": _OpMenu9
                    };
                    _btnCancel.addEventListener("click", function () {
                        _inputWindow.pointData = undefined;
                        _inputWindow.hide();
                    });
                   /* _dropdownElement.addEventListener("click", function () {
                        if ($(_dropdownContentElement).hasClass("hidden")) {
                            resetDropdownContent();
                            $(_dropdownContentElement).removeClass("hidden");
                        } else {
                            $(_dropdownContentElement).addClass("hidden");
                        }
                    });*/
                    function resetDropdownContent() {
                        var ulElement = $(_dropdownContentElement.querySelector(".v-menu"));
                        ulElement.empty();
                        util.forEach(_dataList, function (item, idx) {
                            var liElement = $('<li><a href="javascript:void(0);">' + item + '</a></li>')[0];
                            ulElement.append(liElement);
                            liElement.addEventListener("click", function () {
                                $(_textArea).val(this.textContent);
                                $(_dropdownContentElement).addClass("hidden");
                            })
                        })
                    }
                    //显示输入标记点备注层
                    function bindingMarkPointClick(opMenu, name, color) {
                        if (app.media.duration <= 0 )
                            return;

                        _btnOk.removeEventListener("click", _this.shortcutKey.editOkClick);
                        _btnOk.removeEventListener("click", _this.activeOkClick);
                        _btnOk.addEventListener("click", _this.activeOkClick);

                        $(_chosemarkpointElement).empty();
                        $(_spanElement).css("top", "55px");
                        $(_inputElement).css("top", "50px");
                        $(_contentElement).css("height", "220px").css("width", "550px");

                        $(_dropdownContentElement).addClass("hidden");
                        $(_textArea).val("");
                        _inputWindow.pointData = { menu: opMenu, name: name, color: color };
                        _inputWindow.show();
                        _this.activePanel(PAGE_ID);
                       // showInputDialog(opMenu, name, color);
                    }
                    //显示输入标记点备注层
                    function showInputDialog(opMenu, name, color) {


                        //_inputdialogElement = $(INPUT_DIALOG_LAYOUT)[0];
                        //$("body").append(_inputdialogElement);
                        //$(_inputdialogElement).css("z-index", "10003").css("left", (document.body.offsetWidth - _inputdialogElement.offsetWidth) / 2 + "px").css("top", (document.body.offsetHeight - _inputdialogElement.offsetHeight) / 2 + "px");
                        //_inputdialogElement.querySelector('.dialog-close-button').addEventListener("click", function () {
                        //    _inputdialogElement.remove();
                        //});
                        //_inputdialogElement.querySelector('.cancel').addEventListener("click", function () {
                        //    _inputdialogElement.remove();
                        //});
                        ////提交标记点备注后更新标记点
                        //_inputdialogElement.querySelector('.ok').addEventListener("click", function () {
                        //    var text = $(_inputdialogElement.querySelector('textarea')).val();
                        //    if (text) {
                        //        //保存标记点信息并创建标记点
                        //        _inputdialogElement.remove();
                        //        var newSaveData = { name: name, color: color, text: text, time: app.media.currentTime };
                        //        opMenu.updateSaveData(newSaveData);
                        //        app.markPointPlugin.updateMarkPoint(_OperationMenu.dataList);
                        //    } else {
                        //        var dialog = new Dialog({
                        //            title: '提示',
                        //            content: '标记点备注不能为空！',
                        //            style: 'error', //warn、question、error、succeed
                        //            button: 'Ok'//按钮(是/否<Confirm>;确定<Ok>;确定/取消<OkCancel>)
                        //        });
                        //        dialog.open();
                        //    }

                        //});
                    }
                }

                createMarkPoint();

                _this.activeOkClick = function () {
                    if (app.media.isEmpty()) {
                        _inputWindow.hide();
                        var dialog = new Dialog({
                            title: lang[_curLang].tip,
                            content: lang[_curLang].timeLineEmpty,
                            style: 'error',
                            button: lang[_curLang].ok
                        });
                        dialog.open();
                    }
                    else {
                        var text = $(_textArea).val();
                        //保存标记点信息并创建标记点
                        _inputWindow.hide();
                        var data = _inputWindow.pointData;
                        var newSaveData = { menu: data.menu, name: data.name, color: data.color, text: text, time: app.media.currentTime, guid: _inputWindow.pointData.guid || new Date().getTime() };
                        data.menu.updateSaveData(newSaveData);
                        app.markPointPlugin.updateMarkPoint(_OperationMenu.dataList);
                    }
                }
                _this.editOkClick = function () {
                    if (app.media.isEmpty()) {
                        _inputWindow.pointData = undefined;
                        _inputWindow.hide();
                        var dialog = new Dialog({
                            title: lang[_curLang].tip,
                            content: lang[_curLang].timeLineEmpty,
                            style: 'error',
                            button: lang[_curLang].ok
                        });
                        dialog.open();
                    }
                    else {
                        var text = $(_textArea).val();
                        var _choseElement = $(_chosemarkpointElement).find("ul li.active");
                        /*if (!text) {
                            var dialog = new Dialog({
                                title: lang[_curLang].tip,
                                content: lang[_curLang].markPointEmpty,
                                style: 'error',
                                button: lang[_curLang].ok
                            });
                            dialog.open();
                        } else */if (_choseElement.length < 1) {
                        var dialog = new Dialog({
                            title: lang[_curLang].tip,
                            content: lang[_curLang].selectMarkPoint,
                            style: 'error',
                            button: lang[_curLang].ok
                        });
                        dialog.open();
                    } else {
                        //保存标记点信息并创建标记点
                        var choseIndex = $(_chosemarkpointElement).find("ul li").index($(_chosemarkpointElement).find("ul li.active"));
                        var guid,intime,outtime,color;
                        if (_inputWindow.pointData) {
                            guid = _inputWindow.pointData.guid;
                            choseIndex = _inputWindow.pointData.name;
                            intime = _inputWindow.pointData.intime;
                            outtime = _inputWindow.pointData.outtime;
                            color = _inputWindow.pointData.color;

                        }
                        _inputWindow.pointData = { menu: _menuMap[choseIndex], name: $(_choseElement).find("span:last-child").text().toLowerCase(), color: $(_choseElement).find("span:first-child").css("color"), };
                        //_inputWindow.pointData = { menu: _menuMap[choseIndex], name: choseIndex, color: color || 'rgb(129,231,235)' };
                        var data = _inputWindow.pointData;

                        var newSaveData = { menu: data.menu, name: data.name, color: data.color, text: text, time: app.media.currentTime, guid: guid || new Date().getTime(), intime: intime,outtime:outtime };
                        data.menu.updateSaveData(newSaveData);
                        app.markPointPlugin.updateMarkPoint(_OperationMenu.dataList);
                        _inputWindow.pointData = undefined;
                        _inputWindow.hide();
                    }
                    }
                }
                this.resetDropdownList = function(newDataList){
                    if($.isArray(newDataList)){
                        _dataList = newDataList;
                        _this.resetDropdownContent();
                    }
                }

                //标记点Panel
                var p = this.createPanel(PAGE_ID, lang[_curLang].markPoint, "", false);
                var list = $("<div/>").addClass("listview-outlook").attr("data-role", "listview")[0];
                //var n = document.createElement("div");
                //n.style.height = 2000 + 'px';
                p.appendChild(list);
                Object.defineProperties(this, {
                    root: {
                        enumerable: true,
                        get: function () {
                            return p;
                        }
                    }
                });
                var markPointElement;

                this.updateMarkPointLeft = function () {
                    if (markPointElement) {
                        util.forEach($(markPointElement).children(".markPoint"), function (item, idx) {
                            $(item).css("left", (app.timeToPixel($(item).attr("marktime") * 1000) - 5 - app.trackContainer.element.scrollLeft) + "px");

                            if (parseInt($(item).css("left")) < -5 || parseInt($(item).css("left")) > parseInt($(markPointElement).css("width")) - 5) {
                                $(item).css("display", "none");
                            } else {
                                $(item).css("display", "block");

                            }
                        })
                    }
                }
                this.updateMarkPoint = function (markPointList, flag) {
                    //时间线标记点面板
                    if (document.querySelector(".markPointDiv")) {
                        markPointElement = document.querySelector(".markPointDiv");
                    } else {
                        markPointElement = $("<div/>").addClass("markPointDiv")[0];
                        document.querySelector(".time-bar").appendChild(markPointElement);
                    }
                    $(list).empty();
                    $(markPointElement).empty();
                    util.forEach(markPointList, function (item, idx) {
                        //更新标记点Panel

                        var c = "mp-bk-" + item.name;
                        var _markPointItemElement = $('<div class="list">\
                                                <span class="list-color ' + c + '"></span>\
                                                <span class="list-time">' + util.toSmpteString(item.time*1000) + '</span>\
                                                <div class="list-text"><span class="list-marker-text">' + item.text + '</span><span class="glyphicon glyphicon-remove" style="float: right;line-height: 27px;margin-right: 5px;"></span></div>\
                                            </div>')[0];
                        $(list).append(_markPointItemElement);
                        _markPointItemElement.addEventListener("dblclick", function () {
                            app.media.pause();
                            app.media.currentTime = item.time;
                            app.clearInOutpoint();
                            //if (item.name == "4") {
                            //    app.setInpoint(item.intime);
                            //    app.setOutpoint(item.outtime);
                            //}
                        });

                        var textElement = _markPointItemElement.querySelector(".list-text");
                        textElement.addEventListener("dblclick", function (e) {
                            app.media.currentTime = item.time;
                            app.media.pause();
                            e.preventDefault();
                            e.stopPropagation();
                            $(_dropdownContentElement).addClass("hidden");
                            $(_textArea).val(item.text);
                            _btnOk.removeEventListener("click", _this.shortcutKey.editOkClick);
                            _btnOk.removeEventListener("click", _this.editOkClick);
                            _btnOk.addEventListener("click", _this.editOkClick);
                            _inputWindow.pointData = item;
                            _inputWindow.show();
                        });

                        var closeBtn = _markPointItemElement.querySelector(".glyphicon-remove");
                        closeBtn.addEventListener("click", function () {
                            _this.deleteMarker(item);
                        });
                        //更新时间线标记点
                        //var markPointPixel = app.timeToPixel(item.time * 1000) - 5 + app.trackContainer.element.scrollLeft;
                        var markTimePixel = app.timeToPixel(item.time * 1000) - 5;
                        var markPointPixel = markTimePixel - app.trackContainer.element.scrollLeft;

                        c = "mp-" + item.name;
                        var _timeBarMarkItemElement = $('<span title="(' + util.toSmpteString(item.time * 1000) + ')' + item.text + '" class="markPoint fa fa-markpoint '+ c + '" marktime="' + item.time + '" style="left:' + markPointPixel + 'px;z-index:2;"></span>')[0];
                        _timeBarMarkItemElement.addEventListener("mousedown", function () {
                            app.media.pause();
                            app.media.currentTime = item.time;
                        });
                        $(markPointElement).append(_timeBarMarkItemElement);
                    })
                    if (!flag) {
                        app.undo.push("Add Marker");
                    }
                }


                //media获取Json调用
                _this.getData = function (json) {
                    json.markPoints = [];
                    if (_OperationMenu.dataList && _OperationMenu.dataList.length > 0) {
                        util.forEach(_OperationMenu.dataList, function (m) {
                            var p = util.clone(m);
                            delete p.menu;
                            json.markPoints.push(p);
                        });
                    }
                }
                _this.loadData = function (json) {
                    if (json.markPoints) {
                        _OperationMenu.dataList = json.markPoints;
                        if (_OperationMenu.dataList && _OperationMenu.dataList.length > 0) {
                            util.forEach(_OperationMenu.dataList, function (m) {
                                m.menu = _menuMap[m.name];
                            });
                        }
                        _this.updateMarkPoint(_OperationMenu.dataList, true);
                    }
                }
                _this.addClipMarker = function (markerList) {
                    if (markerList) {
                        _OperationMenu.dataList = _OperationMenu.dataList.concat(markerList);
                        if (_OperationMenu.dataList && _OperationMenu.dataList.length > 0) {
                            util.forEach(_OperationMenu.dataList, function (m) {
                                m.menu = _menuMap[m.name];
                            });
                        }
                        _this.updateMarkPoint(_OperationMenu.dataList);
                    }
                }
                _this.clearData = function () {
                    _OperationMenu.dataList.length = 0;
                    _this.updateMarkPoint([]);
                };
                _this.deleteMarker = function (item) {
                    for (var i = 0, l = _OperationMenu.dataList.length; i < l; i++) {
                        if (_OperationMenu.dataList[i].guid === item.guid) {
                            _OperationMenu.dataList.splice(i, 1);
                            break;
                        }
                    }
                    _this.updateMarkPoint(_OperationMenu.dataList);
                }
                app.trackContainer.element.addEventListener("scroll", _this.updateMarkPointLeft);
                app.addEventListener("zoomchanged", _this.updateMarkPointLeft);


                _this.shortcutKey = new ShortcutKey(app,{
                    inputWindow: _inputWindow,
                    contentElement: _contentElement,
                    menuMap: _menuMap,
                    OperationMenu: _OperationMenu,
                    btnOk: _btnOk,
                    markpointPlugin : _this
                });
                app.Controls.ShortcutKey = _this.shortcutKey;

            },
            name: function () {
                return "MarkPointPlugin";
            }
        });

        return MarkPointPlugin;

    });


h5.define("util/H5ToolbarButton", ["jquery", "util/Object"], function ($, Obj) {
    var H5ToolbarButton = Obj.extend({
        init: function (options) {
            var _element = $("<div>")[0],
                options = options || {},
                _this = this,
                _toggle = options.toggle || false,
                _title= options.title||"",
                _selected = options.selected || false;

            _this._super();

            if (options.split) {
                _element.classList.add("toolbar-split");
            } else {
                _element.classList.add("toolbar-btn");
            }

            if (options.class) {
                _element.classList.add(options.class);
            }
            if (_toggle && _selected) {
                _element.classList.add("selected");
            }

            _element.setAttribute("title", _title);

            _element.addEventListener("click", function () {

                if (_element.classList.contains("disabled")) {
                    return;
                }

                if (options.click) {
                    options.click.call(_this);
                }

                _this.dispatchEvent("click");
            });

            Object.defineProperties(_this, {
                element: {
                    enumerable: true,
                    get: function () {
                        return _element;
                    }
                },
                selected: {
                    enumerable: true,
                    get: function () {
                        return _selected;
                    },
                    set: function (val) {
                        if (val != _selected && _toggle) {
                            var canToggle = true;
                            if (options.beforeChange) {
                                canToggle = options.beforeChange.call(_this, _selected);
                            }
                            if (canToggle) {
                                _selected = val;
                                _element.setAttribute("selected", _selected);
                                if (_selected) {
                                    _element.classList.add("selected");
                                } else {
                                    _element.classList.remove("selected");
                                }
                                _this.dispatchEvent("selectedchanged");
                            }
                        }
                    }
                },
                disabled: {
                    enumerable: true,
                    get: function () {
                        if( _element.classList.contains("disabled")){
                            return true;
                        }
                        return false;
                    },
                    set: function (val) {
                        if (val) {
                            _element.classList.add("disabled");
                        } else {
                            _element.classList.remove("disabled");
                        }
                    }
                }
            });

        }
    });


    return H5ToolbarButton;
});
/*
 * 工具栏标准插件
 */
h5.define("h5plugin/StandardToolbarButtonPlugin", ["core/EditorPluginBase",
    "util/H5ToolbarButton", "plug/Dialog", "util/util"],

    function (EditorPluginBase, H5ToolbarButton, Dialog, util) {
        var NULL_FUNCTION = function(){};
        var StandardToolbarButtonPlugin = EditorPluginBase.extend({
            init: function (app) {
                var _this = this,
                    _media = app.media;

                _this._super(app);

                var projectInfoElement = _this.createToolbarButton("h5-tb-btn-info"),
                    projectInfoButton = new H5ToolbarButton({
                        'class': 'info',
                        title: lang[_curLang].modifyE,
                        click: function () {
                            app.editor.openTrackEventProperty(app.media);
                        }
                    });
                projectInfoElement.appendChild(projectInfoButton.element);

                var newButtonElement = _this.createToolbarButton("h5-tb-btn-new"),
                    newButton = new H5ToolbarButton({
                        'class': 'add',
                        title: lang[_curLang].newN,
                        click: function () {
                            if (_media.isEmpty()) {
                                app.clearInOutpoint();
                                app.create();
                            } else {
                                //是否保存
                                var dialog = new Dialog({
                                    title: lang[_curLang].tip,
                                    content: lang[_curLang].timelineEmpty,
                                    style: 'question', //warn、question、error、succeed
                                    button: lang[_curLang].confirmFlag,//按钮(是/否<Confirm>;确定<Ok>;确定/取消<OkCancel>)
                                    ok: function () {
                                        app.clearInOutpoint();
                                        app.isCreating = true;
                                        app.save(function (b) {
                                            if (b) {
                                                app.create();
                                                app.media.pause();
                                            }
                                        });

                                    },
                                    cancel: function () {
                                        app.clearInOutpoint();
                                        app.create();
                                        app.media.pause();
                                    }
                                });
                                dialog.open();
                            }
                        }
                    });
                newButtonElement.appendChild(newButton.element);


                var clearButtonElement = _this.createToolbarButton("h5-tb-btn-clear"),
                     clearButton = new H5ToolbarButton({
                        'class': 'clear',
                        title: lang[_curLang].clearOut,
                        click: function () {
                            if (_media.isEmpty()) {
                                app.clearInOutpoint();
                            } else {
                                //是否保存
                                var dialog = new Dialog({
                                    title: lang[_curLang].tip,
                                    content: lang[_curLang].clearTimeline,
                                    style: 'question', //warn、question、error、succeed
                                    button: lang[_curLang].confirmFlag,//按钮(是/否<Confirm>;确定<Ok>;确定/取消<OkCancel>)
                                    ok: function () {
                                        app.clearInOutpoint();
                                        app.media.clearAllTrackEvents();
                                        app.markPointPlugin.clearData();
                                        app.media.pause();


                                    },
                                    cancel: function () {

                                    }
                                });
                                dialog.open();
                            }
                        }
                    });
                clearButtonElement.appendChild(clearButton.element);


                var saveButtonElement = _this.createToolbarButton("h5-tb-btn-save"),
                    saveButton = new H5ToolbarButton({
                        'class': 'save',
                        title: lang[_curLang].saveS,
                        click: function () {
                            app.save();
                        }

                    });
                saveButtonElement.appendChild(saveButton.element);

                var split = _this.createToolbarButton("h5-tb-op-undo");
                split.appendChild(new H5ToolbarButton({ split: true }).element);

                var undoButtonElement = _this.createToolbarButton("h5-tb-btn-undo"),
                   undoButton = new H5ToolbarButton({
                       'class': 'undo',
                       title: lang[_curLang].revokeZ,
                       click: function () {
                           app.undo.undo();
                           app.media.pause();
                       }
                   });
                undoButtonElement.appendChild(undoButton.element);

                var redoButtonElement = _this.createToolbarButton("h5-tb-btn-undo"),
                   redoButton = new H5ToolbarButton({
                       'class': 'redo',
                       title: lang[_curLang].redoR,
                       click: function () {
                           app.undo.redo();
                           app.media.pause();

                       }
                   });
                redoButtonElement.appendChild(redoButton.element);


                split = _this.createToolbarButton("h5-tb-op-edit");
                split.appendChild(new H5ToolbarButton({ split: true }).element);

                var textButtonElement = _this.createToolbarButton("h5-tb-btn-text"),
                    textButton = new H5ToolbarButton({
                        'class': 'addtext',
                        title: lang[_curLang].addSubtitleT,
                        click: function () {
                            var curTime = util.roundTime(app.media.currentTime);
                            var track = _media.findTrack('GC');
                            if (track) {
                                //var trackEvent = track.findTrackEventByTime(curTime);
                                //if (trackEvent) {
                                //    var dialog = new Dialog({
                                //        title: lang[_curLang].tip,
                                //        content: lang[_curLang].subtitleExisted,
                                //        style: 'wran', //warn、question、error、succeed
                                //        button: lang[_curLang].ok//按钮(是/否<Confirm>;确定<Ok>;确定/取消<OkCancel>)
                                //    });
                                //    dialog.open();
                                //} else {
                                    app.addTrackEvent('text', {
                                        text: lang[_curLang].addSubtitle,
                                        duration: 10,
                                        start: curTime
                                    });

                               // }
                            }


                        }
                    });
                textButtonElement.appendChild(textButton.element);

                split = _this.createToolbarButton("h5-tb-op-split");
                split.appendChild(new H5ToolbarButton({ split: true }).element);

                var startFrameButtonElement = _this.createToolbarButton("h5-tb-btn-startframe"),
                    startFrameButton = new H5ToolbarButton({
                        'class': 'startframe',
                        title: lang[_curLang].tobegin,
                        click: function () {
                            app.media.startFrame();
                        }
                    });
                startFrameButtonElement.appendChild(startFrameButton.element);

                var prevFrameButtonElement = _this.createToolbarButton("h5-tb-btn-prevframe"),
                    prevFrameButton = new H5ToolbarButton({
                        'class': 'prevframe',
                        title: lang[_curLang].lastFrame,
                        click: function () {
                            app.media.pause();
                            app.media.prevFrame();
                        }
                    });
                prevFrameButtonElement.appendChild(prevFrameButton.element);

                var playButtonElement = _this.createToolbarButton('h5-tb-btn-play'),
                    playButton = new H5ToolbarButton({
                        title: lang[_curLang].playOrPause,
                         toggle: true,
                        'class': 'play',
                        click: function () {
                            if (_media.paused) {
                                _media.play();
                            } else {
                                _media.pause();
                            }
                        }
                    });
                playButtonElement.appendChild(playButton.element);

                var nextFrameButtonElement = _this.createToolbarButton("h5-tb-btn-nextframe"),
                    nextFrameButton = new H5ToolbarButton({
                        'class': 'nextframe',
                        title: lang[_curLang].nextFrame,
                        click: function () {
                            app.media.pause();
                            app.media.nextFrame();
                        }
                    });
                nextFrameButtonElement.appendChild(nextFrameButton.element);

                var endFrameButtonElement = _this.createToolbarButton("h5-tb-btn-endframe"),
                   endFrameButton = new H5ToolbarButton({
                       'class': 'endframe',
                       title: lang[_curLang].toEnd,
                       click: function () {
                           app.media.endFrame();
                       }
                   });
                endFrameButtonElement.appendChild(endFrameButton.element);


                //split = _this.createToolbarButton("h5-tb-op-split");
               // split.appendChild(new H5ToolbarButton({ split: true }).element);

                var inpointButtonElement = _this.createToolbarButton("h5-tb-btn-inpoint"),
                   inpointButton = new H5ToolbarButton({
                       'class': 'inpoint',
                       title: lang[_curLang].inL,
                       toggle:true,
                       click: function () {
                           if (inpointButton.selected) {
                               app.clearInOutpoint();
                           } else {
                               var t = _media.currentTime;
                               var b = app.setInpoint(t);
                               if (!t && b) {
                                   inpointButton.selected = true;
                               }

                           }
                       }
                   });
                inpointButtonElement.appendChild(inpointButton.element);

                var outpointButtonElement = _this.createToolbarButton("h5-tb-btn-outpoint"),
                    outpointButton = new H5ToolbarButton({
                        'class': 'outpoint',
                        title: lang[_curLang].outR,
                        toggle:true,
                        click: function () {
                            if (!inpointButton.selected && !outpointButton.selected) {
                                return;
                            }
                            app.setOutpoint(_media.currentTime);
                        }
                    });
                outpointButtonElement.appendChild(outpointButton.element);

                split = _this.createToolbarButton("h5-tb-op-split");
                split.appendChild(new H5ToolbarButton({ split: true }).element);



                var clipperButtonElement = _this.createToolbarButton("h5-tb-btn-clipper"),
                clipperButton = new H5ToolbarButton({
                    'class': 'clipper',
                    title: lang[_curLang].cut,
                    click: function () {
                    var range = app.getSelectionRange();
                    if (range[0] != range[1]) {
                        app.media.splitTrackEvent(range[0]);
                        app.media.splitTrackEvent(range[1]);
                        app.media.deleteRange(range[1], app.media.duration);
                        app.media.deleteRange(0, range[0]);
                        app.clearInOutpoint();
                        app.media.pause();
                    }
                    else {
                        app.media.splitTrackEvent(app.media.currentTime);
                        app.media.pause();
                    }
                    app.undo.push('split');
                    }
                });
                clipperButtonElement.appendChild(clipperButton.element);

                var deleteButtonElement = _this.createToolbarButton("h5-tb-btn-delete"),
                    deleteButton = new H5ToolbarButton({
                        'class': 'delete',
                        title: lang[_curLang].delete,
                        click: function () {
                            var range = app.getSelectionRange();
                            if (range[0] != range[1]) {
                                app.media.deleteRange(range[0], range[1]);
                                app.clearInOutpoint();
                                app.media.pause();
                            } else {
                                var s = app.media.SelectedTrackEvents;
                                if (s && s.length > 0) {
                                    for (var i = 0; i < s.length; i++) {
                                        var t = s[i];
                                       // t.plugin.removeTrackEvent(t);
                                        t.plugin.removeTrackEvent(t, true);
                                    }
                                }
                                app.media.pause();
                            }
                            app.undo.push('delete');
                        }
                    });
                deleteButtonElement.appendChild(deleteButton.element);

                split = _this.createToolbarButton("h5-tb-op-split");
                split.appendChild(new H5ToolbarButton({ split: true }).element);

                _media.addEventListener("mediapause", function () {
                    playButton.selected = false;
                });
                _media.addEventListener("mediaplay", function () {
                    playButton.selected = true;
                });

                app.undo.addEventListener("undochanged", function () {
                    undoButton.disabled = !app.undo.canUndo();
                    redoButton.disabled = !app.undo.canRedo();
                });
                app.addEventListener("selectionchanged", function () {
                    var r = app.getSelectionRange();
                    if (r[0] === r[1] && r[0] === 0) {
                        inpointButton.selected = false;
                        outpointButton.selected = false;
                        if (app.SelectedTrackEvents && SelectedTrackEvents.length > 0) {
                            if (app.permission.delete) {
                                deleteButton.disabled = false;
                            }
                        } else {

                            deleteButton.disabled = true;
                        }
                    } else {
                        inpointButton.selected = true;
                        if (r[0] !== r[1]) {
                            outpointButton.selected = true;
                        } else {
                            outpointButton.selected = false;
                        }

                        if (app.permission.delete) {
                            deleteButton.disabled = false;
                        }
                    }
                });


                _media.addEventListener("trackeventselectchanged", function (e) {
                    if (e.data && e.data.length > 0) {
                        if (app.permission.delete) {
                            deleteButton.disabled = false;
                        }
                    } else {
                        var r = app.getSelectionRange();
                        if (r[0] === r[1] && r[0] === 0) {
                            //未选择
                            deleteButton.disabled = true;
                        }
                    }
                });
                _media.addEventListener("durationChanged", function () {
                    if (_media.duration === 0) {
                        playButton.disabled = true;
                        saveButton.disabled = true;
                        nextFrameButton.disabled = true;
                        prevFrameButton.disabled = true;
                        clipperButton.disabled = true;
                    } else {
                        playButton.disabled = false;
                        nextFrameButton.disabled = false;
                        prevFrameButton.disabled = false;
                        clipperButton.disabled = false;
                        if (app.permission.save) {
                            saveButton.disabled = false;

                        }
                    }
                });

                app.addEventListener("permissionchanged", function (e) {
                    if (!app.permission.delete) {
                        deleteButton.disabled = true;
                    }
                    if (!app.permission.save) {
                        saveButton.disabled = true;
                    }
                    if (!app.permission.add) {
                        newButton.disabled = true;
                    }

                });

                _media.addEventListener("mediawaiting", function () {
                    playButton.disabled = true;
                });
                _media.addEventListener("mediacanplaythrough", function () {
                    playButton.disabled = false;
                });

            },
            name: function () {
                return 'StandardToolbarButtonPlugin';
            }
        });

        return StandardToolbarButtonPlugin;
    });
/*
 * 权限定义
 */
h5.define("core/Permission", [], function () {
    var Permission = function (app) {
        var _this = this,
        _permission = {
            addTrackEvent: false, //能否添加
            add: false,
            save: false,
            markpoint: false,
            cut: false,
            delete: false,
            inoutpoint: false,
            edit: false
        };

        _this.readonly = function (b) {
            for (var key in _permission) {
                _permission[key] = !b;
            }

            app.dispatchEvent("permissionchanged", _this);
        }

        _this.setPermission = function (options) {
            for (var key in _permission) {
                if (typeof options[key] !== "undefined") {
                    _permission[key] = options[key];
                }
            }

            app.dispatchEvent("permissionchanged", _this);
        }

        Object.defineProperties(_this, {
            add: {
                enumberable: true,
                get: function(){
                    return _permission.add;
                }
            },
            addTrackEvent: {
                enumberable: true,
                get: function () {
                    return _permission.addTrackEvent;
                }
            },
            cut: {
                enumberable: true,
                get: function () {
                    return _permission.cut;
                }
            },
            'delete': {
                enumberable: true,
                get: function () {
                    return _permission.delete;
                }
            },
            edit: {
                enumberable: true,
                get: function () {
                    return _permission.edit;
                }
            },
            inoutpoint: {
                enumberable: true,
                get: function () {
                    return _permission.inoutpoint;
                }
            },
            markpoint: {
                enumberable: true,
                get: function () {
                    return _permission.markpoint;
                }
            },
            save: {
                enumberable: true,
                get: function () {
                    return _permission.save;
                }
            }
        });
    };


    return Permission;
});
h5.define("util/Guid", [], function () {
    var Guid = function (g) {
        var arr = new Array(); //存放32位数值的数组

        if (typeof (g) == "string") { //如果构造函数的参数为字符串
            InitByString(arr, g);
        }
        else {
            InitByOther(arr);
        }
        //返回一个值，该值指示 Guid 的两个实例是否表示同一个值。

        this.Equals = function (o) {
            if (o && o.IsGuid) {
                return this.ToString() == o.ToString();
            }
            else {
                return false;
            }
        }
        //Guid对象的标记

        this.IsGuid = function () { }
        //返回 Guid 类的此实例值的 String 表示形式。

        this.ToString = function (format) {
            if (typeof (format) == "string") {
                if (format == "N" || format == "D" || format == "B" || format == "P") {
                    return ToStringWithFormat(arr, format);
                }
                else {
                    return ToStringWithFormat(arr, "D");
                }
            }
            else {
                return ToStringWithFormat(arr, "D");
            }
        }
        //由字符串加载
        function InitByString(arr, g) {
            g = g.replace(/\{|\(|\)|\}|-/g, "");
            g = g.toLowerCase();
            if (g.length != 32 || g.search(/[^0-9,a-f]/i) != -1) {
                InitByOther(arr);
            }
            else {
                for (var i = 0; i < g.length; i++) {
                    arr.push(g[i]);
                }
            }
        }
        //由其他类型加载

        function InitByOther(arr) {
            var i = 32;
            while (i--) {
                arr.push("0");
            }
        }
        /*
        根据所提供的格式说明符，返回此 Guid 实例值的 String 表示形式。

        N  32 位： xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
        D  由连字符分隔的 32 位数字 xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
        B  括在大括号中、由连字符分隔的 32 位数字：{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
        P  括在圆括号中、由连字符分隔的 32 位数字：(xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
        */
        function ToStringWithFormat(arr, format) {
            switch (format) {
                case "N":
                    return arr.toString().replace(/,/g, "");
                case "D":
                    var str = arr.slice(0, 8) + "-" + arr.slice(8, 12) + "-" + arr.slice(12, 16) + "-" + arr.slice(16, 20) + "-" + arr.slice(20, 32);
                    str = str.replace(/,/g, "");
                    return str;
                case "B":
                    var str = ToStringWithFormat(arr, "D");
                    str = "{" + str + "}";
                    return str;
                case "P":
                    var str = ToStringWithFormat(arr, "D");
                    str = "(" + str + ")";
                    return str;
                default:
                    return new Guid();
            }
        }
    }
    //Guid 类的默认实例，其值保证均为零。

    Guid.Empty = new Guid();
    //初始化 Guid 类的一个新实例。

    Guid.NewGuid = function () {
        var g = "";
        var i = 32;
        while (i--) {
            g += Math.floor(Math.random() * 16.0).toString(16);
        }
        return new Guid(g);
    }

    return Guid;


});
h5.define('core/Undo', ["util/util", "util/Object"], function (util, EventObject) {
    var Undo = EventObject.extend({
        init: function (app, media, opt) {
            var _app = app,
                _media = media,
                _options = opt || {},
                _stepChanged =false,
                _maxCount = opt.max || 11,
                _doing =false,
                _this = this;

            _this._super();

            var _undoList = [],
                _current = 0,
                _id = 0;


            function loadTimeline(json) {
                _doing = true;
                _media.paused = true;
                var ctime = _media.currentTime;
                _media.clear();
                _media.json = json;

                if (ctime > _media.duration) {
                    ctime = _media.duration;
                }
                _media.currentTime = ctime;

                _doing = false;
            }

            _this.clear = function () {
                _undoList.length = 0;
                _id = 0;
                _current = 0;

                _this.dispatchEvent("undochanged");
            };
            function deepCompare(obj1, obj2) {
                if (obj1 && typeof obj1 === 'object' && obj2 && typeof obj2 === 'object') {
                    for (key in obj1) {
                        if (obj1[key] != obj2[key]) {
                            if (typeof obj1[key] == 'object') {
                                if (deepCompare(obj1[key], obj2[key])) {

                                }
                                else {
                                    return false;
                                }
                            }
                            else {
                                return false;
                            }
                        }
                    }
                    for (key in obj2) {
                        if (obj1[key] != obj2[key]) {
                            if (typeof obj2[key] == 'object') {
                                if (deepCompare(obj1[key], obj2[key])) {

                                }
                                else {
                                    return false;
                                }
                            }
                            else {
                                return false;
                            }
                        }
                    }
                }
                else {
                    return obj1 == obj2;
                }
                return true;
            }
            _this.push = function (name, list) {
                if (_doing)
                    return;

                //_undoList.splice(0, _current);
                name = name || lang[_curLang].operation;
                _id++;
                if (!_undoList[0] || (_undoList[0] &&(!deepCompare(_media.json.markPoints, _undoList[0].json.markPoints) || !deepCompare(_media.json.tracks, _undoList[0].json.tracks)))) {
                    _undoList.splice(0, 0, { name: name, id: _id, json: _media.json });
                }
                if (_undoList.length > _maxCount) {
                    _undoList.splice(_undoList.length - 1, 1);
                }
                _current = 0;
                _this.dispatchEvent("undochanged");
            };

            _this.undo = function (id) {
                if (_undoList.length > 0) {

                    if (_current < (_undoList.length - 1)) {
                        _current++;

                        var item = _undoList[_current];
                        loadTimeline(item.json);
                        _this.dispatchEvent("undochanged");
                    }

                }
            };

            _this.redo = function (id) {

                if (_undoList.length > 0) {

                    if (_current >0 ) {
                        _current--;

                        var item = _undoList[_current];
                        loadTimeline(item.json);
                        _this.dispatchEvent("undochanged");
                    }
                }

            };

            _this.canUndo = function () {
                if (_undoList.length > 0 && _current < (_undoList.length - 1)) {
                    return true;
                }
                return false;
            };
            _this.canRedo = function () {
                if (_undoList.length > 0 && _current>0) {
                    return true;
                }
                return false;
            };
        }
    });




    return Undo;
});
/// <reference path="jquery.js" />
/*
 * 入口
 */
h5.define('H5Editor', ['jquery',
    'util/Object',
    'templates/H5EditorLayout',
    'util/H5ResizeHandler',
    'timeline/H5PlayerPanel',
    'util/H5Toggler',
    'core/Media',
    'timeline/H5Media',
    "util/H5DragDrop",
    "core/TrackEventPluginManager",
    "core/EditorPluginManager",
    "editor/Editor",
    "plug/H5OperationMenu",
    "plug/H5OpMenuLi",
    "h5plugin/PropertyPanelPlugin", //默认插件， 用于显示TrackEvent的属性
    "h5plugin/MarkPointPlugin", //标记点插件
    "h5plugin/StandardToolbarButtonPlugin", //工具栏按钮插件
    'plug/Dialog',
    "core/Permission",
    "util/Guid",
    "util/util",
    "util/H5ToolbarButton",
    "util/H5Window",
    "util/H5Scrollbar",
    "core/EditorPluginBase",
    "editor/TrackEventEditor",
    "core/Undo",
    "plug/ShortcutKey"],
    function ($, Obj, H5_EDITOR_LAYOUT, H5ResizeHandler,
        H5PlayerPanel,
        H5Toggler, Media, H5Media, H5DragDrop, PluginManager,
        EditorPluginManager, Editor, H5OperationMenu, H5OpMenuLi,
        PropertyPanelPlugin, MarkPointPlugin, StandardToolbarButtonPlugin,
        Dialog,Permission, Guid, util,
        H5ToolbarButton, H5Window, H5Scrollbar, EditorPluginBase,
        TrackEventEditor,Undo, ShortcutKey) {


        function browser(app) {
            var nav =window.navigator,
                ua = nav.userAgent.toLowerCase();

            app.isiPad = (ua.match(/ipad/i) !== null);
            app.isiPhone = (ua.match(/iphone/i) !== null);
            app.isiOS = app.isiPhone || app.isiPad;
            app.isAndroid = (ua.match(/android/i) !== null);
            app.isBustedAndroid = (ua.match(/android 2\.[12]/) !== null);
            app.isBustedNativeHTTPS = (location.protocol === 'https:' && (ua.match(/android [12]\./) !== null || ua.match(/macintosh.* version.* safari/) !== null));
            app.isIE = (nav.appName.toLowerCase().indexOf("microsoft") != -1 || nav.appName.toLowerCase().match(/trident/gi) !== null);
            app.isChrome = (ua.match(/chrome/gi) !== null) && ua.match(/edge/gi)== null;  //Microsoft  edge
            app.isChromium = (ua.match(/chromium/gi) !== null);
            app.isFirefox = (ua.match(/firefox/gi) !== null);
            app.isWebkit = (ua.match(/webkit/gi) !== null);
            app.isGecko = (ua.match(/gecko/gi) !== null) && !app.isWebkit && !app.isIE;
            app.isOpera = (ua.match(/opera/gi) !== null);
            app.hasTouch = ('ontouchstart' in window);
        }

        var _name_no = 1;
        var NULL_FUNCTION = function () { };

        var H5Editor = Obj.extend({
            /*
             * {object{ opt: 配置选项
             *      {string} elementId: 作为H5时间线的容器元素id
             *      {number} maxRedo:   最大可撤销的步数
             *      {string} topElementId:  H5上方元素容器，即拖动改变编辑器高度时，关联的上方元素
             *      {string} mlElementId:   素材列表容器元素
             *      {string} playerElementId: 播放器容器元素
             *      {string} title: 编辑器标题文字
             *      {Array} initTracks:    初始化时的归档布局
             *      {object} panelOptions: 右侧显示面板配置
             *           {number} minWidth： 最小宽度
             *           {number} initWidth: 初始化宽度
             *           {object}    infoPanel: 信息窗口配置
             *                           {number} minWidth: 最小宽度
             *                           {number} maxWidth:  最大宽度
             *                           {number} initWidth: 初始化宽度
             *           {object}    playerPanel: 播放器窗口配置
             *                           {number} minWidth: 最小宽度
             *                           {number} sizes： 幅面信息
             *      {Object} service: 素材相关服务
             *            {function}    save：保存时间线方法，参数(@media, @callback) save方法执行完成后必须调用callback方法
             *            {function}    getobject: 获取对象详细信息，参数(@app, @objectid, @callback)
             *            {function}    getsignurl: 更新媒体文件签名，参数（@fileid , @查询字符串， @callback)
             */
            init: function (opt) {
                var _this = this;
                var parent = $("#" + opt.elementId);
                var top = $("#" + opt.topElementId);
                var node = $(H5_EDITOR_LAYOUT);
                parent.append(node.find("*"));
                this.rootElement = parent[0];
                this.service = opt.service || {};
                this.permission = new Permission(this);
                this.logger = opt.logger;
                this.useCros = (typeof opt.useCros == 'undefined') ? true : opt.useCros;

                this.useCanvas = opt.useCanvas || false;
                var _options = util.clone(opt);

                this._super();

                Object.defineProperties(_this, {
                    options: {
                        get: function(){
                            return _options;
                        }
                    }
                });



                //常用控件
                this.Controls = {
                    H5OperationMenu : H5OperationMenu,
                    H5OpMenuLi: H5OpMenuLi,
                    H5ToolbarButton: H5ToolbarButton,
                    H5Window: H5Window,
                    H5Scrollbar: H5Scrollbar,
                    Dialog: Dialog,
                    Guid: Guid,
                    EditorPluginBase: EditorPluginBase,
                    TrackEventEditor: TrackEventEditor
                };


                //播放器
                var playerLeft = $("#" + opt.mlElementId);
                var player = $("#" + opt.playerElementId);

                player.addClass("h5");
                parent[0].classList.add("h5");

                //屏蔽编辑器右键菜单
                document.onselectstart =  document.oncontextmenu = function (e) {
                    if (window.event) {
                        e = window.event;
                    }
                    var isEditor = false;
                    var e = e.srcElement;

                    while (e) {
                        if (e === parent[0] || e === player[0]) {
                            isEditor = true;
                            break;
                        }
                        e = e.parentElement;
                    }
                    if (isEditor) {
                        e.returnValue = false;
                        return false;
                    }

                };


                //插件管理
                var editorPlugin = _this.editorPlugin = new EditorPluginManager(this);

                var panelOptions = opt.panelOptions || {};
                var defaultOptions = {
                    minWidth: 860,   //播放器最小宽度
                    initWidth: Math.max( player.width(), 680),//播放器初始宽度
                    slidingElement: playerLeft[0],
                    parentElement: player[0],
                    infoPanel: {
                        minWidth: 5,
                        maxWidth: 0,
                        initWidth: 280,
                    },
                    playerPanel: {
                        minWidth: 580,
                        sizes: "16:9"
                    }
                };
                this._defaultSizes = defaultOptions.playerPanel.sizes;
                util.merge( defaultOptions, panelOptions);


                //播放器面板
                var playerPanel = _this.playerPanel = new H5PlayerPanel(_this, editorPlugin, defaultOptions);


                //默认插件
                var propertyPanel = editorPlugin.registerPlugin(PropertyPanelPlugin);
                this.propertyPanel = propertyPanel;


                var minHeight = 43;  //编辑器最小高度
                var minimized = false; //初始化时是否最小化
                var trayHeight = parent.height();  //编辑器初始高度
                if (!trayHeight) {
                    trayHeight = 175;
                }



                //编辑器大小调整控件
                var resizeHandler = new H5ResizeHandler({
                    margin: 26,
                    border: 15,
                    minimized: minimized,
                    minHeight: minHeight,
                    initHeight: trayHeight,
                    firstElement: top[0],
                    handlerElement: parent[0],
                    resize: function () {
                        _this.dispatchEvent('resize');
                    }
                });
                //动画完成后触发resize事件
                util.applyTransitionEndListener(parent[0], function (e) {
                    if (e && e.srcElement == parent[0]) {
                        _this.dispatchEvent('resize');
                    }
                });
                window.addEventListener('resize', function () {
                    _this.dispatchEvent('resize');
                }, false);


                //编辑器最小化按钮
                var _toggler = new H5Toggler(parent.find(".toggle-button")[0], function () {
                    _toggler.state = !_toggler.state;
                    resizeHandler.minimize(_toggler.state);

                });
                _toggler.state = minimized;

                //层


                var tracksAreaElement = parent.find(".tracks-area");
                this.tracksAreaElement = tracksAreaElement[0];

                var timebarAreaElement = parent.find('.status-area');
                this.timebarAreaElement = timebarAreaElement[0];

                //timeline中赋值
                this.piexelToTime = function () { };
                this.timeToPixel = function () { };

                var app = this;

                var media = this.media = new Media(app, {
                    target: playerPanel.videoPanel
                });

                var editor = _this.editor = new Editor(this, propertyPanel.root);


                //浏览器类型
                browser(app);

                var mediaUi = _this.mediaUi = new H5Media(app, media);

                var initTracks = ['GC', 'GC', 'PIC', 'VA'];
                if (this.options && this.options.initTracks) {
                    initTracks = this.options.initTracks;
                }
                for (var i = 0; i < initTracks.length; i++) {
                    this.media.addTrack(null, false, initTracks[i]);
                }
                media.url = "#t=0,0";

                mediaUi.update();

                //撤销
                var maxStep = opt.maxRedo || 100;
                _this.undo = new Undo(_this, media, { max: maxStep });

                //工具栏按钮插件
                this.toolbarButtons = editorPlugin.registerPlugin(StandardToolbarButtonPlugin);
                this.markPointPlugin = editorPlugin.registerPlugin(MarkPointPlugin);

                this.permission.readonly(false);
                this.dispatchEvent("ready");

            },
            clear: function () {
                if (this.media) {
                    this.media.clear();


                    if (this.editorPlugin) {
                        var pl = this.editorPlugin.getPluginList();
                        for (var p in pl) {
                            if (pl[p].clearData) {
                                pl[p].clearData();
                            }
                        }
                    }
                }
                this.undo.clear();
            },
            create: function () {
                if (this.media) {
                    this.clear();

                    var name = "Unnamed";
                    _name_no++;
                    document.querySelector("#mvTimeLineTitle").innerText = name;
                    this.timeLineId = '';
                    this.edlPath = '';
                    var initTracks = ['GC', 'GC', 'PIC', 'VA'];
                    if (this.options && this.options.initTracks) {
                        initTracks = this.options.initTracks;
                    }

                    for (var i = 0; i < initTracks.length; i++) {
                        this.media.addTrack(null, false, initTracks[i]);
                    }

                    this.media.url = "#t=0,0";
                    this.mediaUi.update();

                    this.media.update({
                        name: name,
                        id: Guid.NewGuid().ToString("N"),
                        sizes: this._defaultSizes

                    });

                    this.media.updateDuration();
                    this.media.currentTime = 0;
                    this.media.saved = false;
                    this.editor.openTrackEventProperty(this.media);
                    this.dispatchEvent("createnew");
                    this.undo.push(lang[_curLang].create);
                }
            },
            save: function (callback) {
                callback = callback || function () { };
                var _media = this.media;
                var dialog = null;
                if (_media.isEmpty()) {
                    dialog = new Dialog({
                        title: lang[_curLang].tip,
                        content: lang[_curLang].timelineEmptyNotSave,
                        style: 'warn',
                        button: lang[_curLang].ok
                    });
                    dialog.open();
                    callback.call(this, false);
                    return;
                }
                var json = _media.json;
                var _this = this;
                if (this.service && this.service.save) {
                    this.service.save.call(this, json,{}, function (b, obj) {
                        callback.call(this, b);
                    });
                } else {
                    dialog = new Dialog({
                        title: lang[_curLang].errorUp,
                        content: lang[_curLang].notSetSaveMethod,
                        style: 'warn',
                        button: lang[_curLang].ok
                    });
                    dialog.open();
                    callback.call(this, false);
                }
                this.dispatchEvent('save', _media);
            },
            initDrag: function (options) {
                var options = options || {},
                    clipSelector = options.clipSelector || '.video',
                    textSelector = options.textSelector || '.text',
                    imageSelector = options.imageSelector || '.image',
                    effectSelector = options.effectSelector || '.effect',
                    transitionSelector = options.transitionSelector || '.transition',
                    maskSelector = options.maskSelector || '.mask',
                    _this = this,
                   _callback = options.callback || NULL_FUNCTION;
               // H5DragDrop.clear();
                function setupDrag(type, selector) {
                    var plugin = PluginManager.getPlugin(null, type, null);
                    if (!plugin)
                        return;
                    $(selector).each(function (i, e) {


                        var dragElement = H5DragDrop.helper(e, {
                            start: function (e, helper) {
                                if (helper && helper.data) {
                                    helper.data.pos = [e.offsetX, e.offsetY];
                                }
                            },
                            stop: function (e, helper) {
                                _this.mediaUi.hideTrackHolder();
                            }
                        });

                        dragElement.data = plugin.parseData(e);
                        dragElement.data.type = "plugin";
                        dragElement.data.plugin = type;

                        var ele = $(e);
                        var ds = { width: ele.width(), height: ele.height() };
                        if (plugin.dragStyle) {
                            ds = plugin.dragStyle();
                        }
                        dragElement.data.width = ds.width;
                        dragElement.data.height = ds.height;
                        _callback.call(_this, dragElement.data);
                    });
                }

                setupDrag('video', clipSelector);
                setupDrag('image', imageSelector);
                //setupDrag('text', textSelector);
                //setupDrag('effect', effectSelector);
                //setupDrag('transition', transitionSelector);
                //setupDrag('mask', maskSelector);
                //$('.doc').each(function (i, e) {


                //    var dragElement = H5DragDrop.helper(e, {
                //        start: function (e, helper) {
                //            if (helper && helper.data) {
                //                helper.data.pos = [e.offsetX, e.offsetY];
                //            }
                //        },
                //        stop: function (e, helper) {
                //            _this.mediaUi.hideTrackHolder();
                //        }
                //    });

                //    var ele = $(e);
                //    var data = {
                //        data: {
                //            sourceid: ele.data("source-id"),
                //            clipid: ele.data("id"),
                //            duration: +ele.data("duration") //结束位置
                //        }
                //    };

                //    dragElement.data = data;
                //    dragElement.data.type = "plugin";
                //    dragElement.data.plugin = 'listitem';

                //    var ds = { width: ele.width(), height: ele.height() };
                //    dragElement.data.width = ds.width;
                //    dragElement.data.height = ds.height;
                //    _callback.call(_this, dragElement.data);
                //});


            },
            readonly: function (val) {
                this.permission.readonly(val);
            },
            setPermission: function (options) {
                this.permission.setPermission(options);
            },
            addTrackEvent: function (type, objectInfo) {
                var _track,
                    _dropType,
                    _plugin,
                    _type,
                    _media = this.media,
                    _typeMap = {
                        video: 'VA',
                        image: 'PIC',
                        text: 'GC',
                        audio: 'A',
                        effect: 'ET',
                        mask:'VA'
                    };

                    _track = _media.findTrack(_typeMap[type]);
                    _type = 'plugin';
                    _dropType = type;
                    objectInfo.start = objectInfo.start || _media.currentTime;
                    _plugin = PluginManager.getPlugin(_type, _dropType, objectInfo);



                if (objectInfo.detail) {
                    objectInfo.detail.__id = objectInfo.clipid;
                }

                _track.view.dispatchEvent("plugindropped", {
                    start: objectInfo.start,
                    plugin: _plugin,
                    oEvent: {},
                    track: _track,
                    dragData: objectInfo,
                    left: 0,
                    dropType: _dropType,
                    type: _type,
                    data: objectInfo,
                    width: 30,
                    height: 30,
                    pos: [0, 0]
                });
            },
            load: function (p) {
                if (typeof p === "string") {
                    p = JSON.parse(p);
                }
                this.clear();
                this.media.json = p;
            }
        });
        return H5Editor;
    });


window.h5 = window.h5 || {};

window.h5.onReady = function (callback) {
    if (window.H5Editor) {
        if (callback) {
            callback(window.H5Editor);
        }
    } else {
        h5.require(["H5Editor"], function (H5Editor) {
            window.H5Editor = H5Editor;
            if (callback) {
                callback(H5Editor);
            }
        });
    }
};
